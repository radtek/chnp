/*
Navicat MySQL Data Transfer

Source Server         : mdb
Source Server Version : 50713
Source Host           : localhost:3306
Source Database       : chngzhen

Target Server Type    : MYSQL
Target Server Version : 50713
File Encoding         : 65001

Date: 2019-01-29 18:00:21
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for answer
-- ----------------------------
DROP TABLE IF EXISTS `answer`;
CREATE TABLE `answer` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '方案ID',
  `issue_id` int(11) DEFAULT NULL COMMENT '问题ID',
  `content` text COMMENT '解决方案',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `user_id` int(11) DEFAULT NULL COMMENT '用户ID',
  `use_times` int(5) DEFAULT NULL COMMENT '引用次数',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=16 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of answer
-- ----------------------------
INSERT INTO `answer` VALUES ('1', '1', '在head标签内添加：```<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">```', '2017-10-18 11:07:19', '1', '0');
INSERT INTO `answer` VALUES ('2', '2', '测试<meta>', '2017-10-18 07:30:36', '1', '0');
INSERT INTO `answer` VALUES ('3', '2', 'cehi', '2017-10-18 07:31:46', '1', '0');
INSERT INTO `answer` VALUES ('4', '1', '在head标签内添加以下代码：\n```\n<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n```\nJSP页面可添加以下代码：\n```\n<%@ page language=\"java\" import=\"java.util.*\" pageEncoding=\"UTF-8\"%>\n```', '2017-10-18 07:59:34', '1', '0');
INSERT INTO `answer` VALUES ('5', '3', '1. 下载Tomcat免安装压缩包\n2. 将压缩包解压至指定路径下。如E:\\tomcats\\tomcat01\n3. 添加系统环境变量。如CATALINA_HOME01=E:\\tomcats\\tomcat01\n4. 将（E:\\tomcats\\tomcat01\\）bin文件夹下的catalina.bat、startup.bat和shutdown.bat文件中的CATALINA_HOME字符串全部替换成CATALINA_HOME01\n5. 将config文件夹下的server.xml中的Server节点和Connector节点的port修改成空闲的端口。如10010、10011\n6. 运行bin文件夹下的startup.bat', '2017-10-18 08:35:25', '1', '0');
INSERT INTO `answer` VALUES ('6', '4', '1. 下载RPM\n```\n$ wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm\n```\n2. 安装RPM\n```\n$ rpm -ivh mysql-community-release-el7-5.noarch.rpm\n```\n3. 安装MySQL\n```\n$ sudo yum install mysql-server\n```\n4. 启动MySQL\n```\n$ service mysqld start\n```\n5. 登陆MySQL\n```\n$ mysql -u root -p\n```\n如果报错，可运行以下指令：\n```\n$ sudo chown -R [username]:[usergroup] /var/lib/mysql\n```\n然后重启MySQL：\n```\n$ service mysqld restart\n```\n再尝试登陆。\n6. 重置密码\n```\n$ mysql -u root\nmysql > use mysql;\nmysql > update user set password=password(‘123456‘) where user=‘root‘;\nmysql > exit;\n```\n7. 开放端口\n```\n$ sudo vim /etc/sysconfig/iptables\n```\n添加以下内容：\n```\n-A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT\n```\n保存后重启防火墙：\n```\n$ sudo service iptables restart\n```', '2017-10-20 04:47:32', '1', '0');
INSERT INTO `answer` VALUES ('7', '5', '方案一：固定DIV长度，左右留白auto，可设置水平居中；上下利用留白或填充可设置垂直高度。\n```\n<div style=\"width:60%;margin:10% auto 0 auto;\">\n	<input>\n</div>\n```\n方案二：固定容器的高度，利用Flex布局。\n```\n<div style=\"height:100px;display:-webkit-flex;display:flex;justify-content:center;align-items:center;\">\n	<div>\n		<input>\n	</div>\n</div>\n```', '2017-10-20 04:53:27', '1', '0');
INSERT INTO `answer` VALUES ('8', '6', '```\n$(\"input\").on(\"input propertychange\", function(e) {\n    console.log($(this).val());\n});\n```', '2017-10-20 04:55:00', '1', '0');
INSERT INTO `answer` VALUES ('9', '7', '```\nlet result = $.merge(array1, array2);\n```\n注意：$.merge(firstArray, secondArray)除了返回合并后的结果，还会用结果覆盖firstArray的值，也就是说，执行完上面的代码后，array1==result。', '2017-10-20 04:56:32', '1', '0');
INSERT INTO `answer` VALUES ('10', '8', 'replace方法支持正则表达式，也就是说，可以利用正则表达式找到目标字符串内所有符合的字符串，并把它们替换掉：\n```\nstr.replae(/\\$/g, \"\"); // 正则表达式包裹在两个斜杠之间。g表示全部替换\n```\n注意：jQuery里面有个RegExp类，用它构造的正则表达式对象在替换时会保留原字符串。', '2017-10-20 04:58:13', '1', '0');
INSERT INTO `answer` VALUES ('11', '9', '可能是Tomcat缓存的原因。Tomcat会在根目录下的work/Catalina/localhost/中缓存项目的一些内容，可以把它删掉后，再前往webapps/删掉旧项目，重新发布即可', '2017-10-23 02:03:57', '1', '0');
INSERT INTO `answer` VALUES ('12', '10', '```\n\'use strict\';\n$.fn.autoHide = function() {\n	let $this = $(this);\n	$(document).on(\"click\", function(e) {\n		if( $this.is(\":visible\") && (!$(e.target)[0].isEqualNode($this[0]) && $this.has(e.target).length===0) ) $this.hide();\n		e.stopPropagation();\n		return false;\n	});\n	return this;\n}\n```\n调用方式：\n```\n$(\"#btn\").on(\"click\", function(e) {\n	$(\"#div\").toggle().autoHide();\n	return false;\n})\n```', '2017-10-23 13:46:23', '1', '0');
INSERT INTO `answer` VALUES ('13', '11', '去任务管理器删除adb.exe进程试试', null, '1', '0');
INSERT INTO `answer` VALUES ('14', '12', '单击`File`->`Project Structure`->`Modules`，将每个模块`Sources`选项卡下的`Language Level`提高', null, '1', '0');
INSERT INTO `answer` VALUES ('15', '12', '在pom.xml手动指定编译版本：\n```\n<plugin>\n    <groupId>org.apache.maven.plugins</groupId>\n    <artifactId>maven-compiler-plugin</artifactId>\n    <version>3.5</version>\n    <configuration>\n        <source>1.8</source>\n        <target>1.8</target>\n    </configuration>\n</plugin>\n```', null, '1', '0');

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '文章ID',
  `title` varchar(50) DEFAULT NULL COMMENT '文章标题',
  `author_id` int(11) DEFAULT NULL COMMENT '文章作者',
  `create_time` datetime DEFAULT NULL COMMENT '发表时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `type` int(1) DEFAULT NULL COMMENT '文章类型',
  `content` longtext COMMENT '文章内容',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article
-- ----------------------------

-- ----------------------------
-- Table structure for blog
-- ----------------------------
DROP TABLE IF EXISTS `blog`;
CREATE TABLE `blog` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT 'ID',
  `type` int(1) DEFAULT NULL COMMENT '博客类型：1-原创，2-转载，3-翻译',
  `title` varchar(255) DEFAULT NULL COMMENT '标题',
  `summary` varchar(255) DEFAULT NULL COMMENT '博客摘要',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `read_times` int(5) DEFAULT '0' COMMENT '阅读次数',
  `comments` int(5) DEFAULT '0' COMMENT '评论数量',
  `author` int(11) DEFAULT NULL COMMENT '作者',
  `create_time` datetime DEFAULT NULL COMMENT '发布时间',
  `content` longtext COMMENT '内容',
  `status` int(1) DEFAULT '1' COMMENT '状态:0-删除，1-对外可见，2-对外隐藏',
  `group_id` int(11) DEFAULT NULL COMMENT '分类',
  PRIMARY KEY (`id`),
  KEY `fk_blog_groupId` (`group_id`)
) ENGINE=InnoDB AUTO_INCREMENT=23 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog
-- ----------------------------
INSERT INTO `blog` VALUES ('1', '1', '【解决方案】搭建基础Web项目', '测试简介', '2017-10-25 11:47:37', '32', '0', '1', '2017-10-09 10:43:08', '# 1 修改记录\n|时间|描述|\n|--|--|\n|2017-08-27|描述|\n\n# 2 正文内容\n本文章尽可能地最少使用JAR包依赖和配置，以完成一个简单的、基于Spring框架的Web项目。\n\n## 2.1 添加依赖\nspring框架中涉及到Web的模块是spring-web、spring-webmvc、spring-websocket和spring-webmvc-portlet：\n\n- spring-web：模块提供了面向Web的基本集成特性。例如多段上传文件功能、利用Servlet监听器初始化IOC容器以及面向Web的应用程序上下文，此外还包括HTTP客户端和Spring远程支持中与Web相关的部分；\n\n- spring-webmvc：模块提供了MVC和REST Web服务的实现。Spring的MVC框架严格分离了Domain模型代码和Web表单，并集成了Spring框架的其他特性；\n\n```\n<dependency>\n	<groupId>org.springframework</groupId>\n	<artifactId>spring-webmvc</artifactId>\n	<version>4.3.9.RELEASE</version>\n</dependency>\n```\n\n## 2.2 配置web.xml\nweb.xml是上下文初始化的入口。\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"\n		xmlns:jsp=\"http://java.sun.com/xml/ns/javaee/jsp\"\n		xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee\n							http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\">\n\n	<servlet>\n		<description>spring mvc servlet</description>\n		<servlet-name>springMvc</servlet-name>\n		<servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n		<!--指明了配置文件的文件名，不使用默认配置文件名，而使用dispatcher-servlet.xml配置文件。-->\n		<!--其中<param-value>**.xml</param-value> 这里可以使用多种写法-->  \n		<!--  1、不写,使用默认值:/WEB-INF/<servlet-name>-servlet.xml-->  \n		<!--  2、<param-value>/WEB-INF/classes/[fileName].xml</param-value>-->  \n		<!--  3、<param-value>classpath*:[fileName].xml</param-value>-->  \n		<!--  4、多个值用逗号分隔-->\n		<init-param>\n			<description>spring mvc 配置文件</description>\n			<param-name>contextConfigLocation</param-name>\n			<param-value>classpath:spring/spring-mvc.xml</param-value>\n		</init-param>\n		<load-on-startup>1</load-on-startup>\n		<async-supported>true</async-supported>\n	</servlet>\n	<servlet-mapping>\n		<servlet-name>springMvc</servlet-name>\n		<url-pattern>/</url-pattern>\n	</servlet-mapping>\n</web-app>\n```\n\n## 2.3 配置spring-mvc.xml\nspring-mvc.xml文件集合了和MVC框架相关的配置。例如扫描Controller层、解析视图等。\n\n- ContentNegotiatingViewResolver：根据请求的文件名或Accept的头信息去解析指定的视图文件。但是，该类自己不会解析视图，而是委派给其他视图解析实现类。可以自动通过应用程序上下文自动分配，也可以通过viewResolvers属性设置。\n\n- InternalResourceViewResolver：继承自UrlBasedViewResolver，支持解析InternalResourceView及其子类，如JstlView。可以通过viewClass设置，默认是InternalResourceView，如果JSTL API可用则默认是JstlView。该类通过URL寻找视图文件，通过prefix和suffix分别设置URL的前缀和后缀，结合Controller返回的\n\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n		xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n		xmlns:p=\"http://www.springframework.org/schema/p\"\n		xmlns:context=\"http://www.springframework.org/schema/context\"\n		xsi:schemaLocation=\"http://www.springframework.org/schema/beans \n							http://www.springframework.org/schema/beans/spring-beans-4.0.xsd \n							http://www.springframework.org/schema/context \n							http://www.springframework.org/schema/context/spring-context-4.0.xsd\">\n	\n	<!-- 自动扫描controller包下的所有类，使其认为spring mvc的控制器 -->\n	<context:component-scan base-package=\"chngzhen.**.controller\" use-default-filters=\"false\">\n		<context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/>\n	</context:component-scan>\n	\n	<!-- 视图解析 -->\n	<bean class=\"org.springframework.web.servlet.view.ContentNegotiatingViewResolver\">\n		<property name=\"viewResolvers\">\n			<list>\n			    <bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\">\n			        <property name=\"prefix\" value=\"/pages\"/>\n			        <property name=\"suffix\" value=\".jsp\"/>\n			    </bean>\n			</list>\n		</property>\n	</bean>\n</beans>\n```\n\n## 2.4 添加视图文件\n在src/main/webapp路径下新建pages文件夹，并添加index.jsp文件：\n```\n<html>\n	<body>\n		<h2>Hello World!</h2>\n	</body>\n</html>\n```\n\n## 2.5 设计Controller\n通过地址http://127.0.0.1:8080/pdms/test访问index.jsp文件：\n\n```\npackage chngzhen.pdms.web.controller;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\n\n@Controller\n@RequestMapping(\"/test\")\npublic class TestUnitController {\n	private static final Logger log = LoggerFactory.getLogger(TestUnitController.class);\n\n	@RequestMapping()\n	public String index(Model model) {\n		log.info(\"进入首页...\");\n		return \"/index\";\n	}\n}\n```', '1', '5');
INSERT INTO `blog` VALUES ('2', '3', '【文档翻译】Quartz官方文档', 'Quartz官方文档翻译', '2017-10-28 08:17:36', '0', '0', '1', '2017-10-25 12:24:38', '## 1 修改记录\n|时间|描述|\n|--|--|\n|2017-10-26|建档|\n\n## 2 前言\n　　为了方便理解和讲解，本节对全文的一些名词进行解释。\n\n　　Quartz有以下几个概念：\n\n|名词|解释|\n|--|--|\n|SchedulerFactory|调度器工厂。SchedulerFactory本身是一个接口类，其实现类用于实例化调度器。|\n|Scheduler|调度器。Scheduler本身是一个接口类，提供了众多接口来调度作业。|\n|Job|作业接口类。在源码中，Job本身是一个接口类。|\n|JobDetail|作业实例。描述作业的实例，****在本文中简称为“作业”****|\n|Schedule|调度策略。作业什么时候、间隔多久被调用。|\n|Trigger|触发器。调度器发现当前时间满足某个触发器的调度策略后，就会执行该触发器绑定的作业。|\n\n　　当触发器（Trigger）被触发时，它关联的作业（JobDetail）就会被加载，然后调度器（Scheduler）指定的作业工厂（JobFactory）会去实例化作业中的作业类（The Implemention of Job）。默认情况下作业工厂会调用`newInstance()`来实例化作业类，然后尝试调用Setter方法，将JobDataMap中Key名相同的值作为实参传递给Setter方法。\n\n## 3 概述\n　　在使用调度器之前，必须先将他实例化。实例化之后的调度器在待机模式中可以被启动、替代和关闭。\n> 注意：一旦调度器被关闭，在它被重新实例化之前是无法被启动的。可以将关闭视作销毁当前调度器实例。 -- Quartz官方文档\n\n　　调度器被启动之前，触发器不会触发，作业也不会执行。调度器被启动之后，可以向里面添加、删除、查询触发器和作业。\n```\ntry {\n	org.quartz.SchedulerFactory sf = new org.quartz.impl.StdSchedulerFactory();\n	org.quartz.Scheduler scheduler = sf.getScheduler();\n	scheduler.start();\n\n	// TODO：现在可以向调度器中添加任务和调度策略\n} catch (Exception e) {\n	log.error(e.toString(), e);\n}\n```\n### 例子\n　　以下给出了一个报时的作业示例，将用于本文档的讲解：\n```\npublic class TimeReportor implements org.quartz.Job{\n	private static final Logger log = LoggerFactory.getLogger(TimeReportor.class);\n\n	@Override\n	public void execute(org.quartz.JobExecutionContext context) throws org.quartz.JobExecutionException {\n		log.info(\"Quartz为您报时。现在是北京时间{}\", new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\").format(new Date()));\n	}\n}\n```\n　　以下是调度配置：\n```\ntry {\n    org.quartz.SchedulerFactory sf = new org.quartz.impl.StdSchedulerFactory();\n	org.quartz.Scheduler scheduler = sf.getScheduler();\n	scheduler.start();\n    \n	// TODO：现在可以向调度器中添加任务和调度策略\n	org.quartz.JobDetail job = org.quartz.JobBuilder.newJob(TimeReportor.class)\n		.withIdentity(\"jTimeReportor\", \"jReportors\")\n		.build();\n	\n	org.quartz.Trigger trigger = org.quartz.TriggerBuilder.newTrigger()\n		.withIdentity(\"tTimeReportor\", \"tReportors\")\n		.startNow()\n		.withSchedule(org.quartz.SimpleScheduleBuilder.simpleSchedule()\n			.withIntervalInSeconds(5)\n			.repeatForever())\n		.build();\n	\n	scheduler.scheduleJob(job, trigger);\n} catch (Exception e) {\n	log.error(e.toString(), e);\n}\n```\n\n## 4 作业\n　　作业（JobDetail）就是用来描述作业的，由org.quartz.JobBuilder创建。调度器通过JobDetail了解作业的一些属性，例如身份标识、作业类等，也可以利用JobDetail向作业内传递数据。\n```\norg.quartz.JobDetail jobDetail = org.quartz.JobBuilder.newJob(TimeReportor.class)\n	.withIdentity(\"jTimeReportor\", \"jReportors\")\n	.usingJobData(\"msg\", \"This is from JobDetail!\")\n	.build();\n```\n　　如上述代码所示，JobDetail被实例化时，保存了一个作业类（TimeReportor）。****当调度器每次执行这个作业的时候，都会从JobDetail对象中获取这个作业类，并创建一个新的实例，然后执行它的execute方法；执行结束后，这个实例就会被丢弃，等待回收。****这个机制产生了两个影响：\n- 当使用默认的JobFactory实现类时，作业类必须带有一个无参构造方法；\n- 作业类成员属性的状态无法保存。即在两次执行里，上一次执行对成员属性所做的修改不能被下一次执行使用。\n\n　　因此，一般将执行状态保存在作业类外面，通过JobDataMap传递。\n\n### 4.1 Job\n　　作业类实现了Job接口类。\n```\npublic class TimeReportor implements org.quartz.Job{\n	@Override\n	public void execute(org.quartz.JobExecutionContext context) throws org.quartz.JobExecutionException {\n		// TODO: 作业做什么。例如：报时\n	}\n}\n```\n　　Job接口类只有一个方法接口`execute()`。该方法就是作业的执行体，调度器调度作业的时候，就是在线程中调用了该方法的实现。该方法的实参JobExecutionContext （作业运行环境实例）包含以下信息：\n- a handle to the Scheduler that executed it\n- a handle to the Trigger that triggered the execution\n- 一个JobDetail对象\n- 一些其他内容.\n\n　　除了必须实现的`execute()`方法，作为一个类，还允许携带属性和其他方法。但是有一点需要注意：如果作业内存在Setter方法，JobFactory在实例化作业时会默认调用Setter方法，这样在`execute()`方法里就不用通过JobDataMap获取数据了。\n\n#### 实例\n　　为TimeReportor作业添加一个时区（timeLocal）的变量，并在日志中打印：\n```\npublic class TimeReportor implements org.quartz.Job{\n	private static final Logger log = LoggerFactory.getLogger(TimeReportor.class);\n	\n	private String timeLocal;\n	public void setTimeLocal(String value) {\n		this.timeLocal = value;\n	}\n	\n	@Override\n	public void execute(org.quartz.JobExecutionContext context) throws org.quartz.JobExecutionException {\n		log.info(\"Quartz为您报时。现在是{}时间{}\", timeLocal, new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\").format(new Date()));\n	}\n}\n```\n　　作业里面的Setter方法等同于JobDataMap的Key，设置值的方式和JobDataMap一样：\n```\norg.quartz.JobDetail jobDetail = org.quartz.JobBuilder.newJob(job)\n	.withIdentity(\"jTimeReportor\", \"jReportors\")\n	.usingJobData(\"timeLocal\", \"北京\")\n	.build();\n```\n\n### 4.2 JobDataMap\n　　作业支持以键值对的形式向作业类传递数据。\n```\n.usingJobData(String keyName, <Object> keyValue)\n```\n　　调度器执行作业时，会将JobDetail对象放进JobExecutionContext实例中，并在调用作业类的`execute()`方法时传递给作业类对象。\n```\n@Override\npublic void execute(org.quartz.JobExecutionContext context) throws org.quartz.JobExecutionException {\n	log.info(\"JobDetail的msg：{}\", context.getJobDetail().getJobDataMap().getString(\"msg\"));\n}\n```\n\n### 4.3 JobKey\n　　作业（JobDetail）在Quartz的调度器中被注册的时候，会被贴上身份标识（JobKey）。\n```\n.withIdentity(String name, String group)\n```\n　　身份标识可以将功能相似的作业归为一组。在同一个组内，身份标识的名称（name）必须唯一；当然，组名（group）也必须唯一。以数据库的角度来看，身份标识是由name和group复合而成的一种主键。\n　　例如，TimeReportor所在的作业被归到jRepotors组，名称是jTimeReportor，那么这个作业的唯一标识就是(jTimeReportor, jReportors)，调度器可以根据它们找到指定的作业，然后进行暂停、启动等操作。\n\n## 5 触发器\n\n### 5.1 JobDataMap\n　　触发器也支持以键值对的形式向作业类传递数据。\n```\n.usingJobData(String keyName, <Object> keyValue)\n```\n　　调度器执行作业时，会将Trigger对象放进JobExecutionContext实例中，并在调用作业类的`execute()`方法时传递给作业类对象。\n```\n@Override\npublic void execute(org.quartz.JobExecutionContext context) throws org.quartz.JobExecutionException {\n	log.info(\"Trigger的msg：{}\", context.getTrigger().getJobDataMap().getString(\"msg\"));\n}\n```\n> 思考：JobDetail和Trigger都能向作业类传递数据。如果两者的数据有重复会如何？\n　　在`execute()`方法内通过JobExecutionContext对象的`getMergedJobDataMap()`方法获取的JobDataMap实际上是JobDetail和Trigger的JobDataMap合并后的。如果存在相同的Key，Trigger会覆盖JobDetail。如果需要分别获取，可以通过`getJobDetail()`或`getTrigger()`先获取JobDetail或Trigger，然后利用`getJobDataMap()`获取对应的数据集合。\n\n### 5.2 JobKey\n　　参见4.3。\n\n## 6 调度策略(Schedule)\n### 6.1 简单策略(SimpleSchedule)\n\n### 6.2 复杂策略(CronSchedule)', '1', '4');
INSERT INTO `blog` VALUES ('3', '1', '【基础知识】JAVA关键字 - Static', 'Java基础', '2017-11-01 06:51:10', '2', '0', '1', '2017-10-27 05:34:47', '1. 加载类：初始化static属性，执行static代码块\n2. 实例化：初始化父类成员属性，执行父类构造方法；初始化子类成员属性，执行子类构造方法\n\n## 1 静态导入\n\n### 1.1 全类导入\n导入指定类的所有`公共`静态成员（包括静态属性和静态方法）。\n```\nimport static chngzhen.test.statics.TestStatic.*;\n\npublic class Primary {\n	private static final Logger log4Primary = LoggerFactory.getLogger(Primary.class);\n\n	public static void main(String[] args) {\n		log4Primary.info(\"私有静态成员属性：{}\", log4TestStatic); // 报错\n		log4Primary.info(\"公有静态成员属性：{}\", CLASS_NAME);\n		log4Primary.info(\"公有静态成员方法：{}\", sayHello());\n	}\n}\n```\n\n### 1.2 成员导入\n导入指定类的特定`公共`静态成员（包括静态属性和静态方法）。\n```\nimport static chngzhen.test.statics.TestStatic.sayHello;;\n\npublic class Primary {\n	private static final Logger log4Primary = LoggerFactory.getLogger(Primary.class);\n\n	public static void main(String[] args) {\n		log4Primary.info(\"私有静态成员属性：{}\", log4TestStatic); // 报错\n		log4Primary.info(\"公有静态成员属性：{}\", CLASS_NAME); // 报错\n		log4Primary.info(\"公有静态成员方法：{}\", sayHello());\n	}\n}\n```\n\n## 2 静态属性\n普通属性在对象被创建的时候初始化，依附于该对象，两者的关系是一对一；而静态属性在类被加载的时候创建，独立于类对象，两者是一对多的关系。\n> 注：静态属性虽然独立于对象，一般的调用方式是`类名.属性名`，但也可以通过对象调用该属性：`对象.属性名`。常见的疑惑就是能否通过this调用静态属性，this指向的是当前对象，所以是可以的。\n\n## 3 静态代码块\n静态代码块和静态属性类似，在类被初次加载的时候执行，且只执行一次。\n\n## 4 静态方法\n> 思考：构造方法是不是静态的？', '1', '10');
INSERT INTO `blog` VALUES ('4', '1', '忍途·第一章', '小说', '2017-11-06 05:18:54', '2', '0', null, '2017-10-28 06:18:52', '　　屋檐下的雨水“滴滴答答”，平缓而富有韵律。茶水的雾气缭缭而上，然后像触了顶儿似的，突兀地散去得一干二净。\n　　漩涡水间盯着看了许久，终于长舒一口气，像似把所有的郁结都吐了出来。\n　　“也罢！漩涡一族也不是非封印术不取。学不了封印术，那就学习其他忍术吧。”看了一眼正襟危坐的漩涡牧，百感交集，“只是可惜了你的资质。”\n　　“有得必有失。漩涡一族的能力独树一帜，霸道强悍。族内比我糟糕的前辈不胜枚举...”漩涡牧若有所指地说到，“总有人要付出点代价的。”', '1', '10');
INSERT INTO `blog` VALUES ('5', '3', '【官方文档】Quartz 02 - 作业（JobDetail）', '本文总结了Quartz官方文档对“作业”的介绍', '2017-10-28 09:10:26', '1', '0', null, '2017-10-28 08:31:03', '|时间|描述|\n|--|--|\n|2017-10-28|建档|\n------------\n\n　　作业（JobDetail）就是用来描述作业的，由org.quartz.JobBuilder创建。调度器通过JobDetail了解作业的一些属性，例如身份标识、作业类等，也可以利用JobDetail向作业内传递数据。\n```\norg.quartz.JobDetail jobDetail = org.quartz.JobBuilder.newJob(TimeReportor.class)\n	.withIdentity(\"jTimeReportor\", \"jReportors\")\n	.usingJobData(\"msg\", \"This is from JobDetail!\")\n	.build();\n```\n　　如上述代码所示，JobDetail被实例化时，保存了一个作业类（TimeReportor）。****当调度器每次执行这个作业的时候，都会从JobDetail对象中获取这个作业类，并创建一个新的实例，然后执行它的execute方法；执行结束后，这个实例就会被丢弃，等待回收。****这个机制产生了两个影响：\n- 当使用默认的JobFactory实现类时，作业类必须带有一个无参构造方法；\n- 作业类成员属性的状态无法保存。即在两次执行里，上一次执行对成员属性所做的修改不能被下一次执行使用。\n\n　　因此，一般将执行状态保存在作业类外面，通过JobDataMap传递。\n\n### 1 JobDataMap\n　　作业支持以键值对的形式向作业类传递数据。\n```\n.usingJobData(String keyName, <Object> keyValue)\n```\n　　调度器执行作业时，会将JobDetail对象放进JobExecutionContext实例中，并在调用作业类的`execute()`方法时传递给作业类对象。\n```\n@Override\npublic void execute(org.quartz.JobExecutionContext context) throws org.quartz.JobExecutionException {\n	log.info(\"JobDetail的msg：{}\", context.getJobDetail().getJobDataMap().getString(\"msg\"));\n}\n```\n\n### 2 Job\n　　作业类实现了Job接口类。\n```\npublic class TimeReportor implements org.quartz.Job{\n	@Override\n	public void execute(org.quartz.JobExecutionContext context) throws org.quartz.JobExecutionException {\n		// TODO: 作业做什么。例如：报时\n	}\n}\n```\n　　Job接口类只有一个方法接口`execute()`。该方法就是作业的执行体，调度器调度作业的时候，就是在线程中调用了该方法的实现。该方法的实参JobExecutionContext （作业运行环境实例）包含以下信息：\n- a handle to the Scheduler that executed it\n- a handle to the Trigger that triggered the execution\n- 一个JobDetail对象\n- 一些其他内容.\n\n　　除了必须实现的`execute()`方法，作为一个类，还允许携带属性和其他方法。但是有一点需要注意：如果作业内存在Setter方法，JobFactory在实例化作业时会默认调用Setter方法，这样在`execute()`方法里就不用通过JobDataMap获取数据了。\n\n#### 实例\n　　为TimeReportor作业添加一个时区（timeLocal）的变量，并在日志中打印：\n```\npublic class TimeReportor implements org.quartz.Job{\n	private static final Logger log = LoggerFactory.getLogger(TimeReportor.class);\n	\n	private String timeLocal;\n	public void setTimeLocal(String value) {\n		this.timeLocal = value;\n	}\n	\n	@Override\n	public void execute(org.quartz.JobExecutionContext context) throws org.quartz.JobExecutionException {\n		log.info(\"Quartz为您报时。现在是{}时间{}\", timeLocal, new SimpleDateFormat(\"yyyy-MM-dd hh:mm:ss\").format(new Date()));\n	}\n}\n```\n　　作业里面的Setter方法等同于JobDataMap的Key，设置值的方式和JobDataMap一样：\n```\norg.quartz.JobDetail jobDetail = org.quartz.JobBuilder.newJob(job)\n	.withIdentity(\"jTimeReportor\", \"jReportors\")\n	.usingJobData(\"timeLocal\", \"北京\")\n	.build();\n```\n\n### 3 JobKey\n　　作业（JobDetail）在Quartz的调度器中被注册的时候，会被贴上身份标识（JobKey）。\n```\n.withIdentity(String name, String group)\n```\n　　身份标识可以将功能相似的作业归为一组。在同一个组内，身份标识的名称（name）必须唯一；当然，组名（group）也必须唯一。以数据库的角度来看，身份标识是由name和group复合而成的一种主键。\n　　例如，TimeReportor所在的作业被归到jRepotors组，名称是jTimeReportor，那么这个作业的唯一标识就是(jTimeReportor, jReportors)，调度器可以根据它们找到指定的作业，然后进行暂停、启动等操作。', '1', '4');
INSERT INTO `blog` VALUES ('6', '3', '【官方文档】Quartz 03 - 触发器（Trigger）', '本文总结了Quartz官方文档对“触发器”的介绍。', '2017-10-28 09:10:55', '0', '0', null, '2017-10-28 08:33:58', '|时间|描述|\n|--|--|\n|2017-10-26|建档|\n------------\n\n### 1 JobDataMap\n　　触发器也支持以键值对的形式向作业类传递数据。\n```\n.usingJobData(String keyName, <Object> keyValue)\n```\n　　调度器执行作业时，会将Trigger对象放进JobExecutionContext实例中，并在调用作业类的`execute()`方法时传递给作业类对象。\n```\n@Override\npublic void execute(org.quartz.JobExecutionContext context) throws org.quartz.JobExecutionException {\n	log.info(\"Trigger的msg：{}\", context.getTrigger().getJobDataMap().getString(\"msg\"));\n}\n```\n> 思考：JobDetail和Trigger都能向作业类传递数据。如果两者的数据有重复会如何？\n　　在`execute()`方法内通过JobExecutionContext对象的`getMergedJobDataMap()`方法获取的JobDataMap实际上是JobDetail和Trigger的JobDataMap合并后的。如果存在相同的Key，Trigger会覆盖JobDetail。如果需要分别获取，可以通过`getJobDetail()`或`getTrigger()`先获取JobDetail或Trigger，然后利用`getJobDataMap()`获取对应的数据集合。\n\n### 2 JobKey\n　　参见4.3。\n', '1', '4');
INSERT INTO `blog` VALUES ('7', '1', '【基础知识】WebService从入门到精通 - Big WebService', '知识归纳 - 《WebService从入门到精通》是一个长期性维护的系列。本节通过一个简单的例子快速了解基于JAX-WS规范的Big Web Service，并以此为例详细讲解该类型的Web Service。', '2017-11-14 13:58:12', '58', '0', null, '2017-11-08 05:11:55', '[TOC]\n\n## 1 修改记录\n|时间|描述|\n|--|--|\n|2017-06-27|建档|\n|2017-11-08|重新修订|\n\n## 2 Big WebService\n　　Big WebService建立在JAX-WS规范<sup>注[3]</sup>上。\n> **注[3]：JAX-WS，全称Java API for XML-Base Web Service，即基于XML的Web Service Java API。JAX-WS创建的Web服务利用XML与客户端通讯，允许提供面向消息和面向远程过程调用的Web服务。**\n\n　　在JAX-WS规范中，Web服务利用基于XML的协议来描述操作，例如SOAP<sup>注[4]</sup>。SOAP规范定义了信封结构、编码规则以及描述Web服务调用与响应过程的约定。这些调用和响应通过HTTP协议以SOAP消息的形式传播。\n> **注[4]：SOAP，全称Simple Object Access Protocol，即简单对象访问协议。该协议基于XML。**\n\n　　SOAP消息比较复杂，但是JAX-WS做了许多简化的工作。服务端只需用Java在一个接口中定义方法即可指定Web服务操作，还可以为这些方法提供多个实现；客户端只需创建一个本地代理（Web服务的本地对象），然后通过代理的方法直接远程调用Web服务；更彻底的是，JAX-WS不要求手动生成或解析SOAP消息，将API的调用和响应转换成SOAP消息的工作都交给了JAX-WS运行系统。\n\n　　使用JAX-WS，客户端和Web服务有个很大的好处：Java的平台独立特性。另外，JAX-WS没有平台限制，客户端可以访问一个运行在非Java平台的Web服务，反之亦然。这是因为JAX-WS使用了W3C定义的现有技术：HTTP、SOAP和WSDL。这些技术应用广泛。\n> WSDL为了在消息中将Web服务描述成一组终端操作指定了一个XML格式。\n\n## 3 快速入门\n　　Web服务是一个C-S应用，所以存在服务端和客户端的概念。服务端只有一个服务实现类：\n```\npackage chngzhen.exp.wsr.impl;\n\n@WebService\npublic class GreetWebserviceImpl implements GreetWebservice {\n	private static final Logger log = LoggerFactory.getLogger(GreetWebserviceImpl.class);\n\n	@WebMethod\n	public Integer sayHello(String name) {\n		log.info(\"Hello, {}\", name);\n		return 1;\n	}\n}\n```\n　　服务端将实现类发布在指定的地址：\n```\npublic class Publisher {\n	private static final Logger log = LoggerFactory.getLogger(Primary.class);\n\n	public static void main(String[] args) {\n		Endpoint.publish(\"http://127.0.0.1:8020/wsr/GreetService\", new GreetWebserviceImpl());\n	}\n}\n```\n　　客户端需要根据上面的发布地址获取WSDL文档：http://127.0.0.1:8020/wsr/GreetServic?wsdl ，然后根据WSDL文档编写接口类（或者要求提供方直接提供，或者利用工具生成）：\n```\npackage chngzhen.exp.wsr;\n\n@WebService(targetNamespace=\"http://impl.wsr.test.chngzhen/\")\npublic interface GreetWebservice {\n	\n	public Integer sayHello(String name);\n}\n```\n　　然后利用客户端获取Web服务的本地代理，通过代理调用Web服务的具体服务：\n```\n\npackage chngzhen.exp.wsr;\n\npublic class GreetWebserviceClient extends Service {\n	// 目标命名空间。默认为\"http://\"+倒置实现类的包路径\n	private final static String targetNamespace = \"http://impl.wsr.test.chngzhen/\";\n	// QNAME的第二个参数是实现类@WebService注解中的serviceName。默认为实现类名称+“Service”\n    private final static QName MGRWEBSERVICE_QNAME =\n		new QName(targetNamespace, \"GreetWebserviceImplService\");\n\n    public GreetWebserviceClient(String url) throws MalformedURLException {\n        super(__getWsdlLocation(url), MGRWEBSERVICE_QNAME);\n    }\n\n    @WebEndpoint(name = \"GreetWebserviceImplPort\")\n    public GreetWebservice getGreetWebserviceImplPort() {\n        return super.getPort(new QName(targetNamespace, \"GreetWebserviceImplPort\"), GreetWebservice.class);\n    }\n\n	private static URL __getWsdlLocation(String url) throws MalformedURLException {\n	    return new URL(url+\"?wsdl\");\n    }\n	\n	public static void main(String[] args) {\n		try {\n			GreetWebserviceClient client =\n				new GreetWebserviceClient(\"http://127.0.0.1:10020/wsr/GreetWebService\");\n			client.getGreetWebserviceImplPort().sayHello(\"Chngzhen\");\n		} catch (MalformedURLException e) {\n			e.printStackTrace();\n		}\n	}\n\n}\n```\n\n## 4 详细说明\n### 4.1 服务端\n开发基于JAX-WS规范的Web服务，得先从服务端程序开始。***服务端程序是一个带有`@javax.jws.WebService`注解的`public`、`非final`和`非abstract`类***，以方法的形式提供了具体服务的实现。\n\n服务端程序有两个概念：Service Endpoint Interface（服务终端接口）和Service Endpoint Implementation（服务终端实现），均简称SEI。\n- 服务终端接口：Java接口类（如GreetWebservice）\n- 服务终端实现：Java实现类（如GreetWebserviceImpl）\n\n他们声明了可供客户端调用的具体服务。在实际开发中，服务端可以不必提供接口类，JAX-WS会根据实现类隐式定义一个接口类。例如GreetWebserviceImpl也可以如下：\n```\n@WebService\npublic class GreetWebserviceImpl {\n	// TODO: 定义操作（方法）\n}\n```\n下面以实现类和方法两个层面来讲解服务端。\n\n#### 4.1.1 服务终端实现类\n如上所述，SEI除了是一个Java类，还要求满足以下条件：\n\n1. 实现类必须是`public`、`非final`和`非abstract`的Java类；\n2. 实现类必须被javax.jws.WebService注解；\n\n除了以上几条外，JavaEE的官方教程还对实现类进行了其他规范。但实际上，这些规范并没有被严格执行：\n1. 实现类不能定义finalize方法；\n2. 实现类必须有一个默认的`public`构造方法；\n\n> 尝试：JAX-WS对以上两个规范是否具有强制性？\n\n##### 4.1.1.1 WebService注解\nSEI在类层面上最最重要的注解就是`javax.jws.WebService`，用来指定一个Java类作为Web服务的实现，或者指定一个Java接口作为Web服务的接口。\n\n以下是该注解的参数：\n- `name`：Web服务的名称。\n　　非重要参数。\n- `portName`：Web服务的端口名称。\n　　非重要参数。\n- `serviceName`：Web服务的服务名称。默认值：实现类的类名+“Service”。\n　　重要参数。对应WSDL文档中`<service/>`节点的`name`属性，是客户端获取服务时必要的内容。\n- `wsdlLocation`：Web服务预先定义好的WSDL地址。\n　　非重要参数。\n- `targetNamespace`：命名空间。默认值：“http://” + 包路径倒置\n　　重要参数。如果服务终端接口的@WebService注解中已经配置了该属性，那么本参数将用于`wsdl:portType`的命名空间。\n　　**重点：当服务终端接口（chngzhen.test.wsr.GreetWebservice）和服务终端实现（chngzhen.test.wsr.impl.GreetWebserviceImpl）不在同一个路径下时，服务终端接口必须在`@WebService`注解上指明该参数，否则客户端利用代理调用服务时会找不到分派的方法。**\n```\n@WebService(targetNamespace=\"http://impl.wsr.test.chngzhen/\")\npublic interface GreetWebservice {\n\n	public Integer sayHello(String name);\n}\n```\n- `endpointInterface`：服务终端接口的完全名称。\n　　非重要参数。\n\n#### 4.1.2 服务终端实现方法\n如上所述，SEI里面的方法提供了具体服务的实现，但必须满足以下条件：\n1. 实现类的业务（暴露给外部的）方法必须是`public`且`非final`和`非static`；\n2. 实现类的业务方法必须被`javax.jws.WebMethod`注解；\n3. 实现类的业务方法的参数和返回值的类型必须符合JAXB规范；\n4. 实现类可以为生命周期回调方法添加javax.annotation.PostConstruct或javax.annotation.PreDestroy注解。\n\n方法层面上，JAX-WS提供了三个重要注解：\n\n|注解|范围|描述|\n|--|--|--|\n|javax.jws.WebMethod|方法|自定义作为Web服务操作暴露给外部的方法。|\n|javax.jws.WebParam|参数|自定义Web服务消息部分的参数与XML元素之间的映射关系。|\n|javax.jws.WebResult|方法|自定义WSDL部分的返回值与XML元素之间的映射关系。|\n##### 4.1.2.1 WebMethod注解\n\n##### 4.1.2.2 WebParam注解\n\n##### 4.1.2.1 WebResult注解\n\n### 4.2 客户端\n　　因为服务终端实现不可能会提供给客户端，所以客户端需要首先需要在本地建立一个服务代理，然后通过代理远程调用Web服务。\n\n　　服务是实现类提供的，代理可以简单地看做是实现类的一个对象。而实现类不可能会提供给外部，所以需要用到接口类。接口类有两种获得方式：其一是服务提供方提供，其二就是根据服务提供方给出的WSDL文档手动创建或自动生成。\n\n　　自动生成可以借助JDK提供的wsimport工具。生成的文件中一定会包含一个接口类和一个实例化代理的工具类（服务客户端）。该工具类简化之后如下：\n```\npublic class GreetWebserviceClient extends Service {\n	// 目标命名空间。默认为\"http://\"+倒置实现类的包路径\n	private final static String targetNamespace = \"http://impl.wsr.test.chngzhen/\";\n	// QNAME的第二个参数是实现类@WebService注解中的serviceName。默认为实现类名称+“Service”\n    private final static QName MGRWEBSERVICE_QNAME =\n		new QName(targetNamespace, \"GreetWebserviceImplService\");\n\n    public GreetWebserviceClient(String url) throws MalformedURLException {\n        super(__getWsdlLocation(url), MGRWEBSERVICE_QNAME);\n    }\n\n    @WebEndpoint(name = \"GreetWebserviceImplPort\")\n    public GreetWebservice getGreetWebserviceImplPort() {\n        return super.getPort(new QName(targetNamespace, \"GreetWebserviceImplPort\"), GreetWebservice.class);\n    }\n\n	private static URL __getWsdlLocation(String url) throws MalformedURLException {\n	    return new URL(url+\"?wsdl\");\n    }\n	\n	public static void main(String[] args) {\n		try {\n			GreetWebserviceClient client =\n				new GreetWebserviceClient(\"http://127.0.0.1:10020/wsr/GreetWebService\");\n			client.getGreetWebserviceImplPort().sayHello(\"Chngzhen\");\n		} catch (MalformedURLException e) {\n			e.printStackTrace();\n		}\n	}\n\n}\n```\n\n### 4.3 交互\n　　JAX-WS支持1.1版本的WS-I基本描述（全称Web Services Interoperability），在运行时允许对服务、静态端口、动态代理以及动态调用接口（Dynamic Invocation Interface，简称DII）进行Doc/Literal或Rpc/Literal编码。WS-I为了促进SOAP的交互，理清了1.1版本的SOAP和1.1版本的WSDL规范。\n', '1', '10');
INSERT INTO `blog` VALUES ('8', '1', '【基础知识】WebService从入门到精通 - 概述', '知识归纳 - 《WebService从入门到精通》是一个长期性维护的系列。本节通过JavaEE文档中的说明，介绍WebService的基本概念。', '2017-11-14 13:11:41', '49', '0', null, '2017-11-09 07:50:28', '[TOC]\n\n## 1 修改记录\n|时间|描述|\n|--|--|\n|2017-06-27|建档|\n|2017-11-08|重新修订|\n|2017-11-13|添加“快速入门”|\n\n## 2 概述\n　　Web服务是一种借助万维网超文本传输协议（HTTP）进行通讯的C-S应用。如同W3C所描述的，Web服务为运行在不同平台和框架上的应用提供了一个标准的交互手段。Web服务的特点就是它强大的交互能力和可扩展性，以及借助XML让描述可被机器处理。Web服务可以结合松耦合的方式实现复杂的操作<sup>注[1]</sup>。程序可以通过提供简单的服务与其他程序进行交互，从而实现复杂的具有附加价值的服务。\n> **注[1]：在Web服务中经常会提到“operate”一词，这里统一将其翻译为“操作”，简单地理解为Web服务实现类中方法的调用和响应。**\n\n　　在概念上，一个服务就是网络服务器提供的一个软件组件。使用者和提供者利用调用请求和响应的自包含文档，以消息的形式交换信息，不用考虑接收者的技术能力；在技术上，Web服务有多种实现方式，常见就是“Big WebService”和“RESTful WebService”<sup>注[2]</sup>。\n> **注[2]：关于如何选择合适的Web Service类型：\n　　基本上，在Web上集成时选用RESTful WebService，而在企业应用程序集成场景中Big WebService在提供高级服务质量需求上更有优势：\n　　- JAX-WS：能够解决企业运算对高级服务质量的需求。和JAX-RS相比，JAX-WS能轻松支持WS-*系列的协议，提供安全性和可靠性的标准等等，并与其他遵循C-S模式的WS-*交互。\n　　- JAX-RS：适合需要应用RESTful风格约束来获取合适属性的Web应用。例如松耦合属性（不用破坏已有的客户端即可扩展服务）、可扩展性以及体系结构简单（使用现成的组件，如代理或HTTP路由）。选择JAX-RS的理由之一是，对于不同类型的客户端，它们都能不受服务端扩展的影响直接使用RESTful风格的WebService，客户端可以选择独立调用部分或者所有的服务。**', '1', '10');
INSERT INTO `blog` VALUES ('9', '1', '【基础知识】WebService从入门到精通 - RESTful WebService', 'P03', '2017-11-09 07:56:11', '2', '0', null, '2017-11-09 07:56:11', 'RESTful Web服务是一种松耦合、轻量级的Web服务，适合为分布在互联网上的客户端创建各种API。REST（全称Representational State Transfer）是一种围绕如何利用请求和响应转移资源表现的C-S应用程序架构风格。在REST架构风格中，数据和函数都被认为是一种资源，并利用URI（全称Uniform Resource Identifier）访问。资源以文档的形式表现，并利用一种简单、定义良好的操作调用。\n\n例如，一个REST资源可能是某个城市当前的天气情况。他的表现则可能是一个XML文档、图片或者一个HTML页面。客户端获取指定的资源，然后进行修改。\n\nREST架构风格被设计倾向使用无状态通讯协议，例如HTTP。在REST架构风格中，客户端和服务端利用标准的接口和协议交换资源表现。', '1', '10');
INSERT INTO `blog` VALUES ('10', '1', '【基础知识】Git入门 - 常见操作指令', 'Git常见的操作指令', '2017-11-14 14:06:15', '91', '0', null, '2017-11-09 13:24:43', '[TOC]\n\n## 1 修改记录\n|时间|描述|\n|--|--|\n|2017-11-09|建档|\n|2017-11-14|新增“删除远程分支”|\n\n## 2 常见操作指令\n##### **创建文件夹**\n格式：`mkdir [localRepo-name]`\n例如：在D盘根目录下创建generator文件夹\n```\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d\n$ mkdir generator\n\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d\n$ \n```\n\n##### **进入文件夹**\n格式：`cd [localRepo-name]`\n例如：进入创建好的generator文件夹\n```\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d\n$ cd generator\n\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d/generator\n$ \n```\n\n##### **初始化仓库**\n格式：`git init`\n例如：初始化generator文件夹作为一个仓库\n```\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d/generator\n$ git init\nInitialized empty Git repository in D:/generator/.git/\n\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d/generator (master)\n$ \n```\n\n##### **建立远程分支**\n格式：`git remote add [remote_name] [repo_address]`\n例如：给generator添加一个名为origin的远程分支\n```\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d/generator (master)\n$ git remote add origin https://github.com/Chngzhen/generator.git\n\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d/generator (master)\n$ \n```\n\n##### **删除远程分支**\n格式：`git remote rm [remote_name]`\n例如：删除generator名为origin的远程分支\n```\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d/generator (master)\n$ git remote rm origin\n\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d/generator (master)\n$ \n```\n\n##### **拉取内容**\n格式：`git pull [remote_name] [branch_name]`\n例如：向本地库generator拉取Git库的master分支内容\n```\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d/generator (master)\n$ git pull origin master\nremote: Counting objects: 119, done.\nK 0 (delta 0), pack-rReceiving objectes:  used 11934% (41/119)119)\nReceiving objects: 100% (119/119), 21.00 KiB | 0 bytes/s, done.\nResolving deltas: 100% (20/20), done.\nFrom https://github.com/Chngzhen/generator\n * branch            master     -> FETCH_HEAD\n * [new branch]      master     -> origin/master\n\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d/generator (master)\n$ \n```\n\n##### **查看文件状态**\n格式：`git status`\n例如：修改README.md文件的内容，然后查看该文件的状态\n```\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d/generator (master)\n$ git status\nOn branch master\nChanges not staged for commit:\n  (use \"git add <file>...\" to update what will be committed)\n  (use \"git checkout -- <file>...\" to discard changes in working directory)\n\n        modified:   README.md\n\nno changes added to commit (use \"git add\" and/or \"git commit -a\")\n\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d/generator (master)\n$ \n```\n\n##### **添加到提交队列**\n格式：`git add [file_path]`\n例如：将README.md添加到提交队列\n```\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d/generator (master)\n$ git add README.md\n\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d/generator (master)\n$ \n```\n\n##### **提交内容**\n格式：`git commit -m [description]`\n例如：提交当前队列中的修改内容\n```\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d/generator (master)\n$ git commit -m \"修改README.md\"\n[master 076e555] 修改README.md\n 1 file changed, 1 insertion(+), 1 deletion(-)\n\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d/generator (master)\n$ \n```\n\n##### **推送内容**\n格式：`git push [remote_name] [branch_name]`\n例如：将generator中提交的内容推送到Git库的master分支上\n> 需要提供Git库的账号和密码\n\n```\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d/generator (master)\n$ git push origin master\nCounting objects: 3, done.\nDelta compression using up to 4 threads.\nCompressing objects: 100% (2/2), done.\nWriting objects: 100% (3/3), 354 bytes | 0 bytes/s, done.\nTotal 3 (delta 0), reused 0 (delta 0)\nTo https://github.com/Chngzhen/generator.git\n   3a8dd8b..076e555  master -> master\n\nMithiuC@LAPTOP-KCR6DH7L MINGW32 /d/generator (master)\n$ \n```', '1', '12');
INSERT INTO `blog` VALUES ('11', '1', '【S-Spring】验证码生成', '解决方案－基于Java与Spring MVC的前端验证码生成解决方案。', '2017-11-09 13:33:57', '2', '0', null, '2017-11-09 13:33:57', '## 1 修改记录\n|时间|描述|\n|--|--|\n|2017-08-29|建档|\n## 2 正文内容\n　　声明：本文章使用了 http://www.cnblogs.com/AdamFamily/p/6379676.html 的代码和思路。\n\n　　简单验证码生成方法。属性和生成方式封装在VerificationCode类。\n### 2.1 基本属性\n　　基本属性包括以下部分：\n\n|名称|类型|默认值|描述|\n|--|--|--|--|\n|width|Integer|90|验证码图片宽度|\n|height|Integer|20|验证码图片高度|\n|fontHeight|Integer|18|验证码字体大小|\n|codeNum|Integer|4|验证码数量|\n|codeSequence|char[]|A-Za-z0-9|验证码可选列表，不包括大写的i和小写的L。该属性不提供Setter方法|\n```\nprivate Integer width = 90;// 验证码图片宽度\n	\nprivate Integer height = 20;// 验证码图片高度\n\nprivate Integer fontHeight = 18;// 验证码字体高度：默认为18\n\nprivate Integer codeNum = 4;// 验证码数量：默认为4\n\nprivate char[] codeSequence = {\n		\'A\', \'B\', \'C\', \'D\', \'E\', \'F\', \'G\',\n		\'H\', \'J\', \'K\', \'L\', \'M\', \'N\', \'O\',\n		\'P\', \'Q\', \'R\', \'S\', \'T\', \'U\', \'V\', \'W\', \'X\', \'Y\', \'Z\',\n		\'a\', \'b\', \'c\', \'d\', \'e\', \'f\', \'g\',\n		\'h\', \'i\', \'j\', \'k\', \'m\', \'n\', \'o\',\n		\'p\', \'q\', \'r\', \'s\', \'t\', \'u\', \'v\', \'w\', \'x\', \'y\', \'z\',\n		\'0\', \'1\', \'2\', \'3\', \'4\', \'5\', \'6\', \'7\', \'8\', \'9\' };\n		\npublic Integer getWidth() {\n	return width;\n}\n\npublic void setWidth(Integer width) {\n	this.width = width;\n}\n\npublic Integer getHeight() {\n	return height;\n}\n\npublic void setHeight(Integer height) {\n	this.height = height;\n}\n\npublic Integer getFontHeight() {\n	return fontHeight;\n}\n\npublic void setFontHeight(Integer fontHeight) {\n	this.fontHeight = fontHeight;\n}\n\npublic Integer getCodeNum() {\n	return codeNum;\n}\n\npublic void setCodeNum(Integer codeNum) {\n	this.codeNum = codeNum;\n}\n\npublic char[] getCodeSequence() {\n	return codeSequence;\n}\n```\n### 2.2 保存结果\n　　需要保存的结果有两个：\n\n|名称|类型|默认值|描述|\n|--|--|--|--|\n|bufferedImage|BufferedImage|null|验证码图片缓冲。该属性不提供Setter方法|\n|codeString|String|null|验证码字符串。该属性不提供Setter方法|\n```\nprivate String codeString;// 验证码\n\nprivate BufferedImage bufferedImage;// 验证码图片\n\npublic String getCodeString() {\n	return codeString;\n}\n\npublic BufferedImage getBufferedImage() {\n	return bufferedImage;\n}\n```\n### 2.3 生成验证码\n```\npublic void generate() {\n    // 定义图像buffer\n    bufferedImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);\n    \n    Graphics gd = bufferedImage.getGraphics();// 获取图像的画笔\n    gd.setColor(Color.WHITE);// 设置画笔颜色：白色\n    gd.fillRect(0, 0, width, height);// 画一个矩形面\n    gd.setColor(Color.BLACK);// 设置画笔颜色：黑色\n    gd.drawRect(0, 0, width - 1, height - 1);// 画一个矩形框\n    \n    Random random = new Random();\n    // 随机产生40条干扰线，使图象中的认证码不易被其它程序探测到。\n    gd.setColor(Color.BLACK);\n    for (int i = 0; i < 40; i++) {\n        int start_x = random.nextInt(width);\n        int start_y = random.nextInt(height);\n        int offset_x = random.nextInt(12);\n        int offset_y = random.nextInt(12);\n        gd.drawLine(start_x, start_y, start_x + offset_x, start_y + offset_y);\n    }\n    \n    // codes用于保存随机产生的验证码，以便用户登录后进行验证。\n    gd.setFont(new Font(\"Fixedsys\", Font.BOLD, fontHeight));// 设置画笔字体属性\n    for (int i = 0; i < codeNum; i++) {\n        String code = String.valueOf(codeSequence[random.nextInt(codeSequence.length-1)]);\n        gd.setColor(new Color(random.nextInt(255), random.nextInt(255), random.nextInt(255)));\n        gd.drawString(code, (i + 1) * 15, 16);\n        this.codeString+=code;\n    }\n    log.info(\"验证码：{}\", this.codeString);\n}\n```\n### 2.4 使用方法\n　　本文章建立在Spring框架上：\n```\n@RequestMapping(\"/verification\")\npublic void getCode(VerificationCode verificationCode, HttpServletRequest req, HttpServletResponse resp) {\n    // 将四位数字的验证码保存到Session中。\n    HttpSession session = req.getSession();\n    System.out.print(verificationCode);\n    session.setAttribute(\"code\", verificationCode.getCodeString());\n    \n    // 禁止图像缓存。\n    resp.setHeader(\"Pragma\", \"no-cache\");\n    resp.setHeader(\"Cache-Control\", \"no-cache\");\n    resp.setDateHeader(\"Expires\", 0);\n    resp.setContentType(\"image/jpeg\");\n    \n    // 将图像输出到Servlet输出流中。\n	try {\n		ServletOutputStream sos = resp.getOutputStream();\n        ImageIO.write(verificationCode.getBufferedImage(), \"jpeg\", sos);\n        sos.close();\n	} catch (IOException e) {\n		log.error(e.toString(), e);\n	}\n}\n```\n## 3 代码地址\n', '1', '5');
INSERT INTO `blog` VALUES ('12', '1', '【官方教程】WebSocket相关API', 'JavaEE官方教程-WebSocket', '2017-11-27 02:36:49', '7', '0', null, '2017-11-23 02:21:33', '[TOC]\n\n## 修改记录\n|时间|描述|\n|--|--|\n|2017-11-21|建档|\n|2017-11-23|完善“注解服务终端”|\n\n## 概述\nWebSocket是一个建立在TCP协议上的***全双工通信***应用协议。\n\n在传统的HTTP请求-响应模型中，客户端请求资源，服务端提供响应。这个交换过程总是由客户端发起，服务端在客户端没有发起请求之前是不能发送任何数据的。\n\n\n```seq\nClient->Server: Request (Resource A)\nServer-->Client: Response (Resource A)\nServer-->Server: Change (Resource A to A\')\nServer-->Server: Change (Resource A\' to A\'\')\nClient->Server: Request (Resource A)\nServer-->Client: Response (Resource A\'\')\n```\n如上图所示，在万维网上，如果客户端只是偶尔请求一些极少变动的文档，这个模型能完全能胜任；但是当内容快速变动而用户需要更及时的知悉这些变动时，这个模型就存在很大的限制。\n\nWebSocket通过为客户端和服务端提供一个全双工通信管道解决了这个问题，结合现有的客户端技术（如javaScript和HTML5），Web应用能提供更好的用户体验。\n> 全双工通信：即客户端能主动向服务端发送消息，而服务端也能够主动向客户端推送消息，无需客户端事先请求。\n\n## 1 WebSocket介绍\n服务端发布一个WebSocket终端，客户端通过该终端映射的URI连接到服务端。\n\n连接建立后，客户端和服务端可以互相主动发送消息，也可以主动关闭连接。\n\n### 1.1 握手\nWebSocket协议有两个部分：握手和数据传输。客户端在于服务端建立连接时，通过请求发起握手。握手兼容HTTP基本结构，因为服务器会将其解释为一个HTTP连接升级请求。下面给出了一个客户端发起的握手请求：\n```\nGET /path/to/websocket/endpoint HTTP/1.1\nHost: localhost\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: xqBt3ImNzJbYqRINxEFlkg==\nOrigin: http://localhost\nSec-WebSocket-Version: 13\n```\n下面是服务器的响应：\n```\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: K7DJLdLooIwIG/MOpvWFB3y3FE8=\n```\n客户端传递一个`Sec-WebSocket-Key`给服务器，服务器根据它将操作解释成`Sec-WebSocket-Accept`的值并返回给客户端，客户端根据操作和`Sec-WebSocket-Key`计算的结果与`Sec-WebSocket-Accept`相同，则连接建立成功。\n### 1.2 URI\nWebSocket终端的URI有两种格式：\n```\nws://host:port/path?query\nwss://host:port/path?query\n```\n- `ws`表示一个未加密的WebSocket连接，`wss`则表示一个加密的连接；\n- `port`可选，未加密连接默认80端口，加密连接默认443端口；\n- `path`表示终端在服务端的位置；\n- `query`可选。\n\n## 2 使用WebSocket\nWebSocket的JAVA API位于以下两个包：\n- javax.websocket.server：包括创建和配置服务终端所需的注解、类与接口；\n- javax.websocket：包括客户端和终端共用的注解、类、接口与异常。\n\nWebSocket是javax.websocket.Endpoint类的实例。有两种方式：其一是继承Endpoint类并重写生命周期方法；其二是通过注解。\n> 大多数情况下，利用注解是更好的选择。\n\n### 2.1 编程化服务终端\n\n### 2.2 注解服务终端\n\n|注解|事件|参数|\n|--|--|--|\n|OnOpen|连接可用|Session, EndpointConfig|\n|OnMessage|服务端接收到消息|Session, String|\n|OnError|连接发生异常|Session, Throwable|\n|OnClose|关闭连接之后|Session, CloseReason|\n\n#### 2.2.2 处理消息\n客户端与服务终端建立连接后，可以向服务终端主动发送消息，服务终端在OnMessage事件中接收并处理该消息：\n```\n/**接收文本消息\n * @param session WebSocket会话对象\n * @param msg 文本消息。由客户端传递\n */\n@OnMessage\npublic void onMessage(Session session, String msg) {\n    // TODO: 处理消息\n}\n\n/**接收二进制消息\n * @param session WebSocket会话对象\n * @param msg 二进制消息。由客户端传递\n */\n @OnMessage\npublic void onMessage(Session session, ByteBuffer msg) {\n    // TODO: 处理消息\n}\n\n/**接收Pong消息\n * @param session WebSocket会话对象\n * @param msg Pong消息。由客户端传递\n */\n@OnMessage\npublic void onMessage(Session session, PongMessage msg) {\n    // TODO: 处理消息\n}\n```\n作为全双工通信协议，WebSocket允许管道建立之后，服务终端主动向客户端推送消息。\n\n已知客户端与服务终端建立连接的时候，会实例化一个专有的WebSocket实现类对象，并在WebSocket的生命周期中提供一个唯一的WebSocket会话对象。该Session提供两个RemoteEndpoint对象——RemoteEndpoint.Basic和RemoteEndpoint.Async：\n- RemoteEndpoint.Basic提供了阻塞的方法来发送消息；\n- RemoteEndpoint.Async提供了非阻塞的方法来发送消息。\n\n除了可以接收的三大类型消息，RemoteEndpoint对象还可以发送Ping帧：\n```\nSession.getBasicRemote.sendText(String text)\n//Session.getAsyncRemote.sendText(String text)\n\nSession.getBasicRemote.sendBinary(ByteBuffer data)\n//Session.getAsyncRemote.sendBinary(ByteBuffer data)\n\nSession.getBasicRemote.sendPing(ByteBuffer appData)\n//Session.getAsyncRemote.sendPing(ByteBuffer appData)\n\nSession.getBasicRemote.sendPong(ByteBuffer appData)\n//Session.getAsyncRemote.sendPong(ByteBuffer appData)\n```\n\n#### 2.2.3 处理错误\n@OnError注解的方法用于处理连接异常、处理消息时产生的运行错误以及解码消息时产生的转换错误。\n```\n@OnError\npublic void onError(Session session, Throwable error) {\n    // TODO: 处理错误\n    log.error(error.toString(), error);\n}\n```\n\n#### 2.2.4 维护客户端状态\n因为容器为每个连接都实例化了一个WebSocket实现类对象，所以可以在实现类中定义变量来保存客户端状态，或者利用Session的UserProperties以键值对的形式保存。\n```\n@ServerEndpoint(\"/wsc/count/readtimes\")\npublic class ReadTimesCountWebsocket {\n    // 用于保存所有有效的连接\n    public static List<Session> sessions = new ArrayList<>();\n\n    @OnOpen\n    public void open(Session session, EndpointConfig cfg) {\n        session.getUserProperties().put(\"previousMsg\", \" \");\n        sessions.add(session);\n    }\n    \n    @OnMessage\n    public void message(Session session, String msg) {\n        String prev = (String) session.getUserProperties()\n                            .get(\"previousMsg\");\n        session.getUserProperties().put(\"previousMsg\", msg);\n        try {\n            session.getBasicRemote().sendText(prev);\n        } catch (IOException e) { ... }\n    }\n}\n```\n> 注意：使用static变量保存所有Session的共享数据时，必须确保线程安全。\n\n#### 2.2.5 指定终端配置类\nWebSocket的JAVA API允许自定义终端配置逻辑，来指导容器如何实例化服务终端对象：\n- 访问握手请求中的详细信息\n- 在Origin Http头信息中执行自定义检查\n- 修改握手响应\n- 从客户端的请求中选择一个WebSocket子协议\n- 控制终端的实例化的初始化\n\n自定义配置逻辑需要继承ServerEndpointConfig.Configurator类，然后根据配置需求重写指定的方法。例如，将握手请求对象传递给服务终端对象：\n```\npublic class CustomConfigurator extends ServerEndpointConfig.Configurator {\n\n    @Override\n    public void modifyHandshake(ServerEndpointConfig conf, HandshakeRequest req, HandshakeResponse resp) {\n        // 将请求对象保存在UserProperties中\n        conf.getUserProperties().put(\"handshakereq\", req);\n    }\n}\n```\n给服务终端实现类指定自定义的配置逻辑，然后通过EndpointConfig获取UserProperties，根据Key名获取握手请求对象：\n```\n@ServerEndpoint(\n    value = \"/wsc/count/readtimes\",\n    configurator = CustomConfigurator.class)\npublic class ReadTimesCountWebsocket {\n\n    @OnOpen\n    public void open(Session session, EndpointConfig cfg) {\n        HandshakeRequest req = (HandshakeRequest) conf.getUserProperties()\n                                                      .get(\"handshakereq\");\n        Map<String,List<String>> headers = req.getHeaders();\n    }\n}\n```\n\n## 3 传参\nWebSocket允许像HTTP那样在URI中携带参数。但需要预先定义：\n```\n@ServerEndpoint(\"/wsc/count/readtimes/{param0}/{param1}\")\npublic class ReadTimesCountWebsocket {\n    \n}\n```\n参数可以在`OnOpen`、`OnMessage`和`OnClose`事件中利用`@PathParam`获取，和Spring MVC的`@RequestParam`有些相似：\n```\n@OnOpen\npublic void onOpen(@PathParam(\"param0\")String param0, @PathParam(\"param1\")String param1, Session session, EndpointConfig cfg) {\n    // TODO: 处理连接可用事件\n    log.info(\"Websocket-{}连接成功\", session.getId());\n    log.info(\"param0={}, param1={}\", param0, param1);\n}\n```\n> 因为URI用于客户端与服务端的连接，所以声明所需携带的参数必须完全具备。一旦缺少参数，则URI会指向不同的WebSocket终端。例如`/wsc/count/readtimes/0/1`和`/wsc/count/readtimes/0`指向的是不同的终端。', '1', '10');
INSERT INTO `blog` VALUES ('13', '1', '【基础知识】jQuery接口 - JS获取项目相关信息', '', '2017-11-27 02:49:27', '2', '0', null, '2017-11-27 02:49:27', '##### 获取当前页面请求路径\n格式：`windoew.location.href`\n```\nconsole.log(\"windoew.location.href=\"+window.location.href);\n// 输出 http://127.0.0.1:8080/projectName/pageURI?Param0=Value0\n```\n\n##### 获取项目协议类型\n格式：`windoew.location.protocol`\n```\nconsole.log(\"windoew.location.protocol=\"+window.location.protocol);\n// 输出 http:\n```\n\n##### 获取项目主机地址\n格式：`windoew.location.host`\n```\nconsole.log(\"windoew.location.host=\"+window.location.host);\n// 输出 127.0.0.1:8080\n```\n\n##### 获取项目主机IP\n格式：`windoew.location.hostname`\n```\nconsole.log(\"windoew.location.hostname=\"+window.location.hostname);\n// 输出 127.0.0.1\n```\n\n##### 获取项目端口\n格式：`windoew.location.port`\n```\nconsole.log(\"windoew.location.port=\"+window.location.port);\n// 输出 8080\n```\n\n##### 获取页面URI\n格式：`windoew.location.pathname`\n```\nconsole.log(\"windoew.location.pathname=\"+window.location.pathname);\n// 输出 /ProjectName/PageURI\n```\n\n##### 获取页面请求参数\n格式：`windoew.location.search`\n```\nconsole.log(\"windoew.location.search=\"+window.location.search);\n// 输出 Param1=Value1\n```\n\n##### \n```\nconsole.log(\"windoew.location.hash=\"+window.location.hash);\n```', '1', '10');
INSERT INTO `blog` VALUES ('14', '1', '【产品介绍】IWebSocket - jQuery简单封装WebSocket', '', '2017-11-27 02:49:56', '0', '0', null, '2017-11-27 02:49:56', '|时间|描述|\n|--|--|\n|2017-07-26|建档|\n|2017-11-27|简化初始化配置|\n\n## 代码\n```\n/**WebSocket插件\n *\n * @CreateBy：chngzhen@outlook.com\n * @CreateOn：2017-07-06\n * @UpdateBy：chngzhen@outlook.com\n * @UpdateOn：2017-11-27\n *\n * @param json\n * @returns {{init: init}}\n * @constructor\n */\nvar IWebSocket = function(json) {\n    let options = {\n        uri:\"#\", // Socket绑定的URI\n        sockJsUri:\"#\",\n        projectName: window.location.pathname.split(\"/\")[1], // 项目名称。默认以“/”为分隔符切割URI后取第2个字符串\n        host: window.location.host, // 项目IP和端口。默认取当前项目的主机IP和Port\n        onOpen:function(event) {\n            // 自定义WSC连接事件：服务端与前端连接成功后触发\n            console.log(event)\n        },\n        onMessage:function(event) {\n            // 自定义WSC消息接收事件：服务端向前端发送消息时触发\n            console.log(event)\n        },\n        onError:function(event) {\n            // 自定义WSC异常事件：WSC报错后触发\n            console.log(event)\n        },\n        onClose:function(event) {\n            // 自定义WSC关闭事件：WSC关闭后触发\n            console.log(event)\n        }\n    };\n    $.extend(true, options, json);\n\n    let websocket;\n    if (\'WebSocket\' in window) {\n        websocket = new WebSocket(\"ws://\" + options.host + \"/\" +options.projectName + \"/\" + options.uri);\n    } else if (\'MozWebSocket\' in window) {\n        websocket = new MozWebSocket(\"ws://\" + options.host + \"/\" +options.projectName + \"/\" + options.uri);\n    } else {\n        websocket = new SockJS(\"http://\" + options.host + \"/\" +options.projectName + \"/\" + options.sockJsUri);\n    }\n\n    websocket.onopen = function(evnt) {\n\n        options.onOpen(evnt);\n    };\n    websocket.onmessage = function(evnt) {\n\n        options.onMessage(evnt);\n    };\n    websocket.onerror = function(evnt) {\n\n        options.onError(evnt);\n    };\n    websocket.onclose = function(evnt) {\n\n        options.onClose(evnt);\n    };\n\n    return websocket;\n}\n```', '1', '10');
INSERT INTO `blog` VALUES ('15', '1', '【基础知识】MyBatis映射文件 - cache元素', 'MyBatis从入门到精通', '2017-12-27 14:02:30', '4', '0', null, '2017-12-27 13:55:25', '# 1 目录\n[TOC]\n\n# 2 概述\n默认情况下仅开启Session的本地缓存，在Session的生命周期内缓存数据。如果要启用全局二级缓存，需要在映射器XML文件中添加以下配置：\n```\n<cache/>\n```\n该配置的作用如下：\n- 所有查询操作返回的结果都会被缓存；\n- 所有新增、更新和删除操作都会清空缓存；\n- 缓存会使用最近最少使用（LRU）淘汰算法删除旧缓存；\n- 缓存不会在任何基于时间表的时间进行清空动作，即清空间隔时间为0；\n- 缓存会保存1024个列表或对象的指针；\n- 缓存将被视为读/写缓存，这意味着检索到的对象不被共享，并且可以由调用者安全地修改，而不会干扰其他调用者或线程的其他可能的修改。\n\n上面的配置均采用了`<cache/>`元素属性的默认值：\n\n| 属性 | 默认值 | 描述 |\n| ---- | ---- | ---- |\n| type |`org.apache.ibatis.cache.impl.PerpetualCache`|缓存的实现|\n| eviction |`org.apache.ibatis.cache.decorators.LruCache`|缓存淘汰策略|\n| flushInteval |0|清空缓存的间隔时间|\n| size |1024|缓存大小|\n| readOnly |true|缓存只读标志|\n| blocking |false|未知|\n\n这些属性在JAVA代码中则放在了`org.apache.ibatis.annotations.CacheNamespace`注解中：\n```\n@Documented\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.TYPE)\npublic @interface CacheNamespace {\n    Class<? extends org.apache.ibatis.cache.Cache> implementation() default PerpetualCache.class;\n    \n    Class<? extends org.apache.ibatis.cache.Cache> eviction() default LruCache.class;\n    \n    long flushInterval() default 0;\n    \n    int size() default 1024;\n    \n    boolean readWrite() default true;\n    \n    boolean blocking() default false;\n    \n    /**\n    * Property values for a implementation object.\n    * @since 3.4.2\n    */\n    Property[] properties() default {};\n}\n```\n\n## 2.1 缓存的实现（type）\nMyBatis提供了一个接口`org.apache.ibatis.cache.Cache`，用来实现自定义的缓存。\n```\npublic class PerpetualCache implements Cache {\n\n    private final String id;\n\n    public PerpetualCache(String id) {\n        this.id = id;\n    }\n    \n    ...\n}\n```\n> 说明：Cache的实现必须有一个String类型的构造参数用来接收缓存id，MyBatis会将命名空间作为id传进来。\n\n默认的缓存实现`org.apache.ibatis.cache.impl.PerpetualCache`直接用一个`HashMap<Object, Object>`对象`cache`作为缓存容器，对该对象做增删查改。\n```\npublic class PerpetualCache implements Cache {\n\n    ...\n    \n    private Map<Object, Object> cache = new HashMap<Object, Object>();\n    \n    @Override\n    public void putObject(Object key, Object value) {\n        cache.put(key, value);\n    }\n    \n    @Override\n    public Object getObject(Object key) {\n        return cache.get(key);\n    }\n    \n    @Override\n    public Object removeObject(Object key) {\n        return cache.remove(key);\n    }\n    \n    @Override\n    public void clear() {\n        cache.clear();\n    }\n    \n    ...\n}\n```\n\n## 2.2 淘汰策略（eviction）\n可用的淘汰策略有：\n- LRU：即最近最少使用，移除最长时间没有使用的对象；\n- FIFO：即先进先出，移除最先被缓存的对象；\n- SOFT：即软引用，根据垃圾回收器状态和软引用的规则移除对象；\n- WEEK：即弱引用，比SOFT更积极。\n\n以默认的LRU策略为例，它的实现是`org.apache.ibatis.cache.decorators.LruCache`，有3个对象属性：\n```\n// 缓存的实现\nprivate final Cache delegate;\n\n// 缓存的键名集合\nprivate Map<Object, Object> keyMap;\n\n// 键名集合中最久没用的键名\nprivate Object eldestKey;\n```\n其中，所有对缓存的增删改查操作都交给了`delegate`，LruCache只负责判断哪个键名指向的对象是最长时间未被使用的，而这个判断则交给了`java.util.LinkedHashMap`类型的`keyMap`。LinkedHashMap在每次做完插入操作后，都会获取最长时间未被使用的对象，并根据需求判断是否需要删除该对象：\n```\nvoid afterNodeInsertion(boolean evict) { // possibly remove eldest\n    LinkedHashMap.Entry<K,V> first;\n    // head指向的就是最长时间未使用的对象，赋值给了first，然后传给了removeEldestEntry()方法\n    // removeEldestEntry()方法永远返回的是false，因此LinkedHashMap默认不会删除最长未使用的对象\n    if (evict && (first = head) != null && removeEldestEntry(first)) {\n        K key = first.key;\n        removeNode(hash(key), key, null, false, true);\n    }\n}\n```\nLruCache重写了LinkedHashMap的`removeEldestEntry()`，将LinkedHashMap传给该方法的最长未使用对象的键名赋值给了`eldestKey`：\n```\nkeyMap = new LinkedHashMap<Object, Object>(size, .75F, true) {\n    private static final long serialVersionUID = 4267176411845948333L;\n    \n    @Override\n    protected boolean removeEldestEntry(Map.Entry<Object, Object> eldest) {\n        // 每次向LinkedHashMap执行put时，判断长度是否超过了缓存大小\n        boolean tooBig = size() > size;\n        // 如果超过了，则准备删除最长时间未使用的对象\n        if (tooBig) {\n            eldestKey = eldest.getKey();// 将键名赋值给eldestKey\n        }\n        return tooBig;\n    }\n};\n```\n每次put缓存时，都会判断eldestKey是否为null：\n```\npublic void putObject(Object key, Object value) {\n    delegate.putObject(key, value);\n    cycleKeyList(key);\n}\n```\n```\nprivate void cycleKeyList(Object key) {\n    keyMap.put(key, key);\n    if (eldestKey != null) {\n        delegate.removeObject(eldestKey);\n        eldestKey = null;\n    }\n}\n```\n\n> 了解淘汰策略的源码除了能够明白策略的实现原理，最大的收获就是知道了LinkedHashMap自带有LRU算法。\n\n## 2.3 清空的间隔（flushInteval）\n清空的间隔时间可以被设置为任意的正整数,而且它们代表一个合理的毫秒形式的时间段。默认情况是不设置,也就是没有刷新间隔,缓存仅仅调用语句时刷新。\n\n## 2.4 缓存的大小（size）\n正如2.1节MyBatis默认缓存实现的源码所示，缓存容器是一个HashMap对象，所以size属性约束的就是HashMap的元素数量。\n\n## 2.5 缓存只读（readOnly）\n只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改，而且速度更快；而可读写的缓存会（通过序列化）返回缓存对象的拷贝，速度慢一些，但是安全，因此默认是`false`。\n\n# 3 示例\n```\n<cache eviction=\"FIFO\" flushInterval=\"60000\" size=\"512\" readOnly=\"true\"/>\n```\n上述配置创建了一个采用FIFO淘汰策略的缓存，每个60秒清空一次，最多只能存储512个引用或结果对象。获取的对象只读，因此企图修改它们的操作会在不同线程的调用者间造成冲突。', '1', '13');
INSERT INTO `blog` VALUES ('16', '1', '【基础知识】MyBatis映射文件 - resultMap元素', 'MyBatis从入门到精通', '2017-12-30 06:41:14', '3', '0', null, '2017-12-28 09:18:53', '# 1 目录\n[TOC]\n\n# 2 概述\n`<resultMap/>`主要用于描述从数据库中返回的数据如何映射到JAVA对象。用于描述的完整结构如下：\n- `<constructor/>`：类的构造方法映射描述。\n- - `<idArg/>`：每条数据的主键的映射描述\n- - `<arg/>`：其他实参的映射描述。\n- `<id/>`：每条数据的主键的映射描述。\n- `<result/>`：普通字段的映射描述。\n- `<association/>`：关联对象的映射描述。\n- - 嵌入结果映射\n- `<collection/>`：对象集合的映射描述。\n- - 嵌入结果映射\n- `<discriminator/>`：利用某个字段的值来判断使用哪个结果映射。\n- - `<case/>`：基于某个值的结果映射。\n- - - 嵌入结果映射\n\n`<resultMap/>`元素的属性如下：\n\n|属性|描述|\n|--|--|\n|id|描述的唯一标识|\n|type|类的全限定名，或者一个类型别名（参见`<select/>`元素的讲解）|\n|autoMapping|自定映射。默认不做设置|\n\n## 2.1 简单映射（id&result）\n将一条数据库数据映射到一个没有普通的POJO对象中，只需要用到`<id/>`和`<result/>`元素：\n```\n<resultMap id=\"tsUserMapper\" type=\"chngzhen.iba.mvc.model.domain.TsUser\">\n    <id column=\"id\" property=\"id\" />\n    <result column=\"user_name\" property=\"userName\" />\n    <result column=\"user_pswd\" property=\"userPswd\" />\n</resultMap>\n```\n`<id/>`和`<result/>`元素的属性如下：\n\n|属性|描述|\n|--|--|\n|column|数据库的字段名或别名|\n|property|POJO对象的属性名。支持点式复杂属性导航，如“blog.id”|\n|javaType|POJO对象属性的JAVA数据类型。类型的全限定名或别名，一般MyBatis可以自行判断|\n|jdbcType|做增删改操作时指定对象属性的JDBC类型。只需要对可能为空的对象属性指定该属性|\n|typeHandler|类型处理器的全限定名或别名。可以自定义类型处理器覆盖默认的实现|\n\nMyBatis支持的JDBC类型如下：\n- 整型：BIT、TINYINT、SMALLINT、INTEGER、BIGINT\n- 小数型：FLOAT、REAL、DOUBLE、NUMERIC、DECIMAL\n- 字符型：CHAR、VARCHAR、LONGVARCHAR、NVARCHAR、NCHAR\n- 时间型：DATE、TIME、TIMESTAMP\n- 二进制型：BINARY、VARBINARY、LONGVARBINARY、BLOB、CLOBN、CLOB\n- 其他类型：NULL、OTHER、CURSOR、BOOLEAN、UNDEFINED、ARRAY\n\n## 2.2 构造方法（constructor）\n`<constructor/>`节点包含两个重要的子节点：`<idArg/>`和`<arg/>`。如之前所述，前者用于将数据主键映射到构造参数，后者则用于映射其他数据。\n```\n<resultMap id=\"tsUserMapper\" type=\"chngzhen.iba.mvc.model.domain.TsUser\">\n    <constructor>\n        <idArg column=\"id\" javaType=\"int\" name=\"id\" />\n        <arg column=\"username\" javaType=\"String\" name=\"userName\" />\n    </constructor>\n    <result column=\"user_pswd\" property=\"userPswd\" />\n</resultMap>\n```\n上述配置要求`chngzhen.iba.mvc.model.domain.TsUser`必须有一个`public TsUser(Integer id, String username)`构造方法：\n```\npublic class TsUser{\n	private Integer id;\n	private String userName;\n	private String userPswd;\n	// 省略Getter和Setter\n	\n	public TsUser(Integer id, String userName) {\n		this.id = id;\n		this.userName = userName;\n	}\n}\n```\n\n`<idArg/>`和`<arg/>`的属性如下：\n\n|属性|描述|\n|--|--|\n|column|数据库的字段名或别名|\n|javaType|POJO对象属性的JAVA数据类型。类型的全限定名或别名，一般MyBatis可以自行判断|\n|name|构造方法形参的名称。用于精确映射构造参数|\n|jdbcType|做增删改操作时指定对象属性的JDBC类型。只需要对可能为空的对象属性指定该属性|\n|typeHandler|类型处理器的全限定名或别名。可以自定义类型处理器覆盖默认的实现|\n|select|指向另一个`<select/>`元素，用该映射语句的查询结果做OR映射。参见关联查询。|\n|resultMap|指向另一个`<resultMap/>`元素，将联合查询的部分结果映射到另一个POJO对象。参见关联查询|\n\n## 2.3 关联查询\n`<association/>`是一对一关联，即POJO对象中包含了另外一个对象，POJO对象的某个属性在数据库中是外键。例如Blog中的userId属性是一个外键，Blog对象中有个TsUser对象：\n```\npublic class Blog{\n	private Integer id;\n	// 其他Blog属性\n	private Integer userId;\n	\n	private TsUser tsUser;\n	// 省略Getter和Setter\n}\n```\n可以通过联表查询在查询Blog信息时同时根据userId属性查询TsUser的信息，并将结果映射到两个对象中：\n```\n<resultMap id=\"blogResult\" type=\"Blog\">\n	<id property=\"id\" column=\"id\" />\n	<result property=\"userId\" column=\"user_id\" />\n    <association property=\"author\" column=\"user_id\" javaType=\"chngzhen.iba.mvc.model.domain.TsUser\" select=\"selectAuthor\"/>\n</resultMap>\n\n<select id=\"selectAuthor\">\n	<!-- 该标签参见相关讲解 -->\n</select>\n```\n也可以通过嵌套查询结果，来映射对象的关联对象：\n```\n<resultMap id=\"blogResult\" type=\"Blog\">\n    <id property=\"id\" column=\"blog_id\" />\n    <result property=\"userId\" column=\"user_id\"/>\n    <association property=\"author\" column=\"user_id\" javaType=\"chngzhen.iba.mvc.model.domain.TsUser\" resultMap=\"TsUser\"/>\n</resultMap>\n\n<resultMap id=\"TsUser\" type=\"chngzhen.iba.mvc.model.domain.TsUser\">\n	<!-- TsUser的映射描述 -->\n</resultMap>\n```\n\n`<association/>`的属性如下：\n\n|属性|描述|\n|--|--|\n|property|数据库的字段映射到对象的属性名称|\n|javaType|数据映射后的JAVA数据类型。JAVA类的全限定名或别名，一般MyBatis可以自定判断|\n|jdbcType|做增删改操作时指定对象属性的JDBC类型。只需要对可能为空的对象属性指定该属性|\n|typeHandler|类型处理器的全限定名或别名。可以自定义类型处理器覆盖默认的实现|\n\n\n## 2.4 ', '1', '13');
INSERT INTO `blog` VALUES ('17', '1', '【基础知识】JAVA线程 - 线程的中断', null, '2017-12-28 09:21:07', '0', '0', null, '2017-12-28 09:21:07', '# 1 目录\n[TOC]\n\n# 2 概述\n> Java有3种终止线程的方法：自然结束、调用`stop()`和调用`interrupt()`。--《Java多线程编程核心技术》\n\n由于stop()方法并不安全，因此本文将主要讲解利用interrupt()中断线程的方法。\n\n为了区分，这里将线程分为逻辑线程和物理线程：\n- 逻辑线程：JAVA管理的抽象线程；\n- 物理线程：系统分配的线程。\n\n# 3 interrupt()\n> 小节简介：interrupt()方法并不会真正中断物理线程，只是标记了逻辑线程的中断标志。\n\n在main()方法中**意图中断主线程**，然后输出一条信息检查线程是否中断：\n```\npublic static void main(String[] args) {\n    Thread.currentThread().interrupt(); // 中断当前线程（主线程）\n    log.info(\"当前线程（主线程）终止后的输出\"); // 该语句正常执行并输出\n}\n```\n从代码逻辑上来讲，利用`Thread.currentThread().interrupt();`中断主线程之后，后面的日志打印语句就不应该执行，但实际上控制台会正常打印日志。\n\n也就是说，`interrupt()`方法并没有真正地中断物理线程。查看该方法的源码可以发现，官方在注释中明确指出了，执行中断操作的`interrupt0()`方法**只设置线程的中断标志**，而**不是直接中断线程**。\n```\npublic void interrupt() {\n    if (this != Thread.currentThread())\n        checkAccess();\n    \n    synchronized (blockerLock) {\n        Interruptible b = blocker;\n        if (b != null) {\n            interrupt0();           // Just to set the interrupt flag\n            b.interrupt(this);\n            return;\n        }\n    }\n    interrupt0();\n}\n```\n\n## 3.1 中断标志\n> 小节简介：中断标志指示了所属逻辑线程的中断状态：true表示逻辑线程中断。\n\n`java.lang.Thread`提供了两个方法来获取逻辑线程的中断标志：\n- interrupted()：测试当前线程是否处于中断状态并返回中断标志；\n- isInterrupted()：测试线程自身是否处于中断状态并返回中断标志。\n\n> 说明：所谓当前线程，指执行当前代码的线程。例如，在`main()`方法中执行`new MyThread().interrupted()`，当前线程就是指`main()`所在的线程，即主线程，而不是MyThread线程。\n\n### 3.1.1 isInterrupted()\n```\npublic boolean isInterrupted() {\n    return isInterrupted(false);\n}\n\nprivate native boolean isInterrupted(boolean ClearInterrupted);\n```\n根据`Thread.isInterrupted()`的源码可知，该方法只能通过Thread对象调用，判断的是线程自身的中断状态。\n\n`isInterrupted()`允许传入一个“清除中断状态”的布尔标识：\n- true：此次判断后将线程的中断标志置为false；\n- false：默认值。此次判断后不修改线程的中断标志。\n\n### 3.1.2 interrupted()\n```\npublic static boolean interrupted() {\n    return currentThread().isInterrupted(true);\n}\n```\n根据`Thread.interrupted()`的源码可知，该方法是静态方法，利用`currentThread()`获取到当前线程的Thread对象，然后利用`isInterrupted()`判断该对象的中断状态。因此，`interrupted()`判断的是该方法的调用过程所在的线程是否处于中断状态。\n\n需要注意的是，`Thread.interrupted()`在中断当前线程时，传了一个“清除终端状态”的标识。即，当调用该方法判断当前线程的中断状态之后，会将当前线程的中断状态置为false。如果此后没有再次中断当前线程的操作，连续调用该方法时，永远返回的是false。\n```\npublic static void main(String[] args) {\n    log.info(\"当前线程的状态：{}\" , Thread.interrupted()); // 输出false\n    Thread.currentThread().interrupt(); // 终端当前线程\n    log.info(\"当前线程的状态：{}\" , Thread.interrupted()); // 输出true\n    log.info(\"当前线程的状态：{}\" , Thread.interrupted()); // 输出false\n    log.info(\"当前线程的状态：{}\" , Thread.interrupted()); // 输出false\n    Thread.currentThread().interrupt(); // 再次中断当前线程\n    log.info(\"当前线程的状态：{}\" , Thread.interrupted()); // 输出true\n}\n```\n\n### 3.1.3 两者的区别\n例如：MyThread继承自Thread，一直处于执行状态：\n```\npublic class MyThread extends Thread {\n    @Override\n    public void run() {\n        while(true) {}\n    }\n}\n```\n然后在`main()`方法里启动MyThread线程并中断主线程：\n```\npublic static void main(String[] args) {\n    MyThread myThread = new MyThread(); // 创建副线程\n    myThread.start(); // 启动副线程\n    Thread.currentThread().interrupt(); // 中断主线程\n    log.info(\"myThread的interrupted:{}\", myThread.interrupted());\n    log.info(\"myThread的isInterrupted:{}\", myThread.isInterrupted());\n}\n```\n输出MyThread对象两种判断的结果：\n```\n2017-12-21 17:19:31 698[main] Main[16] - myThread的interrupted:true\n2017-12-21 17:19:31 702[main] Main[17] - myThread的isInterrupted:false\n```\n根据上述结果可以明确地理解两者的区别：`myThread.interrupted()`判断的是主线程的中断状态，而`myThread.isInterrupted()`判断的是myThread线程的中断状态。\n\n# 4 中断线程\n> 注意：对休眠状态的线程进行中断操作、对中断状态的线程进行休眠操作都会抛出异常。\n\n如前文所述，`interrupt()`不会真正地中断线程，只会修改线程的中断状态，因此JAVA替代`stop()`的方式是利用该状态来跳过业务逻辑，直接结束`run()`方法的执行，从而使这个线程“执行完毕”。\n\n## 4.1 异常中断\n> 小节简介：interrupt()不会直接中断活动状态的物理线程，可以利用它修改的“线程中断状态标志”来使活动状态的线程抛出异常，结束业务操作。\n\n在`run()`方法中通过判断线程的中断状态来结束局部业务操作：\n```\npublic class MyThread extends Thread {\n    @Override\n    public void run() {\n        while (true) {\n            if (this.isInterrupted()) break; // 线程中断状态标志为true时，终止业务\n\n            // TODO： 业务逻辑\n        }\n    }\n}\n```\n在`main()`方法中利用`interrupt()`中断MyThread的对象，程序最终会自动结束：\n```\npublic static void main(String[] args) {\n    MyThread myThread = new MyThread();\n    myThread.start();\n    myThread.interrupt();\n}\n```\n但如果while语句后面还有业务逻辑，依旧会执行。这不符合预期（彻底中断所有业务操作）：\n```\npublic class MyThread extends Thread {\n    @Override\n    public void run() {\n        int i=0;\n        while (i++<50000) {\n            if (this.isInterrupted()) break; // 线程中断状态标志为true时，终止业务\n\n            // TODO： 业务逻辑\n        }\n        \n        // TODO：业务逻辑\n    }\n}\n```\n可以利用抛出和捕获异常的方式，跳过所有业务逻辑：\n```\npublic class MyThread extends Thread {\n    @Override\n    public void run() {\n        try{\n            int i=0;\n            while (i++<50000) {\n                if (this.isInterrupted())\n                    throw new RuntimeException(\"线程已中断\"); // 线程中断状态标志为true时，抛出异常\n    \n                // TODO： 业务逻辑\n            }\n            \n            // TODO：业务逻辑\n        } catch(Exception e) {\n            \n        }\n    }\n}\n```\n\n## 4.2 return中断\n> 小节简介：interrupt()不会直接中断活动状态的物理线程，可以利用它修改的“线程中断状态标志”来结束run()方法，以此跳过后面的业务逻辑。\n\nrun()方法的返回值类型为void，判断线程的中断状态后直接返回一个空值，就可以结束run()方法，从而真正的中断线程：\n```\npublic class MyThread extends Thread {\n    private static final Logger log = LoggerFactory.getLogger(MyThread.class);\n\n    @Override\n    public void run() {\n        int i=0;\n        while (i++<50000) {\n            if (this.isInterrupted()) return; // 线程中断状态标志为true时，结束run()方法\n\n            // TODO： 业务逻辑1\n        }\n        log.info(\"业务逻辑2\");\n    }\n}\n```', '1', '10');
INSERT INTO `blog` VALUES ('18', '1', '【基础知识】JAVA修饰符 - Static', null, '2017-12-28 09:22:18', '0', '0', null, '2017-12-28 09:22:18', '1. 加载类：初始化static属性，执行static代码块\n2. 实例化：初始化父类成员属性，执行父类构造方法；初始化子类成员属性，执行子类构造方法\n\n## 1 静态导入\n\n### 1.1 全类导入\n导入指定类的所有`公共`静态成员（包括静态属性和静态方法）。\n```\nimport static chngzhen.test.statics.TestStatic.*;\n\npublic class Primary {\n	private static final Logger log4Primary = LoggerFactory.getLogger(Primary.class);\n\n	public static void main(String[] args) {\n		log4Primary.info(\"私有静态成员属性：{}\", log4TestStatic); // 报错\n		log4Primary.info(\"公有静态成员属性：{}\", CLASS_NAME);\n		log4Primary.info(\"公有静态成员方法：{}\", sayHello());\n	}\n}\n```\n\n### 1.2 成员导入\n导入指定类的特定`公共`静态成员（包括静态属性和静态方法）。\n```\nimport static chngzhen.test.statics.TestStatic.sayHello;;\n\npublic class Primary {\n	private static final Logger log4Primary = LoggerFactory.getLogger(Primary.class);\n\n	public static void main(String[] args) {\n		log4Primary.info(\"私有静态成员属性：{}\", log4TestStatic); // 报错\n		log4Primary.info(\"公有静态成员属性：{}\", CLASS_NAME); // 报错\n		log4Primary.info(\"公有静态成员方法：{}\", sayHello());\n	}\n}\n```\n\n## 2 静态属性\n普通属性在对象被创建的时候初始化，依附于该对象，两者的关系是一对一；而静态属性在类被加载的时候创建，独立于类对象，两者是一对多的关系。\n> 注：静态属性虽然独立于对象，一般的调用方式是`类名.属性名`，但也可以通过对象调用该属性：`对象.属性名`。常见的疑惑就是能否通过this调用静态属性，this指向的是当前对象，所以是可以的。\n\n## 3 静态代码块\n静态代码块和静态属性类似，在类被初次加载的时候执行，且只执行一次。\n\n## 4 静态方法\n> 思考：构造方法是不是静态的？\n', '1', '10');
INSERT INTO `blog` VALUES ('19', '1', '【基础知识】JAVA数据类型 - BitSet', null, '2017-12-28 09:23:03', '0', '0', null, '2017-12-28 09:23:03', '# 1 目录\n[TOC]\n\n# 2 修改记录\n|时间|描述|\n|--|--|\n|2017-12-07|建档|\n\n# 3 名词解释\n为了方便讲解和理解，本文自定义了部分名词，再次说明：\n- **【目标数字】** `bitIndex`，指需要被存储的数字。通常是`BitSet.set()`方法的参数；\n- **【仓库数字】** `word`，指用来存储目标数字的long类型数字。默认该数字为0L；\n- **【仓库】** `words`，指仓库数字的集合。默认长度为1；\n- **【需求数量】** `wordsRequired`，指存储目标数字时需要用到的仓库数字数量。仓库数字是64位（位索引范围是0-63）long类型，则仓库第一个（索引为0）的仓库数字可以独立存储0-63的目标数字；当存储64-127时，则需要2个仓库数字；\n- **【有效数量】** `wordsInUse`，指用来存储最大目标数字时所用的仓库数字的数量，也能表示BitSet能存储的数字的有效范围。例如，BitSet中存储了{1,60,120}三个数字，则有效数量就是用来存储120所用到的仓库数量，即2；2个有效仓库数字能存储0-127的数字，那么BitSet当前的有效范围就是[0, 128)；\n \nBitSet用64位二进制中每一位的索引来存储数字。例如，存储数字3，就将二进制中从右往左数的第3位设置成1。该二进制初始化时为64个0。\n\n该二进制数转化成long类型的**仓库数字**存储在一个long数组中`words`，即**仓库**。当存储的数字大于63（即超出了一个二进制long数据的长度）时，**仓库**就会新增一个**仓库数字**合作存储它。\n\n对比传统的存储方式，一个数字（例如3）以int方式存储，需要4个字节32位；而利用BitSet，只需要1位即可表示该数字。\n\n# 4 源码解析\n## 4.1 set(int bitIndex)\n1.  判断目标数字是否小于0：true-抛出异常，false-进入步骤2；\n    ```\n    if (bitIndex < 0)\n        throw new IndexOutOfBoundsException(\"bitIndex < 0: \" + bitIndex);\n    ```\n2.  计算存储了目标数字的位数据所在仓库数字的索引。例如，存储了60的位数据在索引为60/64=0的仓库数字中。\n    ```\n    int wordIndex = wordIndex(bitIndex);\n    ```\n    具体计算方法如下。因为仓库数字是long类型，长度为64位（2的6次方），目标数字作为索引不能超过这个长度，因此计算方式是目标数字除64取整，也即目标数字右移6位：\n    ```\n    private static int wordIndex(int bitIndex) {\n        return bitIndex >> ADDRESS_BITS_PER_WORD; // ADDRESS_BITS_PER_WORD=6\n    }\n    ```\n3.  调整BitSet的有效范围。\n    ```\n    expandTo(wordIndex);\n    ```\n4.  设置存储位。需要注意的是JAVA的位移操作，如果位移的位数大于数据类型的长度，JAVA并不会位移那么多位，而是只会位移`位数%类型长度`的位数。例如，对1进行左位移120位操作时，实际只位移120%32=24位，其余补0；对1L进行左位移120位操作时，JAVA只位移120%64=56位，其余补0。\n    ```\n    words[wordIndex] |= (1L << bitIndex);\n    ```\n    例如，存储120时，第一个仓库数字不变，第二个仓库数字与2的56次方进行或操作，即将第二个仓库数字的第57位（下标为63+57=120）设置成1。\n    > 注意：之所以是63+57，是因为第一个仓库数字的索引是从0开始的，第64位的索引是63；而除第一个仓库数字之外的其他仓库数字的索引均是从1开始的，或者将他们单纯地理解为增量。\n5.  检验。\n    ```\n    private void checkInvariants() {\n        assert(wordsInUse == 0 || words[wordsInUse - 1] != 0);\n        assert(wordsInUse >= 0 && wordsInUse <= words.length);\n        assert(wordsInUse == words.length || words[wordsInUse] == 0);\n    }\n    ```\n\n## 4.2 expandTo()\n确保BitSet的有效范围。如果有效数量小于的需求数量，则需提升BitSet的有效范围。\n```\nprivate void expandTo(int wordIndex) {\n    // 需求数量：仓库数字索引+1\n    // 例如，目标数字为2，则仓库数字索引是2/64=0，需求数量是0+1=1，即只需要一个仓库数字就能存储目标数字2；\n    // 同理，目标数字为67，则仓库数字索引是67/64=1，需求数量是1+1=2，即需要两个仓库数字才能存储目标数字67。\n    int wordsRequired = wordIndex+1;\n    \n    // 如果有效数量小于需求数量，表示目前有效仓库数字的数量不足以存储该数字，需提升有效仓库数字的数量\n    if (wordsInUse < wordsRequired) {\n        ensureCapacity(wordsRequired);\n        wordsInUse = wordsRequired;\n    }\n}\n```\n\n## 4.3 ensureCapacity()\n仓库`words`自动扩容。执行到这儿，说明目标数字是当前BitSet存储的最大数字，有效数量无法满足存储该数字的需求，因此需要提升有效仓库数字的数量。\n```\nprivate void ensureCapacity(int wordsRequired) {\n\n}\n```\n如果仓库现有的长度不够，默认2倍递增；如果2倍依然不够，则以需求数量为扩容标准进行扩容。\n\n例如，仓库当前长度是4，每个仓库数字是64位，如果目标数字是258，则wordRequired=258/64（=4）+1=5，仓库长度不够，默认按两倍扩容至8，能满足需求数量（5）；如果目标数字是513，则wordRequired=512/64（=8）+1=9，仓库长度不够，默认2倍扩容至8，无法满足需求数量9，因此BitSet会扩容至9。\n```\nif (words.length < wordsRequired) {\n    int request = Math.max(2 * words.length, wordsRequired);\n    words = Arrays.copyOf(words, request);\n}\n```', '1', '10');
INSERT INTO `blog` VALUES ('20', '1', '【产品介绍】Generator - 代码生成器', null, '2017-12-28 09:26:46', '0', '0', null, '2017-12-28 09:26:46', '# 1 目录\n[TOC]\n\n# 2 修改记录\n|时间|描述|\n|--|--|\n|2017-08-16|建档|\n|2017-08-24|Java转Kotlin|\n|2017-11-20|解决默认模板路径不支持IDEA的BUG|\n|2017-12-14|新增MyBatis相关模板|\n\n# 3 快速开始\n使用时，除了模板文件，只需修改`chngzhen.generator.main.Generator`类的`chngzhen.generator.config.GeneralConfig`对象，该对象的属性贯穿整个生成过程。\n\n程序默认定义了一个名为`configureEntity`的`GeneralConfig`对象：\n```\nvar configureEntity = GeneralConfig()\n```\n\n## 3.1 配置信息\n### 3.1.1 配置数据库信息\n数据库连接信息包括数据库地址（url）、用户名（user）和密码（pswd），此外还需要指定生成目标文件所需的数据结构（即表）集合。\n\n|属性|数据类型|默认值|描述|\n|:--|--|--|--|\n|`url`|`String`|\"\"|数据库配置。数据库地址.|\n|`user`|`String`|\"root\"|数据库配置。数据库用户名。|\n|`pswd`|`String`|\"root\"|数据库配置。数据库密码。|\n|`tables`|`List<String>`|{}|生成目标文件的数据结构集合。程序根据表名获取数据结构信息，然后渲染到模板文件生成目标文件。|\n\n其中，对数据库的某些约束（如字符编码等）直接以参数的形式添加在url后面，类似HTTP请求。\n```\nconfigureEntity.url=\"jdbc:mysql://localhost:3306/chngzhen?characterEncoding=utf8&...\"\nconfigureEntity.user=\"user001\"\nconfigureEntity.pswd=\"pswd123\"\n\nconfigureEntity.tables=listOf(\"ts_log\", \"ts_user\")\n```\n\n> 程序暂时只在MySQL上测试和使用过，因此建议使用MySQL设计数据存储结构。\n\n### 3.1.2 配置项目信息\n项目信息主要用于生成代码文件的基本包路径和基本文件路径。\n\n|属性|数据类型|默认值|描述|\n|--|--|--|--|\n|`orgType`|`String`|\"\"|基本包路径配置项。客户组织类型，与其余两个配置组成类文件的基本包路径|\n|`orgName`|`String`|\"\"|基本包路径配置项。客户组织名称，与其余两个配置组成类文件的基本包路径|\n|`proName`|`String`|\"\"|基本包路径配置项。代码项目名称，与其余两个配置组成类文件的基本包路径|\n\n以JAVA为例，类的顶部需要添加`package ...`语句以声明类所在的包，而`.java`文件也是按照这个路径存放的。\n```\nconfigureEntity.orgType=\"chngzhen\"// 组织类型：com、cn、edu等\nconfigureEntity.orgName=\"iba\"// 组织名称：sina、baidu等\nconfigureEntity.proName=\"mvc\"// 项目名称：weixin、qq等\n```\n\n> 程序默认的基本包路径格式为`orgType.orgName.proName`。如chngzhen.iba.mvc。\n\n### 3.1.3 配置模板文件路径\n程序默认模板文件须存放在类路径下的templates文件夹下。\n\n|属性|数据类型|默认值|描述|\n|--|--|--|--|\n|`templatePath`|`String`|classpath:templateInfos/|模板文件根路径。默认为类路径下的`templateInfos`文件夹。|\n\n如果需自定义模板文件的位置，可以通过修改`templatePath`参数覆盖默认的模板文件路径：\n```\nconfigureEntity.templatePath=configureEntity.javaClass.classLoader.getResource(\"templateInfos\").path\n```\n\n### 3.1.4 配置命名策略\n命名策略用于数据库名称与应用名称的相互转化。\n\n|属性|数据类型|默认值|描述|\n|--|--|--|--|\n|`namingStrategy`|`NamingStrategy`|BaseNamingStrategy()|命名策略。用于数据库与应用之间名称的相互转化，如字段名称转化属性名称等。|\n\n如果自定义了命名策略的实现，可以通过修改`namingStrategy`覆盖默认的命名策略对象：\n```\nconfigureEntity.namingStrategy = BaseNamingStrategy()\n```\n\n> 自定义的命名策略必须实现`chngzhen.generator.intf.NamingStrategy`接口。\n\n## 3.2 配置模板\n如果模板文件的存放路径中存在占位符，则必须且只能是以下几种：\n\n|占位字符串|翻译|示例|\n|--|--|--|\n|${AuthName}|类名小写|TsUser==>tsuser|\n|${BasePackageDir}|orgType/orgName/proName/|generations/com/sina/weibo/|\n|${ClassName}|类名|TsUser|\n\n以下给出一个大致的翻译过程：\n```\norgType=com\norgName=sina\nproName=weibo\n== 可得 ==>\n${BasePackageDir}=com/sina/weibo/\n\n// 模板文件根路径\ntemplatePath=/../templateInfos/\n== 可得 ==>\n// 模板文件路径：以DOMAIN类模板文件为例\ntemplateFilePath=/../templateInfos/src/java/${BasePackageDir}/model/domain/${ClassName}.java\n\n== 根据模板文件路径翻译输出路径 ==>\n// 目标文件输出路径\noutputFilePath=/../generations/src/java/com/sina/weibo/model/domain/TsUser.java\n```\n\n> 程序在翻译目标文件输出路径时，首先将模板文件路径中的根路径由templates改为generations；然后翻译路径中的占位字符串，最后渲染输出。\n\n程序使用的是FreeMarker作为模板引擎。可供渲染的数据如下：\n\n|名称|描述|\n|--|--|\n||**表信息对象。调用格式：直接调用**|\n|tableName|表名。当前用于生成目标文件所用的数据结构|\n|className|类名。利用`namingStrategy.toNormalName(String tableName)`转换。|\n|instanceName|实例名。利用`namingStrategy.toInstanceName(String tableName)`转换|\n|authName|权限名。利用`namingStrategy.toAuthName(String tablenName)`转换|\n|**column.**|**字段信息对象。调用格式：`column.*`**|\n|name|字段名称。如user_id|\n|normalName|字段的正常名称，利用`namingStrategy.toNormalName(String columnName)`转换。如UserId|\n|aliasName|字段的别名，利用`namingStrategy.toAliasName(String columnName)`转换。如ALIAS_USER_ID|\n|authName|字段的权限名称，利用`namingStrategy.toAuthName(String columnName)`转换。如userid|\n|instanceName|字段的属性名称，利用`namingStrategy.toInstanceName(String columnName)`转换。如userId|\n|remarks|字段的注释。如“用户ID”|\n|javaType|字段的JAVA类型。如`java.lang.Integer`|\n|kotlinType|字段的Kotlin类型。如`int`|\n|jdbcType|字段的JDBC类型。如`INTEGER`|\n|size|字段的长度。如11|\n|typeCode|字段的数据库类型代码。|\n|type|字段的数据库类型名称|\n|decimalDigits|字段的小数点精度|\n|nullable||\n|numPrecRadix||\n|default|字段的默认值|\n|charOctetLength||\n|ordinalPosition||\n|isNullable||\n|isAuto||\n|isKey|字段的主键标识。如果字段是主键，则值为true|\n\n# 4 源码地址\n\n[Github](https://github.com/Chngzhen/generator)', '1', '14');
INSERT INTO `blog` VALUES ('21', '1', '【解决方案】Linux问题 - aapt解析APK文件异常', null, '2017-12-28 09:28:28', '0', '0', null, '2017-12-28 09:28:28', '#### 1 权限不够\n错误提示：`/home/.../aapt d binding /../file:权限不够`\n\n解决方案：\n```\nchmod 777 /home/../aapt\n```\n##### 扩展知识\n在Linux下：\n- 文件具有读（r=4）、写（w=2）和执行（x=1）三种权限，还有一个限制X，表示只有当该文件是个子目录或者该档案已经被设定过为可执行；\n- 权限对象又分所有用户（a）、当前用户（u）、用户组（g）和其他用户（o）；\n- 权限操作分增加权限（+）、取消权限（-）和唯一设定权限（=）；\n\n格式：chmod [-cfvR] [--help] [--version] [ugoa][+-=][rwxX] [file]\n\n其中:\n- -c : 若该档案权限确实已经更改，才显示其更改动作\n- -f : 若该档案权限无法被更改也不要显示错误讯息\n- -v : 显示权限变更的详细资料\n- -R : 对目前目录下的所有档案与子目录进行相同的权限变更(即以递回的方式逐个变更)\n- --help : 显示辅助说明\n\n`chmod 777`等价于`chmod a=rwx`等价于`chmod u=rwx,g=rwx,o=rwx`，即所有用户均具有读写运行三种权限。其中7=r+w+x=4+2+1.\n\n#### 2 缺少libz.so.1\n错误提示：`error while loading shared libraries: libz.so.1: cannot open shared object file: no such file or directory`\n\n解决方案：\n使用`whereis libz.so.1`查询lib相关文件的位置。如果在库文件libz.so.1.y.z，则利用`ln -s libz.so.1.y.z /usr/lib/libz.so.1`重新建立libz.so.1的链接；如果没有库文件，则需要下载并安装库文件（推荐使用yum或rpm），例如zlib-1.2.3-29.el6.i686.rpm。\n\n#### 3 无法运行64位库文件\n错误提示：`error while loading shared libraries: libz.so.1: wrong ELF class: ELFCLASS64`\n\n解决方案：\naapt是32位的程序，使用的也是32位的libz库文件。可能是安装的libz.so是64位的。\n\n#### 4 缺少libstdc++.so.6\n错误提示：`error while loading shared libraries: libstdc++.so.6: cannot open shared object file: No such file or directory`\n\n解决方案：\n缺少libstdc++.so.6库文件（安装32位的库文件），例如libstdc++-4.4.7-18.el6.i686.rpm。', '1', '16');
INSERT INTO `blog` VALUES ('22', '1', '【解决方案】Spring快速整合MyBatis', null, '2017-12-28 09:30:03', '0', '0', null, '2017-12-28 09:30:03', '# 1 目录\n[TOC]\n\n# 2 修改记录\n|时间|描述|\n|--|--|\n|2017-12-14|建档|\n\n# 3 基本配置\n本文档建立在Spring+Spring MVC上，利用Maven构建项目，快速整合MyBatis。\n\n## 3.1 添加依赖\n> 说明：本文档不对Spring和Spring MVC所需的依赖做说明。\n\n使用MyBatis，需要添加MyBatis的依赖：\n```\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis</artifactId>\n    <version>x.x.x</version>\n</dependency>\n```\nSpring不像对Hibernate那样提供对MyBatis的支持，所以在Spring中使用MyBatis需要添加一个整合依赖：\n```\n<dependency>\n    <groupId>org.mybatis</groupId>\n    <artifactId>mybatis-spring</artifactId>\n    <version>x.x.x</version>\n</dependency>\n```\n\n## 3.2 配置文件\n在实际Spring项目中，一般都已经创建好DataSource。这里以Druid为例：\n```\n<bean id=\"dataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"\n    init-method=\"init\" destroy-method=\"close\" autowire=\"byName\">\n	<property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"/>\n	<property name=\"url\" value=\"${jdbc_url.mgr}\"/>\n	<property name=\"username\" value=\"${jdbc_username.mgr}\"/>\n	<property name=\"password\" value=\"${jdbc_password.mgr}\"/>\n	\n	<property name=\"initialSize\" value=\"3\"/>\n	<property name=\"minIdle\" value=\"3\"/>\n	<property name=\"maxActive\" value=\"20\"/>\n	\n	<!-- 配置获取连接等待超时的时间 -->\n	<property name=\"maxWait\" value=\"60000\"/>\n	<!-- 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 -->\n	<property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\"/>\n	<!-- 配置一个连接在池中最小生存的时间，单位是毫秒 -->\n	<property name=\"minEvictableIdleTimeMillis\" value=\"300000\"/>\n	\n	<property name=\"validationQuery\" value=\"SELECT \'x\'\"/>\n	<property name=\"testWhileIdle\" value=\"true\"/>\n	<property name=\"testOnBorrow\" value=\"false\"/>\n	<property name=\"testOnReturn\" value=\"false\"/>\n</bean>\n```\n\n### 3.2.1 创建Session工厂\nMyBatis的Session工厂是SqlSessionFactory，类似Hibernate的SessionFactory，由SqlSessionFactoryBean创建。\n```\n!-- 1 创建Session工厂\n        SqlSessionFactoryBean实现了Spring的FactoryBean接口，因此Spring创建的Session工厂并不是SqlSessionFactoryBean对象，\n    而是getObject()返回的SqlSessionFactory对象。和Hibernate不同的是，一般情况下不用在程序中显式使用Session工厂，它会会自\n    动被注入到MapperFactoryBean或其他扩展了SqlSessionDaoSupport的DAO中。\n        1.1 数据源：必填项。\n        1.2 数据映射器XML文件：可选项。如果数据映射器XML文件与接口类文件不在同一路径下，则需通过该参数指定XML文件的位置\n -->\n<bean id=\"ibaSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\">\n    <property name=\"dataSource\" ref=\"dataSource\" />\n    <property name=\"mapperLocations\" value=\"classpath*:mappers/*Mapper.xml\"></property>\n</bean>\n```\nMyBatis通常不用显式调用SqlSessionFactory和SqlSession，如果需要手动执行SQL语句，可以利用SqlSessionTemplate。\n\n### 3.2.2 注册映射器\nMyBatis的数据映射器类指DAO层接口，每个DAO层的接口对应了一个映射器XML文件，里面配置了映射语句。XML文件的加载在5.1节中的Session工厂配置时完成。\n```\n<!-- 2 注册映射器\n        批量注册映射器。MapperScannerConfigurer会自动加载指定路径下的所有映射器类，并创建成MapperFactoryBean。\n -->\n<bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\">\n    <!-- 指定会话工厂，如果当前上下文中只定义了一个则该属性可省去 -->\n    <property name=\"sqlSessionFactoryBeanName\" value=\"ibaSessionFactory\"></property>\n    <!-- 指定要自动扫描接口的基础包，实现接口 -->\n    <property name=\"basePackage\" value=\"chngzhen.iba.mvc.dao\"></property>\n</bean>\n```\n\n### 3.2.3 事务管理\n将MyBatis的事务交给Spring框架，从而能利用Spring的事务管理框架。\n```\n<!-- 3 事务管理器\n        MyBatis的事务管理借用了Spring的现有框架DataSourceTransactionManager，这样可以按照Spring的做法来管理MyBatis的事务。\n    例如：@Transaction注解和AOP配置。\n        2.1 数据源：必填项。该数据源必须被用来创建MyBatis的SqlSession工厂。\n -->\n<bean id=\"ibaTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\">\n    <property name=\"dataSource\" ref=\"dataSource\"></property>\n</bean>\n```\n例如：Spring允许使用注解。\n```\n<!-- 事务允许使用注解 -->\n<tx:annotation-driven transaction-manager=\"ibaTransactionManager\"/>\n```\n例如：Spring的AOP技术。\n```\n<!--支持注解驱动的事务管理，指定事务管理器 -->\n<tx:advice id=\"ibaAdvice\" transaction-manager=\"ibaTransactionManager\">\n    <tx:attributes>\n        <tx:method name=\"insert*\" propagation=\"REQUIRED\" />\n        <tx:method name=\"del*\" propagation=\"REQUIRED\" />\n        <tx:method name=\"find*\" propagation=\"REQUIRED\" />\n        <tx:method name=\"get*\" propagation=\"REQUIRED\" />\n        <tx:method name=\"update*\" propagation=\"REQUIRED\" />\n    </tx:attributes>\n</tx:advice>\n<aop:config>\n    <aop:pointcut expression=\"execution(* chngzhen.iba.**.service.*Impl.*(..))\" id=\"ibaPointcut\" />\n    <aop:advisor advice-ref=\"ibaAdvice\" pointcut-ref=\"ibaPointcut\" />\n</aop:config>\n```\n> 说明：关于Spring利用AOP技术管理事务的相关信息参见Spring的说明文档。\n\n## 3.3 数据映射器\n数据映射器分XML文件和接口类。\n\n### 3.3.1 映射器XML文件\n在resources下新建一个mappers文件夹，用于存放映射器的XML文件。\n> 说明：由于映射器的XML文件和映射器类不在同一路径下，因此在5.1节中需要手动加载映射器XML文件。\n\n```\n<!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\">\n\n<!-- namespace必须与接口的全类名一致-->\n<mapper namespace=\"chngzhen.iba.dao.TsTestDao\">\n    <!-- 查询结果映射：单条数据的映射逻辑 -->\n    <resultMap id=\"tsTestMapper\" type=\"chngzhen.iba.model.domain.TsTest\">\n        <id column=\"id\" property=\"id\" />\n        <result column=\"bit_set\" property=\"bitSet\" />\n    </resultMap>\n    \n    <!-- 查询字段 -->\n    <sql id=\"columns\">\n        <trim suffixOverrides=\",\">\n            id ,bit_set ,\n        </trim>\n    </sql>\n    \n    <!-- 过滤条件 -->\n    <sql id=\"where\">\n        <trim prefix=\"where\" suffixOverrides=\"and\">\n            <if test=\"id != null\"><![CDATA[ ts_test.id = #{ id } and ]]></if>\n            <if test=\"bitSet != null\"><![CDATA[ ts_test.bit_set = #{ bitSet } and ]]></if>\n        </trim>\n    </sql>\n    \n    <!-- 操作：根据条件获取单条数据 -->\n    <select id=\"getByCondition\" resultMap=\"tsTestMapper\">\n        select <include refid=\"columns\" /> from ts_test\n        <include refid=\"where\" /> limit 1\n    </select>\n</mapper>\n```\n\n### 3.3.2 映射器接口类\n映射器接口类的方法接口必须在XML文件中有匹配的映射语句，即方法名和操作的id相同。\n```\npublic interface TsTestDao {\n    public TsTest getByCondition(TsTestQuery tsTestQuery);\n}\n```\n> 说明：MyBatis的Dao层接口不需要实现，可以把XML文件看做是Dao层接口的实现。\n\n# 4 调用\n和Hibernate一样，利用`@Autowired`注解将Dao层对象注入到Service层即可使用。\n```\n@Service\npublic class TsTestServiceImpl implements TsTestService {\n\n	@Override\n	public TsTest getById(Integer id) throws Exception {\n		if(null==id) throw new RuntimeException(\"主键不能为空\");\n		TsTestQuery tsTestQuery = new TsTestQuery();\n		tsTestQuery.setId(id);\n		return tsTestDao.getByCondition(tsTestQuery);\n	}\n}\n```', '1', '13');

-- ----------------------------
-- Table structure for blog_comment
-- ----------------------------
DROP TABLE IF EXISTS `blog_comment`;
CREATE TABLE `blog_comment` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '评论ID',
  `comment` text COMMENT '评论内容',
  `create_time` datetime DEFAULT NULL COMMENT '评论时间',
  `user_name` varchar(255) DEFAULT NULL COMMENT '评论作者',
  `blog_id` int(11) DEFAULT NULL COMMENT '博客ID',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog_comment
-- ----------------------------
INSERT INTO `blog_comment` VALUES ('1', '测试评论', '2018-01-02 16:50:30', 'chngzhen@outlook.com', '1');

-- ----------------------------
-- Table structure for blog_group
-- ----------------------------
DROP TABLE IF EXISTS `blog_group`;
CREATE TABLE `blog_group` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '组ID',
  `name` varchar(20) DEFAULT NULL COMMENT '分组名称',
  `sort` int(2) DEFAULT NULL COMMENT '排序',
  `parent_id` int(11) DEFAULT NULL COMMENT '父ID',
  `blog_num` int(5) DEFAULT NULL COMMENT '博客数量',
  `is_parent` int(1) DEFAULT NULL COMMENT '是否父节点',
  `level` int(2) DEFAULT NULL COMMENT '层级',
  `descr` varchar(50) DEFAULT NULL COMMENT '描述',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=17 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of blog_group
-- ----------------------------
INSERT INTO `blog_group` VALUES ('1', '根节点', '1', '0', '0', '1', '1', '根节点，无意义');
INSERT INTO `blog_group` VALUES ('2', '后台服务', '1', '1', '2', '1', '2', '');
INSERT INTO `blog_group` VALUES ('3', 'Shiro', '1', '2', '0', '0', '3', '安全框架');
INSERT INTO `blog_group` VALUES ('4', 'Quartz', '2', '2', '3', '0', '3', '作业调度框架');
INSERT INTO `blog_group` VALUES ('5', 'Spring MVC', '3', '2', '2', '0', '3', 'MVC框架');
INSERT INTO `blog_group` VALUES ('6', 'Ehcache', '4', '2', '0', '0', '3', '缓存框架');
INSERT INTO `blog_group` VALUES ('7', 'Druid', '5', '2', '0', '0', '3', '连接池技术');
INSERT INTO `blog_group` VALUES ('8', 'JDBC', '6', '2', '0', '0', '3', '连接技术');
INSERT INTO `blog_group` VALUES ('9', '编程语言', '2', '1', '0', '1', '2', null);
INSERT INTO `blog_group` VALUES ('10', 'Java', '1', '9', '8', '0', '3', null);
INSERT INTO `blog_group` VALUES ('11', '辅助工具', '3', '1', '0', '1', '2', null);
INSERT INTO `blog_group` VALUES ('12', 'Git', '1', '11', '1', '0', '3', null);
INSERT INTO `blog_group` VALUES ('13', 'MyBatis', '7', '2', '0', '0', '3', '持久层框架');
INSERT INTO `blog_group` VALUES ('14', 'Kotlin', '2', '9', '0', '0', '3', null);
INSERT INTO `blog_group` VALUES ('15', '操作系统', '4', '1', '0', '1', '2', null);
INSERT INTO `blog_group` VALUES ('16', 'Linux', '1', '15', '0', '0', '3', null);

-- ----------------------------
-- Table structure for issue
-- ----------------------------
DROP TABLE IF EXISTS `issue`;
CREATE TABLE `issue` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '问题ID',
  `title` varchar(100) DEFAULT NULL COMMENT '问题标题',
  `content` text COMMENT '问题内容',
  `status` int(1) DEFAULT NULL COMMENT '问题状态:1-待解决,2-已解决',
  `user_id` int(11) DEFAULT NULL COMMENT '用户ID',
  `create_time` datetime DEFAULT NULL COMMENT '提问时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=13 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of issue
-- ----------------------------
INSERT INTO `issue` VALUES ('1', '如何解决HTML页面中文乱码', '如题所述，HTML页面解析中文时出现乱码的情况。', '2', '1', '2017-10-16 15:05:44', '2017-10-16 15:05:46');
INSERT INTO `issue` VALUES ('2', '测试标题', '测试问题', '2', '1', '2017-10-17 06:46:55', '2017-10-17 06:46:55');
INSERT INTO `issue` VALUES ('3', '如何在同一台计算机上部署多个Tomcat服务器', '如题，要求是在同一台计算机上部署多个Tomcat服务器', '2', '1', '2017-10-18 08:27:31', '2017-10-18 08:27:31');
INSERT INTO `issue` VALUES ('4', 'CentOS如何安装MySQL', '如题所述，在CentOS系统下安装MySQL', '2', '1', '2017-10-20 04:38:52', '2017-10-20 04:38:52');
INSERT INTO `issue` VALUES ('5', 'DIV标签如何水平垂直居中', '仅限于使用CSS', '2', '1', '2017-10-20 04:52:18', '2017-10-20 04:52:18');
INSERT INTO `issue` VALUES ('6', 'jQuery如何实时监听input的内容变化', '普通的change事件只会在input失去焦点之后，才会判断内容是否发生变化。要求实时监听向input进行输入的动作。', '2', '1', '2017-10-20 04:54:31', '2017-10-20 04:54:31');
INSERT INTO `issue` VALUES ('7', 'jQuery如何合并数组', '在JS代码块中定义两个数组：\n```\nlet array1 = [1, 2, 3];\nlet array2 = [2, 3, 4];\n```\n要求将两个数组合并为一个数组。', '2', '1', '2017-10-20 04:56:17', '2017-10-20 04:56:17');
INSERT INTO `issue` VALUES ('8', 'jQuery如何替换字符串中的字符', '定义一个字符串，要求用空字符替换里面所有的\"$\"字符：\n```\nlet str = \"你$好，j$Query!\";\n```\njQuery的字符串对象拥有一个replace方法用来替换子字符串，但是它只能替换第一个匹配到的子字符串。要求对目标字符串内的所有指定的子字符串进行替换。', '2', '1', '2017-10-20 04:57:56', '2017-10-20 04:57:56');
INSERT INTO `issue` VALUES ('9', '修改Web文件内容，重新部署后页面内容无变化', '利用Tomcat发布Web项目，修改Web项目中的内容后重新发布，页面并没有变化。即使在浏览器端强制刷新也没用', '2', '1', '2017-10-23 02:00:48', '2017-10-23 02:00:48');
INSERT INTO `issue` VALUES ('10', '如何实现点击其他地方隐藏div', '设置一个按钮btn，点击显示一个div。如何监听点击事件，当鼠标点击div以外的地方时，隐藏div？', '2', '1', '2017-10-23 13:44:14', '2017-10-23 13:46:23');
INSERT INTO `issue` VALUES ('11', 'AndeoidStudio无法检测到虚拟机', '虚拟机已经启动了', '2', '1', '2017-11-09 20:45:13', '2017-11-03 01:38:12');
INSERT INTO `issue` VALUES ('12', 'IntelliJ IDEA报错：Diamond types are not supported at language level', 'IntelliJ IDEA ULTIMATE 2017.2对`new java.util.ArrayList<>();`代码报错：\r\n```\r\nDiamond types are not supported at language level \'1.5\'\r\n```', '2', '1', '2017-11-14 12:28:02', '2017-11-14 04:30:51');

-- ----------------------------
-- Table structure for pro_user
-- ----------------------------
DROP TABLE IF EXISTS `pro_user`;
CREATE TABLE `pro_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '记录ID',
  `pro_id` int(11) DEFAULT NULL COMMENT '项目ID',
  `user_id` int(11) DEFAULT NULL COMMENT '用户ID',
  `user_type` int(1) DEFAULT NULL COMMENT '用户类型：1-创建者，2-翻译者，3-检验者',
  `user_state` int(1) DEFAULT NULL COMMENT '用户状态：0-退组；1-申请，2-正式',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of pro_user
-- ----------------------------

-- ----------------------------
-- Table structure for templateInfo
-- ----------------------------
DROP TABLE IF EXISTS `templateInfo`;
CREATE TABLE `templateInfo` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT COMMENT '模板ID',
  `orm` int(1) DEFAULT NULL COMMENT 'ORM框架：1-MyBatis，2-Hibernate',
  `templateInfo` longtext COMMENT '模板内容',
  `engine` int(1) DEFAULT NULL COMMENT '模板引擎：1-FreeMarker',
  `output_file` varchar(255) DEFAULT NULL COMMENT '输出文件',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of templateInfo
-- ----------------------------

-- ----------------------------
-- Table structure for test
-- ----------------------------
DROP TABLE IF EXISTS `test`;
CREATE TABLE `test` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of test
-- ----------------------------
INSERT INTO `test` VALUES ('1', '001');
INSERT INTO `test` VALUES ('2', '001');
INSERT INTO `test` VALUES ('3', '001');
INSERT INTO `test` VALUES ('4', '004');

-- ----------------------------
-- Table structure for translation
-- ----------------------------
DROP TABLE IF EXISTS `translation`;
CREATE TABLE `translation` (
  `id` varchar(64) NOT NULL COMMENT '项目ID：UUID',
  `pro_name` varchar(255) DEFAULT NULL COMMENT '项目名称',
  `pro_desc` varchar(255) DEFAULT NULL COMMENT '项目描述',
  `creator` int(11) DEFAULT NULL COMMENT '项目创建者',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime DEFAULT NULL COMMENT '更新时间',
  `tags` varchar(255) DEFAULT NULL COMMENT '标签',
  `origin_url` varchar(255) DEFAULT NULL COMMENT '源文档地址',
  `read_times` int(8) DEFAULT NULL COMMENT '阅读量',
  `member_num` int(2) DEFAULT NULL COMMENT '成员数量',
  `pro_status` int(1) DEFAULT NULL COMMENT '状态：0-正常，1-待审，2-拒绝',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of translation
-- ----------------------------
INSERT INTO `translation` VALUES ('29792a95-806b-46c3-9218-71ee39cb3d5a', 'Spring Framework中文文档', 'Spring Framework官方说明文档中文翻译', '1', '2018-01-19 13:59:56', '2018-01-19 13:59:56', 'Spring Framework,中文,文档', null, '3', '1', null);
INSERT INTO `translation` VALUES ('6415d31f-beea-4064-aa9c-757f76d27ca2', 'Spring Boot中文文档', 'Spring Boot说明文档中文翻译', '1', '2018-01-23 02:22:36', '2018-01-23 02:22:36', 'Spring Boot,中文,文档', null, '0', '1', null);
INSERT INTO `translation` VALUES ('a6ad4f07-712b-4c2f-8b4b-0c157e2bee95', 'Quartz中文文档', 'Quartz官方说明文档中文翻译', '1', '2018-02-23 00:57:12', '2018-02-23 00:57:12', 'Quartz,定时器,中文,文档', 'http://www.quartz-scheduler.org/documentation/quartz-2.2.x/quick-start.html', '15', '2', null);
INSERT INTO `translation` VALUES ('c4d145ec-02bc-47ff-9543-244539fed90e', 'Nginx中文文档', 'Nginx官方说明文档中文翻译', '1', '2018-01-20 14:16:03', '2018-01-20 14:16:03', 'Nginx,中文,文档', null, '0', '1', null);
INSERT INTO `translation` VALUES ('f4e3b441-dc74-484a-9022-15d4d63a4a1b', 'Linux指令大全中文文档', 'Linux 指令大全', '1', '2018-01-25 07:34:14', '2018-01-25 07:34:14', 'Linux,指令', null, '0', '1', null);

-- ----------------------------
-- Table structure for translation_apply
-- ----------------------------
DROP TABLE IF EXISTS `translation_apply`;
CREATE TABLE `translation_apply` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '记录ID',
  `pro_id` varchar(64) DEFAULT NULL COMMENT '项目ID',
  `user_id` int(11) DEFAULT NULL COMMENT '用户ID',
  `status` int(1) DEFAULT NULL COMMENT '申请状态:2-待审核，3-通过，0-拒绝，1-退组',
  `create_time` datetime DEFAULT NULL COMMENT '申请时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=7 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of translation_apply
-- ----------------------------
INSERT INTO `translation_apply` VALUES ('1', '6415d31f-beea-4064-aa9c-757f76d27ca2', '1', '3', '2018-02-07 09:20:50');
INSERT INTO `translation_apply` VALUES ('2', 'c4d145ec-02bc-47ff-9543-244539fed90e', '1', '3', '2018-02-07 09:21:45');
INSERT INTO `translation_apply` VALUES ('3', '29792a95-806b-46c3-9218-71ee39cb3d5a', '1', '3', '2018-02-07 09:21:54');
INSERT INTO `translation_apply` VALUES ('4', 'f4e3b441-dc74-484a-9022-15d4d63a4a1b', '1', '3', '2018-02-07 09:22:00');
INSERT INTO `translation_apply` VALUES ('5', 'a6ad4f07-712b-4c2f-8b4b-0c157e2bee95', '1', '3', '2018-02-23 00:57:12');
INSERT INTO `translation_apply` VALUES ('6', 'a6ad4f07-712b-4c2f-8b4b-0c157e2bee95', '2', '3', '2018-03-06 00:56:57');

-- ----------------------------
-- Table structure for translation_article
-- ----------------------------
DROP TABLE IF EXISTS `translation_article`;
CREATE TABLE `translation_article` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '译文ID',
  `content` longtext COMMENT '内容',
  `struct_id` int(11) DEFAULT NULL COMMENT '节点ID',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=46 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of translation_article
-- ----------------------------
INSERT INTO `translation_article` VALUES ('1', 'Nginx在不同的操作系统下有不同的安装方式：\n- 在Linux上安装：可以从[nginx.org](http://nginx.org/packages/)下载相应版本的安装包；\n- 在FreeBSD上安装：可以选择通过包或端口系统来安装Nginx。端口系统提供了更强大的灵活性，允许选择更广泛的选项。端口会根据指定的选项编译并安装Nginx；\n- 构建源码：如果需要一些特定的功能，无法从包或端口中获取，Nginx允许编译源码文件。虽然极具灵活性，但对于初学者会显得很复杂。', '32');
INSERT INTO `translation_article` VALUES ('2', '[TOC]\n\n本教程对Nginx做了基本地介绍，并描述了一些Nginx可以做到的简单任务。本教程假设读者已经成功安装Nginx，如果还没有，请参阅[Nginx安装]()译文。本教程描述了如何启动和关闭Nginx、重新加载Nginx的配置，并解释了配置文件的结构，描述如何设置Nginx来发送静态内容、如何将Nginx配置成代理服务器以及如何与FastCGI应用程序连接。\n\nNginx有一个主进程和多个工作进程。主进程的主要工作就是读取和评估配置，然后维护工作进程。工作进程则对请求做实际上的处理。Nginx使用基于事件的驱动模型和依赖操作系统的机制来高效地在工作进程间分配请求。工作进程的数量定义在配置文件中。对于一个给定的配置该数值可能是固定的，也可能自动调整为可用的CPU核心数量。\n\nNginx及其模块的工作方式由配置文件决定。默认该配置文件名称是`nginx.conf`，位于`/usr/local/nginx/conf`、`/etc/nginx`或`/usr/local/etc/nginx`文件夹下。\n\n# 启动、关闭及重新加载配置\n启动Nginx需要运行一个可执行文件。一旦Nginx被启动，就可以通过使用`-s`参数调用可执行文件来控制它。格式如下：\n```\nnginx -s [options]\n```\n`options`的取值如下：\n- `stop` 快速关闭\n- `quit` 优雅关闭\n- `reload` 重新加载配置文件\n- `reopen` 重新打开日志文件\n\n例如，等工作进程处理完当前请求后再关闭Nginx进程，可以执行下面的命令：\n```\nnginx -s quit\n```\n> 原文注：该命令的执行者与启动Nginx的用户应当相同。\n\n在配置文件中所做的修改不会立即被应用，直到给Nginx发送重新加载配置的命令或者Nginx重启。重新加载配置的命令如下：\n```\nnginx -s reload\n```\n主进程一旦收到了重新加载配置的信号，就会检查新配置文件的语法合法性并尝试应用该配置。如果成功了，主进程会开启一个新的工作进程并发送消息给旧的工作进程要求他们关闭；如果失败了，主进程会回滚这些修改并继续使用旧配置工作。收到了关闭命令的工作进程会停止接收新的连接，但会继续处理当前请求直到所有的请求都被处理。之后，旧的工作进程就会退出。\n\n一个信号也可能会在Unix工具的帮助下发送给Nginx的进程，例如`kill`。在这种情况下，信号会直接发送给指定ID的进程。Nginx主进程的进程ID默认被写到`/usr/local/nginx/logs`或`/var/run`目录下的`nginx.pid`文件中。例如，如果主进程ID是1628，发送`QUIT`信号让Nginx优雅地退出：\n```\nkill -s QUIT 1628\n```\n为了获取所有执行中的Nginx进程，可能会用到`ps`工具。\n```\nps -ax|grep nginx\n```\n\n# 配置文件的结构\nNginx由模块组成，通过在配置文件中指定指令来控制这些模块。指令分为简单指令和块指令。简单指令由空格分隔的名称和参数组成，以分号结尾；块指令和简单指令的结构相同，但它不是以分号结尾，而是以花括号包裹的一系列附加说明结尾。如果一个块指令在花括号中拥有其他指令，那么它被称为一个上下文。\n\n独立于任何上下文的配置文件中所存放的指令一般被认为属于主上下文，`events`和`http`指令集在`main`上下文中，`server`在`http`中，而`location`在`server`中。\n\n`#`之后的内容被认为是注释。\n\n# 提供静态文件\n一个重要的Web服务器任务就是提供文件（例如图片、静态HTML页面）。接下来你会实现一个实例：根据请求，文件从不同的本地目录（`/data/www`提供HTML文件和`/data/images`提供图片）被返回。这个实现需要编辑配置文件并在`http`块中设置一个带有两个`location`块的`server`块。\n\n首先，创建`/data/www`目录并添加一个`index.html`文件，里面可以写任何东西；再创建一个`/data/images`目录并添加一个图片。\n\n然后，打开配置文件。默认的配置文件通常已经包含了一些`server`块的实例，大部分都被注释了。现在注释掉所有这些块，重新开始一个新的`server`块：\n```\nhttp {\n    server {\n        \n    }\n}\n```\n一般来说，配置文件可能包含几个`server`块，这些`server`块可以通过它们监听的端口和服务器名称来区分。一旦Nginx决定某个`server`处理请求，它会根据`server`块中定义的`location`指令的参数来测试请求头中指定的URI。\n\n将下面的`location`块添加到`server`块中。\n```\nlocation / {\n    root /data/wwww;\n}\n```\n`location`块中指定的`/`前缀会比较请求中的URI。对于匹配的请求，URI将被添加到`root`指令中指定的路径（即`/data/www`），以形成到本地文件系统上请求文件的路径。如果存在多个匹配的`location`块，Nginx会选择前缀最长的那个。上面的`location`块提供的前缀是最短的，长度为1，所以只有当其他所有的`location`块都匹配失败时，他才会被用到。\n\n接下来，添加第二个`location`块：\n```\nlocation /images/ {\n    root /data;\n}\n```\n它将会匹配以`/images/`开头的请求（`location /`也能匹配这类请求，但是它的前缀更短）。\n\n最终，`server`块的配置如下：\n```\nserver {\n    location / {\n        root /data/www;\n    }\n    \n    location /images/ {\n        root /data;\n    }\n}\n```\n这已经是一个有效的服务器配置了，监听标准的80端口，并可以在本机上通过`http://locahost/`访问。在响应以`/images/`开头的请求时，服务器会从`/data/images`目录中发送文件。例如，响应`http://localhost/images/example.png`的请求时，Nginx会发送`/data/images/example.png`文件。如果该文件不存在，Nginx会响应一个404。而不是以`/images/`开头的请求将都会被映射到`/data/www`目录。例如，响应`http://localhost/some/example.html`时，Nginx会发送`/data/www/some/example.html`文件。\n\n为了应用新的配置，如果Nginx没有启动，则直接启动即可；如果Nginx已经启动了，则可以向Nginx的主进程发送一个`reload`信号：\n```\nnginx -s reload\n```\n> 原文注：如果事情没有按预期发展，可以尝试在`/usr/local/nginx/logs`或`/var/log/nginx`目录下的`access.log`与`error.log`文件中查找原因。\n\n# 设置简单的代理服务器\nNginx另一个常见的用法是作为代理服务器，即一个服务器负责接收请求，然后将其派发给代理的其他服务器，并从它们那里获取响应返回给客户端。\n\n我们将配置一个基础的代理服务器：它为本地目录中的文件提供图片请求，并将所有其他请求发送给代理的服务器。在这个例子中，两个服务器将在一个Nginx实例中定义。\n\n首先，向配置文件中添加多个`server`块来定义被代理的服务器：\n```\nserver {\n    listen 8080;\n    root /data/upl;\n    \n    location / {\n        \n    }\n}\n```\n这是一个简单的服务器，监听了8080端口（之前使用80端口时没有显式指定`listen`指令），并将所有的请求都映射到了本地文件系统的`/data/upl`目录。创建该目录并添加`index.html`文件。注意，`root`指令位于`server`上下文中。当选择用于处理请求的`location`块没有自己的`root`指令时，就会使用这种`root`指令。\n\n接下来，使用上一节中的服务器配置并对其进行修改，使其成为代理服务器配置。在第一个`location`块中放入一个`proxy_pass`指令，该指令的参数包括被代理服务器的协议、名称和端口。\n```\nserver {\n    location / {\n        proxy_pass http://localhost:8080;\n    }\n    \n    location /images/ {\n        root /data;\n    }\n}\n```\n我们将会修改第二个`location`块，目前它只会将`/images/`开头的请求映射到`/data/images`目录。为了使它映射带有典型文件扩展名的图片请求，，可以做如下修改：\n```\nlocation ~ \\.(gif|png|jpg)$ {\n    root /data/images;\n}\n```\n该参数是一个匹配所有以`.gif`、`.jpg`或`.png`结尾的URI的正则表达式。正则表达式应该以`〜`开头。相应的请求将被映射到`/data/images`目录。\n\n当Nginx选择一个`location`块来处理请求时，它首先检查指定了前缀的`location`指令，记住最长前缀的`location`，然后检查正则表达式。如果与正则表达式匹配，Nginx会选择这个`location`；否则，选择一个早先记住的`location`。\n\n代理服务器的最终配置如下：\n```\nserver {\n    location / {\n        proxy_pass http://localhost:8080/;\n    }\n    \n    location ~ \\.(gif|jpg|png) {\n        root /data/images;\n    }\n}\n```\n此服务器将过滤以`.gif`、`.jpg`或`.png`结尾的请求，并将它们映射到`/data/images`目录（通过将URI添加到`root`指令的参数后面），并将所有其他请求传递到上面配置的代理服务器。\n\n像之前描述的那样给Nginx发送一个`reload`信号即可应用新的配置。\n\n# 设置FastCGI代理\nNginx可用于将请求路由到FastCGI服务器，该服务器运行着由各种框架和编程语言（如PHP）构建的应用程序。\n\n使用FastCGI服务器的最基本的Nginx配置包括使用`fastcgi_pass`指令而不是`proxy_pass`指令，以及使用`fastcgi_param`指令来设置传递给FastCGI服务器的参数。假设FastCGI服务器可以在`localhost:9000`上访问。以前面的代理配置为基础，用`fastcgi_pass`指令替换`proxy_pass`指令，并将参数更改为`localhost:9000`。在PHP中，`SCRIPT_FILENAME`参数用于确定脚本名称，`QUERY_STRING`参数用于传递请求参数。由此产生的配置将是：\n```\nserver {\n    location / {\n        fastcgi_pass  localhost:9000;\n        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;\n        fastcgi_param QUERY_STRING    $query_string;\n    }\n    \n    location ~ \\.(gif|jpg|png)$ {\n        root /data/images;\n    }\n}\n```\n这将建立一个服务器，通过FastCGI协议将除静态图像请求之外的所有请求路由到在`localhost:9000`上运行的代理服务器。', '33');
INSERT INTO `translation_article` VALUES ('3', '[TOC]\n\n可以通过信号来控制Nginx。主进程的进程ID默认被写到`/usr/local/nginx/logs/nginx.pid`文件，文件名称可以在配置时更改，或者在`nginx.conf`中使用`pid`指令更改。主进程支持以下信号：\n\n|信号|描述|\n|--|--|\n|TERM,INT|快速关闭|\n|QUIT|优雅关闭|\n|HUP|更改配置、时区变化同步（只针对FreeBSD和Linux）、根据新的配置启动新的工作进程、优雅地关闭旧工作进程|\n|USR1|重新打开日志文件|\n|USR2|升级可执行文件|\n|WINCH|优雅的关闭工作进程|\n\n单个工作进程也可以通过信号被控制。支持的信号如下：\n\n|信号|描述|\n|--|--|\n|TERM,INT|快速关闭|\n|QUIT|优雅关闭|\n|USR1|重新打开日志文件|\n|WINCH|异常的调试终止（需要允许`debug_points`）|\n\n# 更改配置\n让Nginx重新读取配置文件，可以向主进程发送一个`HUP`信号。主进程会先检查语法的合法性，然后尝试应用新的配置（即打开日志文件及新的监听口）。如果该过程失败了，主进程会回滚所做的修改，并继续根据旧的配置提供服务；如果这个过程成功了，主进程会开启一个新的工作进程，并发送消息给旧的工作进程要求他们优雅地结束。旧的工作进程关闭监听口并继续为已收到的客户端请求服务。当这些请求都处理完毕之后，旧的工作进程就是结束。\n\n我们用一个例子来说明。想象一下，Nginx运行在FreeBSD 4.x上，运行以下命令：\n```\nps axw -o pid,ppid,user,%cpu,vsz,wchan,command | egrep \'(nginx|PID)\'\n```\n会产生以下输出：\n```\n  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND\n33126     1 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx\n33127 33126 nobody   0.0  1380 kqread nginx: worker process (nginx)\n33128 33126 nobody   0.0  1364 kqread nginx: worker process (nginx)\n33129 33126 nobody   0.0  1364 kqread nginx: worker process (nginx)\n```\n如果向主进程发送`HUP`信号，输出会变成下面这样：\n```\n  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND\n33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx\n33129 33126 nobody   0.0  1380 kqread nginx: worker process is shutting down (nginx)\n33134 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)\n33135 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)\n33136 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)\n```\nPID为33129的工作进程仍然在工作，一段时间之后才会退出：\n```\n  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND\n33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx\n33134 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)\n33135 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)\n33136 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)\n```\n\n# 轮换日志文件\n为了轮换日志文件，首先需要对他们重命名。之后，应该向主进程发送`USR1`信号。主进程将重新打开所有当前已打开的日志文件，并为其分配一个非特权用户作为所有者，工作进程正运行在这个用户下。成功打开之后，主进程会关闭所有打开的文件并发送消息给工作进程要求他们重新打开文件。工作进程会立即关闭旧的文件并打开新的文件。最后，旧文件几乎立即可用于后期处理，如压缩。\n\n# 在Fly上升级可执行文件\n为了升级服务器的可执行文件，首先新的执行文件应当替换掉旧的文件。之后，向主进程发送`USR2`信号。主进程首先利用进程ID将其文件重命名为具有`.oldbin`后缀的新文件，如`/usr/local/nginx/logs/nginx.pod.oldbin`，然后启动新的执行文件和新的工作进程：\n```\n  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND\n33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx\n33134 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)\n33135 33126 nobody   0.0  1380 kqread nginx: worker process (nginx)\n33136 33126 nobody   0.0  1368 kqread nginx: worker process (nginx)\n36264 33126 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx\n36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)\n36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)\n36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)\n```\n之后，不管新的还是旧的工作进程都会继续接收请求。如果向主进程发送`WINCH`信号，主进程会发送消息给他的工作进程，要求他们优雅地结束并退出：\n```\n  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND\n33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx\n33135 33126 nobody   0.0  1380 kqread nginx: worker process is shutting down (nginx)\n36264 33126 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx\n36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)\n36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)\n36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)\n```\n一段时间后，只有新的工作进程会处理请求：\n```\n  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND\n33126     1 root     0.0  1164 pause  nginx: master process /usr/local/nginx/sbin/nginx\n36264 33126 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx\n36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)\n36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)\n36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)\n```\n应当注意的是，旧的主进程不会关闭他的监听口，如果需要，可以通过管理它来再次启动其工作进程。如果由于某种原因，新的可执行文件无法正常工作，则可以执行以下操作之一：\n- 向旧的主进程发送`HUP`信号。旧的主进程在不重新读取配置的情况下创建一个新的工作进程，然后在新的主进程收到`QUIT`信号后，所有新的进程都会被优雅地结束。\n- 向新的主进程发送`TREM`信号。新的主进程会发送消息给他的工作进程，要求他们立即退出（如果新的进程因为某些原因没有退出，可以向其发送`KILL`信号强制关闭）。当新的主进程退出时，旧的主进程会自动开启新的工作进程。\n\n如果新的主进程退出了，旧的主进程将根据进程ID丢弃文件名中的.oldbin后缀。\n\n如果升级成功，旧的主进程会收到`QUIT`信号，然后新的进程会驻留：\n```\n  PID  PPID USER    %CPU   VSZ WCHAN  COMMAND\n36264     1 root     0.0  1148 pause  nginx: master process /usr/local/nginx/sbin/nginx\n36265 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)\n36266 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)\n36267 36264 nobody   0.0  1364 kqread nginx: worker process (nginx)\n```', '35');
INSERT INTO `translation_article` VALUES ('4', '**本部分说明文档涵盖了所有那些对Spring Framework不可或缺的技术。**\n\n在这些技术中最重要的是Spring Framework的反转控制（Inversion of Control，简称IoC）容器，其次是全面应用的Spring面向切面编程技术（ Aspect-Oriented Programming  ，简称AOP ）和IoC容器的深度处理。Spring Framework拥有自己的AOP框架，这个框架在概念上很容易理解，并且成功地解决了Java企业编程中80％的AOP需求。\n\nSpring提供了对AspectJ（目前在功能上最丰富 ，也是Java企业领域最成熟的AOP实现）的整合。', '2');
INSERT INTO `translation_article` VALUES ('5', '本章节讲解IoC原理的Spring Framework实现。IoC通常被称为依赖注入（Dependency Injection，简称DI），后者指对象通过构造参数、工厂方法参数或属性来定义其依赖的过程，容器在创建Bean后会自动为它注入这些依赖。这个过程从根本上来说是相反的，因此名为控制反转（IoC），bean本身通过使用类的直接构造或诸如Service Locator模式的机制来控制其依赖的实例化或位置。\n\n`org.springframework.beans`包和`org.springframework.context`包是Spring Framework IoC容器的基础。 `BeanFactory`接口提供了一个高级配置机制来管理所有对象的类型。`ApplicationContext`是`BeanFactory`的子接口，增加了以下内容：\n- 与Spring的AOP功能更简单的集成；\n- 消息资源处理（用于国际化）；\n- 事件发布；\n- Web应用程序上下文（WebApplicationContext）等应用程序层特定的上下文，以用于Web应用程序。\n\n简而言之 ，`BeanFactory`提供了配置框架和基本功能，而`ApplicationContext`添加了更多企业级专用的功能。`ApplicationContext`是`BeanFactory`的真超集，在本章节中指代IoC容器。\n\n在Spring中，组成应用程序骨干的的对象和被Spring IoC容器管理的对象被称为Bean。一个Bean就是一个由Spring IoC容器实例化、组装并管理的对象。因此，Bean就是应用程序中的对象，他们之间的依赖关系反映在容器的配置元数据中。', '18');
INSERT INTO `translation_article` VALUES ('6', '`org.springframework.context.ApplicationContext`接口是Spring IoC容器的代码呈现，负责实例化、配置和组装之前提到的Bean。容器通过读取配置元数据获取有关Bean的实例化、配置和组装的说明。配置元数据用XML、JAVA注解或JAVA代码表达对象和对象之间丰富的相互依赖关系。\n\n`ApplicationContext`接口的一些实现可以独立于Spring使用。在单独的应用程序中，通常是创建一个`ClassPathXmlApplicationContext`或`FileSystemXmlApplicationContext`的实例。虽然XML是定义配置元数据的传统方式，但只需要在XML中做一点声明支持的配置，就可以利用JAVA注解或代码定义配置元数据。\n\n在多数应用场景中不需要显式利用用户代码去实例化Spring的IoC容器。例如，在Web应用场景中，只需要在web.xml文件里利用简单的几行XML就可以实现。\n\n下图展示了Spring工作原理的顶层视图。应用程序的类加上配置元数据，可以在`ApplicationContext`被创建和初始化后产生一个完全可配置且可执行的系统或应用程序。\n![image](https://docs.spring.io/spring/docs/5.0.1.RELEASE/spring-framework-reference/images/container-magic.png)\n\n#### 1.2.1 配置元数据\n如上图所示，Spring的IoC容器需要用到配置元数据。这些配置元数据描述了Spring容器该如何去实例化、配置并组装应用程序中的对象。 \n\n传统上，配置元数据以简单直观的XML格式提供。本章的大部分内容都是用这种格式来传达Spring IoC容器的关键概念和特性。 \n\n> 原文注：基于XML的元数据不是唯一选择。Spring IoC容器本身与配置元数据实际写入的格式完全解耦，当下更流行的是基于JAVA的配置。 \n\nSpring的配置至少包含一个（通常是多个）Bean定义。基于XML的配置通过配置顶层元素`<beans/>`中的`<bean/>`元素来展示这些Bean；基于JAVA的配置则通常在一个被`@Configuration`注解的类中利用`@Bean`注解方法。 \n\n这些对应实际对象的Bean定义组成了应用程序，通常用来定义服务层（Service Layer）对象、数据访问对象（Data Access Object，即DAO）、诸如Struts里`Action`实例的表现对象、诸如Hibernate中`SessionFactories`的基础对象、JMS的`Queues`及其他。 通常不会在容器中配置细粒度的域（Domain）对象，因为创建和加载Domain对象通常是DAO和业务逻辑的责任。 但是，可以使用Spring与AspectJ的集成来配置在IoC容器控制之外创建的对象。\n\n以下示例显示了基于XML的配置元数据的基本结构：\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean id=\"...\" class=\"...\">\n        <!-- collaborators and configuration for this bean go here -->\n    </bean>\n    \n    <bean id=\"...\" class=\"...\">\n        <!-- collaborators and configuration for this bean go here -->\n    </bean>\n    \n    <!-- more bean definitions go here -->\n</beans>\n```\n`id`属性是字符串，用来标识单个Bean定义；`class`属性利用完全限定的类名定义了Bean的类型。\n\n#### 1.2.2 实例化容器\n实例化一个Spring IoC容器很简单。传给`ApplicationContext`构造方法的路径实际上是资源字符串，容器根据它从各种外部资源（例如本地文件系统，Java CLASSPATH等等）加载配置元数据。\n```\nApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\");\n```\n以下示例展示了服务层对象的配置文件（services.xml）：\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <!-- services -->\n    \n    <bean id=\"petStore\" class=\"org.springframework.samples.jpetstore.services.PetStoreServiceImpl\">\n        <property name=\"accountDao\" ref=\"accountDao\"/>\n        <property name=\"itemDao\" ref=\"itemDao\"/>\n        <!-- additional collaborators and configuration for this bean go here -->\n    </bean>\n    \n    <!-- more bean definitions for services go here -->\n</beans>\n```\n以下示例展示了数据访问对象的配置文件（daos.xml）：\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<beans xmlns=\"http://www.springframework.org/schema/beans\"\n    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n    xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n        http://www.springframework.org/schema/beans/spring-beans.xsd\">\n\n    <bean id=\"accountDao\" class=\"org.springframework.samples.jpetstore.dao.jpa.JpaAccountDao\">\n        <!-- additional collaborators and configuration for this bean go here -->\n    </bean>\n    \n    <bean id=\"itemDao\" class=\"org.springframework.samples.jpetstore.dao.jpa.JpaItemDao\">\n        <!-- additional collaborators and configuration for this bean go here -->\n    </bean>\n    \n    <!-- more bean definitions for data access objects go here -->\n</beans>\n```\n在前面的例子中，服务层由`PetStoreServiceImpl`类以及`JpaAccountDao`、`JpaItemDao`类型的两个数据访问对象（基于JPA对象/关系映射标准）组成。`<property/>`的元素`name`属性指JavaBean属性的名称，`ref`属性指另一个Bean定义的名称。`id`和`ref`元素之间的这种联系表示了协作对象之间的依赖关系。\n\n##### 构建基于XML的配置元数据\n让Bean定义跨越多个XML文件是很有用的。通常，每个单独的XML配置文件都代表了架构中的逻辑层或模块。\n\n可以使用应用程序上下文构造方法从所有这些XML片段中加载Bean定义（如前一节所示，这个构造方法有多个资源位置），或者使用一个或多个`<import/>`元素从另一个或多个文件加载Bean定义。例如：\n```\n<beans>\n    <import resource=\"services.xml\"/>\n    <import resource=\"resources/messageSource.xml\"/>\n    <import resource=\"/resources/themeSource.xml\"/>\n    \n    <bean id=\"bean1\" class=\"...\"/>\n    <bean id=\"bean2\" class=\"...\"/>\n</beans>\n```\n在上面的例子中，从三个外部文件中加载Bean定义：`services.xml`，`messageSource.xml`和`themeSource.xml`。所有的位置路径都是相对于导入的定义文件而言的，所以`services.xml`必须和导入的文件位于相同的目录或类路径位置，而`messageSource.xml`和`themeSource.xml`必须位于导入文件位置之下的`resources`位置。正如你所看到的，一个前导的斜线被忽略，但是鉴于这些路径是相对的，最好不要使用斜线。正在导入的文件的内容（包括顶级`<beans/>`元素）必须是遵循Spring架构的有效XML Bean定义。\n\nimport指令是Bean名称空间本身提供的一个功能。除了普通的Bean定义之外的其他配置特征可以在由Spring提供的XML命名空间的选择中获得，例如，“context”和“util”命名空间。\n\n##### Groovy Bean定义DSL\n不作翻译。\n\n#### 1.2.3 使用容器\n`ApplicationContext`是高级工厂的接口，能够维护不同的Bean及其依赖关系的注册表。使用方法`T getBean（String name，Class <T> requiredType）`可以检索Bean的实例。\n\n`ApplicationContext`能够读取Bean定义并访问它们，如下所示：\n```\n// create and configure beans\nApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\");\n\n// retrieve configured instance\nPetStoreService service = context.getBean(\"petStore\", PetStoreService.class);\n\n// use configured instance\nList<String> userList = service.getUsernameList();\n```\n使用Groovy配置，使用方式和上面相似，只是上下文实现类不同：\n```\nApplicationContext context = new GenericGroovyApplicationContext(\"services.groovy\", \"daos.groovy\");\n```\n最灵活的变体是结合了阅读器委托（如`XmlBeanDefinitionReader`）的`GenericApplicationContext`：\n```\nGenericApplicationContext context = new GenericApplicationContext();\nnew XmlBeanDefinitionReader(context).loadBeanDefinitions(\"services.xml\", \"daos.xml\");\n   context.refresh();\n```\n或者读取Groovy文件的`GroovyBeanDefinitionReader`：\n```\nGenericApplicationContext context = new GenericApplicationContext();\nnew GroovyBeanDefinitionReader(context).loadBeanDefinitions(\"services.groovy\", \"daos.groovy\");\n   context.refresh();\n```\n这样的阅读器委托可以在相同的`ApplicationContext`上混合和匹配，如果需要，可以从不同的配置源读取Bean定义。\n\n然后可以使用`getBean`来检索Bean的实例。`ApplicationContext`接口还有其他一些检索Bean的方法，但理想情况下应用程序代码不应该使用它们。事实上，应用程序代码根本就不应该调用`getBean()`方法，因此完全不依赖于Spring API。例如，Spring与Web框架的集成为各种Web框架组件（如控制器和JSF托管的Bean）提供了依赖注入，允许通过元数据（例如自动装配注释）来声明对特定Bean的依赖关系。', '19');
INSERT INTO `translation_article` VALUES ('7', 'Spring IoC容器管理一个或多个bean。这些bean是使用提供给容器的配置元数据创建的，例如以XML`<bean/>`定义的形式。\n\n在容器中，这些Bean定义表示为`BeanDefinition`对象，其中包含以下元数据（以及其他信息）：\n- 包限定的类名：通常是被定义的Bean的实际实现类；\n- Bean行为配置元素：它表示Bean在容器中的行为（范围，生命周期回调等等）；\n- 引用其他Bean来协作完成其工作：这些引用也被称为协作者或依赖关系；\n- 在新创建的对象中设置的其他配置设置：例如，在管理连接池的Bean中使用的连接数，或池的大小限制。\n\n这些元数据转化为一组构成每个Bean定义的属性。\n\n除了Bean定义之外，`ApplicationContext`的实现还允许注册在容器外创建的现有对象。这是通过`getBeanFactory()`方法访问`ApplicationContext`的`BeanFactory`来完成的，该方法返回`BeanFactory`的实现`DefaultListableBeanFactory`。`DefaultListableBeanFactory`通过方法`registerSingleton(..)`和`registerBeanDefinition(..)`来支持这种注册。但是，典型的应用程序只能通过元数据Bean定义来定义Bean。\n> 原文注：Bean元数据和手动提供的单例实例需要尽可能早地注册，以便容器在自动装配和其他内省步骤中正确推理它们。虽然重写现有的元数据和现有的单例实例在一定程度上得到了支持，但是在运行时注册新的Bean（与实时访问工厂同时）并没有得到官方的支持，并且可能导致bean容器中的并发访问异常或不一致的状态。\n\n#### 1.3.1 命名Bean\n每个bean都有一个或多个标识符。这些标识符在托管bean的容器中必须是唯一的。一个bean通常只有一个标识符，但是如果它需要多个标识符，额外的可以被认为是别名。\n\n在基于XML的配置元数据中，使用`id`和`name`属性来指定bean标识符。`id`属性允许指定一个id，通常是字母数字（\'myBean\'，\'fooService\'等），但也可能包含特殊字符。如果想向bean引入其他别名，也可以在`name`属性中指定它们，用逗号（，），分号（;）或空格分隔。作为一个历史记录，在Spring 3.1以前的版本中，`id`属性被定义为一个`xsd：ID`类型，它限制了可能的字符。从3.1开始，它被定义为一个`xsd：string`类型。请注意，尽管不再由XML解析器执行，bean的`id`唯一性仍由容器强制执行。\n\n不是必须要求为bean提供名称或标识。如果没有显式提供名称或标识，则容器为该bean生成一个唯一的名称。但是，如果要通过名称引用该bean（例如通过使用`ref`元素或`Service Locator`样式查找），必须提供一个名称。不提供名称的动机与使用内部bean和自动装配协作者有关。\n> 原文注：通过类路径中的组件扫描，Spring为未命名的组件生成bean名称，遵循以上规则：本质上，采用简单的类名称并将其初始字符变为小写。但是，在不常见的特殊情况下，如果有多个字符，并且第一个字符和第二个字符都是大写字母，则会保留原始的外壳。这些和java.beans.Introspector.decapitalize（Spring在这里使用的）定义的规则相同。\n\n##### 为外部Bean定义取别名\n在bean定义中，可以通过`id`属性指定一个名称和`name`属性指定任意数量的名称来为bean提供多个名称。这些名称可以等同于同一个bean的别名，并且在某些情况下非常有用，例如允许应用程序中的每个组件通过使用特定于该组件本身的bean名称来引用公共依赖项。\n\n但是，在bean定义中指定的所有别名并不总是足够的。有时候需要为其他地方定义的bean引入一个别名。在大型系统中，每个子系统分开配置的情况很常见，每个子系统都有自己的一组对象定义。在基于XML的配置元数据中，可以使用`<alias/>`元素来完成此操作。\n```\n<alias name=\"fromName\" alias=\"toName\"/>\n```\n在这种情况下，同名容器中名为`fromName`的bean也可以在使用这个别名定义之后被称为`toName`。\n\n例如，子系统A的配置元数据可以通过名称`subsystemA-dataSource`来引用数据源。子系统B的配置元数据可以通过名称`subsystemB-dataSource`引用数据源。在编写使用这两个子系统的主应用程序时，主应用程序通过名称`myApp-dataSource`引用数据源。要使所有三个名称都与您添加到MyApp配置元数据中的同一个对象相关联，请使用以下别名定义：\n```\n<alias name=\"subsystemA-dataSource\" alias=\"subsystemB-dataSource\"/>\n<alias name=\"subsystemA-dataSource\" alias=\"myApp-dataSource\" />\n```\n现在，每个组件和主应用程序都可以通过唯一的名称引用数据源，并保证不与其他任何定义冲突（有效地创建名称空间），但它们引用同一个bean。\n\n#### 1.3.2 实例化Bean\n一个bean定义本质上是一个创建对象的配方。当容器被询问时，该容器查看命名bean的配方，并使用由该bean定义封装的配置元数据来创建（或获取）实际的对象。\n\n如果使用基于XML的配置元数据，则可以在`<bean/>`元素的`class`属性中指定要实例化的对象的类型（或类）。这个`class`属性在内部是一个`BeanDefinition`实例的`Class`属性，通常是强制的。（有关例外情况，请参阅使用实例工厂方法和Bean定义继承进行实例化。）可以通过以下两种方式之一使用`Class`属性：\n- 通常，在容器本身通过反射调用其构造函数直接创建bean的情况下，指定要构造的bean类，这与使用new运算符的Java代码有些相同。\n- 指定包含被用来创建对象的静态工厂方法的实际类。容器调用类的静态工厂方法来创建该bean的情况较少，从调用静态工厂方法返回的对象类型可以是完全相同的类或另一个类。\n\n##### 利用构造方法实例化\n当通过构造方法创建一个bean时，所有的普通类都可以被Spring使用并兼容。也就是说，正在开发的类不需要实现任何特定的接口或以特定的方式编码，只需指定bean类就足够了。但是，根据您用于特定bean的IoC类型，您可能需要一个默认（空）构造函数。\n\nSpring IoC容器几乎可以管理任何类，它不限于管理真正的JavaBeans。大多数Spring用户更喜欢实际的JavaBeans，它只有一个默认的（无参数）构造函数和合适的setter和getter。你也可以在你的容器中有更多异国情调的非bean风格的类。例如，如果需要使用绝对不符合JavaBean规范的传统连接池，Spring也可以管理它。\n\n使用基于XML的配置元数据，您可以指定您的bean类如下：\n```\n<bean id=\"exampleBean\" class=\"examples.ExampleBean\"/>\n\n<bean name=\"anotherExample\" class=\"examples.ExampleBeanTwo\"/>\n```\n\n##### 使用静态工厂方法实例化\n在定义使用静态工厂方法创建的bean时，可以使用`class`属性来指定包含静态工厂方法的类，使用`factory-method`属性指定工厂方法本身的名称。这个方法必须可以调用（使用后面描述的可选参数）并返回一个活动对象，这个活动对象随后被视为是通过构造函数创建的。这种bean定义的一个用途是在传统代码中调用静态工厂。\n\n下面的bean定义指定了通过调用工厂方法创建的bean。该定义没有指定返回对象的类型（类），而只指定了包含工厂方法的类。在这个例子中，`createInstance()`方法必须是一个静态方法。\n```\n<bean id=\"clientService\"\n    class=\"examples.ClientService\"\n    factory-method=\"createInstance\"/>\n```\n```\npublic class ClientService {\n    private static ClientService clientService = new ClientService();\n    private ClientService() {}\n    \n    public static ClientService createInstance() {\n        return clientService;\n    }\n}\n```\n\n##### 使用实例工厂方法实例化\n与通过静态工厂方法实例化类似，使用实例工厂方法的实例化过程从容器中调用现有bean的非静态方法来创建新的bean。要使用这种机制，请将`class`属性留空，并在`factory-bean`属性中指定当前（或父/祖代）容器中的bean的名称，该容器包含要创建该对象的实例方法。使用`factory-method`属性设置工厂方法本身的名称。\n```\n<!-- the factory bean, which contains a method called createInstance() -->\n<bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\">\n    <!-- inject any dependencies required by this locator bean -->\n</bean>\n\n<!-- the bean to be created via the factory bean -->\n<bean id=\"clientService\"\n    factory-bean=\"serviceLocator\"\n    factory-method=\"createClientServiceInstance\"/>\n```\n```\npublic class DefaultServiceLocator {\n\n    private static ClientService clientService = new ClientServiceImpl();\n    \n    public ClientService createClientServiceInstance() {\n        return clientService;\n    }\n}\n```\n一个工厂类也可以拥有多个工厂方法，如下所示：\n```\n<bean id=\"serviceLocator\" class=\"examples.DefaultServiceLocator\">\n    <!-- inject any dependencies required by this locator bean -->\n</bean>\n\n<bean id=\"clientService\"\n    factory-bean=\"serviceLocator\"\n    factory-method=\"createClientServiceInstance\"/>\n\n<bean id=\"accountService\"\n    factory-bean=\"serviceLocator\"\n    factory-method=\"createAccountServiceInstance\"/>\n```\n```\npublic class DefaultServiceLocator {\n\n    private static ClientService clientService = new ClientServiceImpl();\n    \n    private static AccountService accountService = new AccountServiceImpl();\n    \n    public ClientService createClientServiceInstance() {\n        return clientService;\n    }\n    \n    public AccountService createAccountServiceInstance() {\n        return accountService;\n    }\n}\n```\n这种方法表明，工厂bean本身可以通过依赖注入（DI）进行管理和配置。\n> 原文注：在Spring文档中，工厂bean指的是在Spring容器中配置的bean，它将通过实例或静态工厂方法创建对象。相比之下，FactoryBean（注意大写字母）是指特定于Spring的FactoryBean。', '20');
INSERT INTO `translation_article` VALUES ('8', '**本部分说明文档涉及数据访问以及数据访问层与业务层/服务层之间的交互。**\n\n详细地介绍Spring对事务管理的全面支持之后，接下来会深入介绍Spring Framework集成的各种数据访问框架和技术。', '4');
INSERT INTO `translation_article` VALUES ('9', '选择Spring Framework的主要理由之一就是其对事务的全面支持。Spring Framework为事务管理提供了统一的抽象层，从而带来以下好处：\n- 跨越不同事务API（如JTA、JPA、JDBC、Hibernate）的统一编程模型\n- 支持声明式事务管理\n- 相较于复杂的事务API（如JTA），Spring为编程式事务管理提供了更简单的API\n- 与Spring数据访问抽象层的完美集成\n\n以下部分描述了Spring Framework的事务增值和技术（本章还会讨论最佳实践、应用程序服务器集成以及常见问题的解决方案）：\n- **Spring Framework事务支持模型的优势** 描述了为什么选择使用Spring Framework的事务抽象层而不是EJB容器管理的事务（EJB Container-Managed Transactions，即CMT）或者选择利用专用API（如Hibernate）来驱动本地事务；\n- **理解Spring Framework的事务抽象层** 概述了（事务抽象层的）核心类以及描述了如何配置并从各种资源中获取<code>DataSource</code>实例；\n- **资源与事务同步** 描述了应用程序代码如何确保资源被正确地创建、复用及清除；\n- **声明式事务管理** 描述了对声明式事务管理的支持；\n- **编程式事务管理** 描述了对编程式（即显式编码）事务管理的支持；\n- **事务绑定事件** 描述了如何在事务中使用应用程序的事件。', '28');
INSERT INTO `translation_article` VALUES ('10', '### 2.1.介绍\nSpring对数据访问对象（Data Access Object，简称DAO）的支持是为了用一个统一的方式简化诸如JDBC、Hibernate或JPA等数据访问技术的使用。这样，上述持久化技术之间的相互切换会变得更简单，而且编码时不用考虑捕获每种技术特有的异常。', '37');
INSERT INTO `translation_article` VALUES ('11', '### 2.2.一致的异常层次\nSpring能够将`SQLException`这样技术特有的异常转化到自身以`DataAccessException`为根异常的异常类层次。这里面的异常都包装了原始异常，所以对于任何可能会造成错误的信息，Spring都能确保不会丢失。\n\n不仅是JDBC异常，Spring还可以包装Hibernate特有的异常，并将它们转化为一组受到关注的运行时异常（JPA异常同样如此）。这样就只需要在合适的层上处理大多数不可恢复的持久化异常，而在DAO中无须写`catch-throw`块和声明会抛出的异常（当然你仍然可以在任何需要的地方捕获并处理这些异常）。如上所述，JDBC异常（包括数据库特有的方言）也会被转化到对应的层次，这意味在统一编程模型中可以利用JDBC执行某些操作。\n\n针对Spring用来支持各种ORM框架的模板类，上述内容同样适用。如果使用了基于拦截器的类，那么应用程序必须关心`HibernateExceptions`和`PersistenceExceptions`自身的处理，通常倾向于分别将它们委派给`SessionFactoryUtils`的`convertHibernateAccessException(..)`方法和`convertJpaAccessException()`方法。这些方法会对异常进行转化，使之能够兼容`org.springframework.dao`异常层次中提供的异常。由于`PersistenceExceptions`是未检查的，它们可以简单地被抛出，但在异常方面牺牲了通用的DAO抽象。\n\nSpring提供的异常层次如下（请注意，下图展示的类层次只是整个`DataAccessException`层次的一个子集）。\n![](https://docs.spring.io/spring/docs/5.0.1.RELEASE/spring-framework-reference/images/DataAccessException.png)', '38');
INSERT INTO `translation_article` VALUES ('12', '### 2.3.使用注解盘配置DAO和Repository\n确保DAO和Repository提供异常转化的最好方法是使用`@Repository`注解。另外，无需为它们提供XML配置实体，Spring会利用对组件扫描的支持自动寻找并配置这些DAO和Repository。\n```\n@Repository\npublic class SomeMovieFinder implements MovieFinder {\n	// ...\n}\n```\n任何DAO或Repository的实现基本都会访问一个持久化资源，这取决于使用了哪种持久化技术。例如，基于JDBC的Repository会访问一个JDBC`DataSource`，基于JPA的Repository会访问一个`EntityManager`。而访问这些资源最简单的方式就是使用`@Autowired`、`@Inject`、`@Resource`或`@PersistenceContext`注解依赖注入该资源。以下是一个JPA Repository的例子：\n```\n@Repository\npublic class JpaMovieFinder implements MovieFinder {\n\n	@PersistenceContext\n	private EntityManager entityManager;\n\n	// ...\n\n}\n```\n如果你使用的是传统的Hibernate API，你可以注入SessionFactory：\n```\n@Repository\npublic class HibernateMovieFinder implements MovieFinder {\n\n	private SessionFactory sessionFactory;\n\n	@Autowired\n	public void setSessionFactory(SessionFactory sessionFactory) {\n	this.sessionFactory = sessionFactory;\n	}\n\n	// ...\n\n}\n```\n最后我们将展示典型的JDBC支持。你将会把`DataSource`注入到一个初始化方法中，在该方法里你会利用该`DataSource`创建一个`JdbcTemplate`实例，或者其他像`SimpleJdbcCall`这样的数据访问支持类。\n```\n@Repository\npublic class JdbcMovieFinder implements MovieFinder {\n\n	private JdbcTemplate jdbcTemplate;\n\n	@Autowired\n	public void init(DataSource dataSource) {\n	this.jdbcTemplate = new JdbcTemplate(dataSource);\n	}\n\n	// ...\n\n}\n```\n> 原文注：关于如何利用这些注解配置应用程序上下文的详情，请参阅对各个持久化技术的专门介绍。', '39');
INSERT INTO `translation_article` VALUES ('13', '# Part2 开始\n如果你是初次接触Spring Boot或者常说的“Spring”，那么本部分内容就是为你准备的。这里我们会回答基本的“是什么”、“怎么使用”及“为什么使用”的问题，并通过安装说明向你介绍Spring Boot，然后我们会构建第一个Spring Boot应用程序，并讨论一些我们会接触到的核心概念。', '52');
INSERT INTO `translation_article` VALUES ('14', '## 8.Spring Boot介绍\nSpring Bott简化了基于Spring的独立生产级应用程序的创建过程。我们会根据对Spring平台与第三方库的理解帮助你规避大部分麻烦。大部分的Spring Boot应用程序只需要很少的Spring配置。\n\n利用Spring Boot，你可以创建直接通过`java -jar`或war包部署启动的JAVA应用程序。我们还提供了一个运行“Spring脚本”的命令行工具。\n\n我们主要的目标是：\n- 为所有Spring开发提供一个更快、更广泛的入门体验。\n- 开箱即用，但随着需求开始偏离默认设置也能够快速退出。\n- 提供一系列对于大型项目来说很常见的非功能性功能（例如嵌入式服务器、安全性、指标、运行状况检查、外部配置）。\n- 绝对不会生成代码，也不需要XML配置。', '53');
INSERT INTO `translation_article` VALUES ('15', '## 9.系统需求\n默认情况下，1.5.9.RELEASE版本的Spring Boot需要Java 7和4.3.13.RELEASE及以上版本的Spring Framework。当然，你也可以通过配置使用Java 6，详情参见[84.11 如何使用Java 6]()。此外，Spring Boot还为Maven（3.2）和Gradle 2（2.9或更高版本）和3提供了显式构建支持。\n\n> 原文注：虽然你可以在Spring Boot中使用Java 6或7，但如果可能，我们推荐使用Java 8。\n\n### 9.1 Servlet容器\n开箱的情况下支持以下嵌入的Servlet容器：\n\n|名称|Servlet版本|Java版本|\n|--|--|--|\n|Tomcat 8|3.1|Java 7+|\n|Tomcat 7|3.0|Java 6+|\n|Jetty 9.3|3.1|Java 8+|\n|Jetty 9.2|3.1|Java 7+|\n|Jetty 8|3.0|Java 6+|\n|Undertow 1.3|3.1|Java 7+|\n\n你也可以在其他Servlet 3.0+兼容的容器中部署Spring Boot应用程序。', '54');
INSERT INTO `translation_article` VALUES ('16', '## 19.运行应用程序\n将应用程序打包成JAR以及使用嵌入式HTTP服务器的一个最大优势就是你可以像其他程序一样直接运行你的应用程序。调试也很简单，你不需要任何特殊的IDE插件或扩展。\n\n> 原文注：本部分只涵盖了基于JAR包的打包方式。如果你选择将你的应用程序打包成WAR包，那你应该参考你的服务器文档或IDE文档。\n\n### 19.1 在IDE上运行\n你可以在你的IDE上像其他简单的JAVA程序那样运行Spring Boot应用程序，但首先你得先导入你的项目。导入的步骤随你的IDE和构建工具而异。大多数的IDE都能够直接导入Maven项目，例如，Eclipse用户可以选择从`File`菜单下的`Import...`->`Existing Maven Projects`导入项目。\n\n如果你不能直接将你的项目导入到IDE，你可以使用构建插件生成IDE元数据。Maven为Eclipse和IDEA都提供了插件，Gradle为各种IDE都提供了插件。\n\n> 原文注：如果你偶然运行了应用程序两次，你将会看到“Port already in use”的错误。STS使用者可以利用`Relaunch`按钮确保其他已存在的实例被关闭。\n\n### 19.2 运行JAR包\n如果你使用Spring Boot Maven或Gradle插件创建了一个可执行的JAR包，你可以使用`java -jar`命令运行你的应用程序。例如：\n```\n$ java -jar target/myproject-0.0.1-SNAPSHOT.jar\n```\n也可以开启远程调试支持来运行打包后的应用程序。这种方式允许你将调试器附加到打包后的应用程序中：\n```\n$ java -Xdebug -Xrunjdwp:server=y,transport=dt_socket,address=8000,suspend=n \\\n       -jar target/myproject-0.0.1-SNAPSHOT.jar\n```\n\n### 19.3 使用Maven插件\nSpring Boot Maven有一个可用来快速编译并运行应用程序的`run`目标。应用程序以分解形式运行，就像在IDE中一样。\n```\n$ mvn spring-boot:run\n```\n你可能希望应用一些有用的操作系统环境变量：\n```\n$ export MAVEN_OPTS=-Xmx1024m -XX:MaxPermSize=128M\n```\n\n### 19.4 使用Gradle插件\nSpring Boot Gradle插件也包含一个`bootRun`任务，可以以分解形式运行应用程序。当导入`spring-boot-gradle-plugin`时就会添加`bootRun`任务：\n```\n$ gradle bootRun\n```\n你可能希望应用一些有用的操作系统环境变量：\n```\n$ export JAVA_OPTS=-Xmx1024m -XX:MaxPermSize=128M\n```\n\n### 19.5 热插拨\n由于Spring Boot应用程序只是普通的Java应用程序，所以JVM热插拔应该是开箱即用的。 JVM热插拨在某种程度上受限于它可以替换的字节码，为了获得更完整的解决方案，可以使用JRebel或Spring Loaded项目。 spring-boot-devtools模块也包括对快速重启应用程序的支持。', '55');
INSERT INTO `translation_article` VALUES ('17', '## 10.安装Spring Boot\n可以通过经典的Java开发工具或命令行安装Spring Boot，但不管哪种方法都需要Java 6或更高的版本。在安装Spring Boot之前你应当先检查以下自己的Java版本：\n```\njava -version\n```\n如果你是初次接触Java开发，或者只是想体验一下Spring Boot，那么你需要先尝试[Spring Boot CLI]()；否则请阅读经典安装说明。\n\n> 原文注：虽然Spring Boot兼容Java 6，但如果有可能，你应当尽量选择最近的版本。\n\n### 10.1 针对Java开发者的安装介绍\n你可以像使用标准Java库一样使用Spring Boot，只需要将合适的`spring-boot-*.jar`放到类路径下。Spring Boot不需要任何特别的工具集成，所以你可以使用任何IDE或者文本编辑器；Spring Boot应用程序也没有任何特别之处，你可以像其他Java程序那样运行和测试。\n\n#### 10.1.1 利用Maven安装\nSpring Boot兼容Apache Maven 3.2及以上的版本。如果你还没有安装Maven，可以参阅[maven.apache.org](https://maven.apache.org)。\n\n> 原文注：一些操作系统可以通过包管理器安装Maven。如果你是OSX HomeBrew的用户，可以尝试`brew install maven`，Ubuntu用户可以尝试`sudo apt-get install maven`。\n\nSpring Boot的依赖都是以`org.springframework.boot`作为`groupId`。通常，你的POM文件都会继承自`spring-boot-starter-parent`项目，然后声明依赖一个或多个“启动器”。Spring Boot还提供了一个可选的Maven插件来创建一个可执行的JAR文件。\n\n下面是常见的`pom.xml`文件：\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n	xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n	<modelVersion>4.0.0</modelVersion>\n\n	<groupId>com.example</groupId>\n	<artifactId>myproject</artifactId>\n	<version>0.0.1-SNAPSHOT</version>\n\n	<!-- Inherit defaults from Spring Boot -->\n	<parent>\n		<groupId>org.springframework.boot</groupId>\n		<artifactId>spring-boot-starter-parent</artifactId>\n		<version>1.5.7.RELEASE</version>\n	</parent>\n\n	<!-- Add typical dependencies for a web application -->\n	<dependencies>\n		<dependency>\n			<groupId>org.springframework.boot</groupId>\n			<artifactId>spring-boot-starter-web</artifactId>\n		</dependency>\n	</dependencies>\n\n	<!-- Package as an executable jar -->\n	<build>\n		<plugins>\n			<plugin>\n				<groupId>org.springframework.boot</groupId>\n				<artifactId>spring-boot-maven-plugin</artifactId>\n			</plugin>\n		</plugins>\n	</build>\n\n</project>\n```\n> 原文注：`spring-boot-starter-parent`是一个使用Spring Boot的好方法，但也不是在任何情况下都合适，因为有时候你可能需要继承另一个父POM，或者你仅仅是不喜欢这种方式。参阅[13.2.2 不借助父POM使用Spring Boot]()，这里面提供了一个利用`import`范围的可选方案。\n\n#### 10.1.2 利用Gradle安装\nSpring Boot兼容Gradle 2（2.9及之后的版本）和Gradle 3。如果你还没有安装Gradle，可以参阅[www.gradle.org](https://www.gradle.org)。\n\n可以用`group`为`org.springframework.boot`来声明Spring Boot的依赖。通常你的项目需要声明一个或多个“启动器”的依赖。Spring Boot提供了一个有用的Gradle插件来简化依赖声明及创建可执行JAR文件。\n\n> 原文注：当你需要利用Gradle构建项目时，Gradle包装器提供了一个很好的获取Gradle的方式。它是一个与代码一起提交，用来引导项目构建过程的小脚本和库。\n\n以下是一个典型的`build.gradle`文件：\n```\nplugins {\n	id \'org.springframework.boot\' version \'1.5.7.RELEASE\'\n	id \'java\'\n}\n\n\njar {\n	baseName = \'myproject\'\n	version =  \'0.0.1-SNAPSHOT\'\n}\n\nrepositories {\n	jcenter()\n}\n\ndependencies {\n	compile(\"org.springframework.boot:spring-boot-starter-web\")\n	testCompile(\"org.springframework.boot:spring-boot-starter-test\")\n}\n```\n\n### 10.2 安装Spring Boot CLI\nSpring Boot CLI是一个命令行工具，你可以用它结合Spring来快速创建原型。它允许你运行Groovy脚本，这意味着你有一个熟悉的类Java语法，且没有太多的样板代码。\n\n你不需要利用CLI来使用Spring Boot，但它绝对是实现Spring应用程序实现最快速度的最快捷方式。\n\n#### 10.2.1 手动安装\n你可以从Spring软件存储库下载Spring CLI发行版：\n- [spring-boot-cli-1.5.7.RELEASE-bin.zip](https://repo.spring.io/release/org/springframework/boot/spring-boot-cli/1.5.7.RELEASE/spring-boot-cli-1.5.7.RELEASE-bin.zip)\n- [spring-boot-cli-1.5.7.RELEASE-bin.tar.gz](https://repo.spring.io/release/org/springframework/boot/spring-boot-cli/1.5.7.RELEASE/spring-boot-cli-1.5.7.RELEASE-bin.tar.gz)\n\n最新的[Snapshot发行版](https://repo.spring.io/snapshot/org/springframework/boot/spring-boot-cli/)也是可用的。\n\n下载之后，请按照解压缩归档中的INSTALL.txt说明进行操作。总结：在`.zip`文件的`bin/`目录下有一个Spring脚本（适用于Windows的`spring.bat`），或者可以利用`java -jar`运行`.jar`文件（该脚本可以帮助你确定类路径设置是否正确）。\n\n#### 10.2.2 利用SDKMAN!安装\nSDKMAN!（The Software Development Kit Manager）可以用来管理各种二进制SDK的多个版本，包括Groovy和Spring Boot CLI。从[sdkman.io](https://sdkman.io)获取SDKMAN!然后安装Spring Boot：\n```\n$ sdk install springboot\n$ spring --version\nSpring Boot v1.5.7.RELEASE\n```\n如果你正在开发CLI的功能并希望轻松访问刚刚构建的版本，请按照这些额外的说明进行操作：\n```\n$ sdk install springboot dev /path/to/spring-boot/spring-boot-cli/target/spring-boot-cli-1.5.7.RELEASE-bin/spring-1.5.7.RELEASE/\n$ sdk default springboot dev\n$ spring --version\nSpring CLI v1.5.7.RELEASE\n```\n这将安装一个名为`dev`的`spring`本地实例。它指向了你的目标构建位置，所以每次重构Spring Boot的时候，`spring`都是最新的。\n\n你可以通过以下命令查看：\n```\n$ sdk ls springboot\n\n================================================================================\nAvailable Springboot Versions\n================================================================================\n> + dev\n* 1.5.7.RELEASE\n\n================================================================================\n+ - local version\n* - installed\n> - currently in use\n================================================================================\n```\n\n#### 10.2.3 利用OSX Homebrew安装\n如果你使用的是Mac+Homebrew，可以通过下面的命令安装Spring Boot CLI：\n```\n$ brew tap pivotal/tap\n$ brew install springboot\n```\nHomebrew将会把`spring`安装到`/usr/local/bin`。\n\n> 原文注：如果你没有看到该公式，那么你的brew可能已过时。可以执行`brew update`并重试。\n\n#### 10.2.4 利用MacPorts安装\n如果你使用的是Mac+MacPorts，可以通过下面的命令安装Spring Boot CLI：\n```\n$ sudo port install spring-boot-cli\n```\n\n#### 10.2.5 命令行完成\nSpring Boot CLI为BASH和zsh Shell提供了命令完成的脚本。你可以在任何shell中`source`（或`spring`）该脚本，也可以把它放在你个人或系统范围的bash完成初始化中。在Debian系统上，系统范围的脚本位于`/shell_completion/bash`目录，当一个新的shell启动时这里面所有的脚本都会被执行。假设你已经用SDKMAN!安装了Spring Boot CLI，可以手动运行这些脚本：\n```\n$ . ~/.sdkman/candidates/springboot/current/shell-completion/bash/spring\n$ spring <HIT TAB HERE>\n  grab  help  jar  run  test  version\n```\n> 原文注：如果你使用Homebrew或MacPorts安装的Spring Boot CLI，命令行完成脚本会自动注册到你的Shell。\n\n#### 10.2.6 快速开始Spring CLI的实例\n下面是一个很简单的Web应用程序，你可以用来测试安装结果。创建一个名为`app.groovy`的文件：\n```\n@RestController\nclass ThisWillActuallyRun {\n\n	@RequestMapping(\"/\")\n	String home() {\n		\"Hello World!\"\n	}\n\n}\n```\n然后在shell中运行它：\n```\n$ spring run app.groovy\n```\n> 原文注：当你第一次运行这个程序的时候需要花费一些时间来下载依赖，之后的运行会快很多。\n\n在浏览器上访问localhost: 8080，你会看到下面的输出。\n```\nHello World!\n```\n\n### 10.3 升级低版本的Spring Boot\n如果你想对早期版本的Spring Boot进行升级，请查看[project wiki](https://github.com/spring-projects/spring-boot/wiki)上托管的“发行说明”。你会发现升级说明以及每个版本的“新的和值得注意的”功能列表。\n\n可以使用合适的软件包管理器命令升级CLI（例如`brew upgrade`）；如果你是手动安装的CLI，请按照[标准说明]()记住更新PATH环境变量以删除任何较旧的引用。', '56');
INSERT INTO `translation_article` VALUES ('18', '## 连接处理方法\nNginx提供了各种连接处理方法，部分方法依赖使用的平台。如果平台支持多种方法，Nginx通常会自动选择最有效的那个。但是如果有需求，也可以通过`use`指令显式地选择一个连接处理方法。\n\nNginx支持以下连接处理方法：\n- `select` 标准方法。如果平台没有更高效的方法，那么支持该方法的模块会自动被构建到Nginx。`--with-select_module`和`--without-select_module`配置的参数可以强制构建或禁止构建该模块。\n- `poll` 标准方法。如果平台没有更高效的方法，那么支持该方法的模块会自动被构建到Nginx。`--with-poll_module`和`--without-poll_module`配置的参数可以强制构建或禁止构建该模块。\n- `kqueue` 在FreeBSD 4.1+、OpenBSD 2.9+、NetBSD 2.0和macOS上使用的高效方法。\n- `epoll` 在Linux 2.6+上使用的高效方法。\n- `/dev/poll` 在Solaris 7 11/99+、HP/UX 11.22+ (eventport)、IRIX 6.5.15+和Tru64 UNIX 5.1A+上使用的高效方法。\n- `eventport` 时间端口，在Solaris 10+上使用的方法（因为某些已知的原因，推荐用`/dev/poll`代替该方法）。\n\n> 原文注：从1.11.3版本开始，Nginx支持`EPOLLEDHUP`（Linux 2.6.17、glibc 2.8）和`EPOLLEXCLUSIVE`（Linux 4.5、glibc 2.24）标志。\n\n> 原文注：像SuSE 8.2这样的一些较早的发行版本提供了补丁，为2.4内核添加了epoll支持。', '68');
INSERT INTO `translation_article` VALUES ('22', '# HTTP负载均衡器\n本章描述如何将Nginx和Nginx Plus用作负载均衡器。\n\n## 目录\n[TOC]\n\n## 概览\n优化资源利用率、最大化吞吐量、减少延迟以及确保容错配置常用的技术手段就是对多个应用程序实例进行负载均衡。\n\n观看[Nginx负载均衡软件即时网络研讨会](https://www.nginx.com/resources/webinars/nginx-plus-for-load-balancing-30-min/)深入了解那些Nginx使用者用来构建大规模、高度可用Web服务的技术。\n\nNginx可以在不同的部署场景中用作非常高效的HTTP负载均衡器。\n\n## 将流量代理到组服务器\n在利用Nginx代理组服务器之前，需要利用`upstream`指令定义一个组。该指令放在`http`上下文中。\n\n在这个组中，用`server`指令配置目标服务器（不要与`server`块混淆，它定义的是一个运行在Nginx上的虚拟服务器）。例如，下面的配置定义了一个名为`backend`的组且由三个（可以在至少三个服务器上解析的）服务器配置组成。\n```\nhttp {\n	upstream backend {\n		server backend1.example.com weight=5;\n		server backend2.example.com;\n		server 192.0.0.1 backup;\n	}\n}\n```\n将请求传递给一个服务器组，需要在`proxy_pass`（或根据协议在`fastcgi_pass`、`memcached_pass`、`uwsgi_pass`、`scgi_pass`）指令中指定改组的名称。在下面的例子中，一个运行在Nginx上的虚拟服务器将所有的请求都传递给了上一个例子中定义的`backend`服务器组。\n```\nserver {\n	location / {\n		proxy_pass http://backend;\n	}\n}\n```\n下面的例子整合了之前的两个例子，展示将请求代理到`backend`服务器组。这个服务器组由三个服务器组成，其中两个独立运行着一个相同的应用程序，另一个则作为备份服务器。Nginx利用负载均衡来分配请求：\n```\nhttp {\n	upstream backend {\n		server backend1.example.com;\n		server backend2.example.com;\n		server 192.0.0.1 backup;\n	}\n	server {\n		location / {\n			proxy_pass http://backend;\n		}\n	}\n}\n```\n\n## 选择负载均衡的方式\nNginx支持四种负载均衡的方式，Nginx Plus则补充了第五种：\n1. `Round-robin` - 轮询。根据服务器权重将请求均匀地分配给各个服务器。该方式是默认的，不需要用指令开启。\n	```\n	upstream backend {\n	   server backend1.example.com;\n	   server backend2.example.com;\n	}\n	```\n2. `least-conn` - 最少连接优先。根据服务器权重将请求派发给活跃连接数最少的服务器。\n	```\n	upstream backend {\n		least_conn;\n\n		server backend1.example.com;\n		server backend2.example.com;\n	}\n	```\n3. `ip_hash` - 通过客户端的IP地址来决定请求派发的目标服务器。在这种方式下，IPv4地址的前3个八位字节或者整个IPv6地址会被用来计算哈希值。这种方式确保了来自相同地址的请求会被派发到同一个服务器，除非这个服务器不可用了。\n	```\n	upstream backend {\n		ip_hash;\n\n		server backend1.example.com;\n		server backend2.example.com;\n	}\n	```\n	如果需要暂时地移除某个服务器，为了保护客户端IP地址的哈希值，可以将该服务器标记为`down`。被该服务器处理的请求会被转发给组里的下一个服务器。\n	```\n	upstream backend {\n		server backend1.example.com;\n		server backend2.example.com;\n		server backend3.example.com down;\n	}\n	```\n4. 通用`hash` - 请求派发的目标服务器由用户自定义的密钥决定。这个密钥可能是一个文本、变量或者前两者的组合。例如，这个密钥可能是资源IP和端口，或者是一个URL。\n	```\n	upstream backend {\n		hash $request_uri consistent;\n\n		server backend1.example.com;\n		server backend2.example.com;\n	}\n	```\n	`hash`指令的`consistent`参数可选，它会使[Ketama](https://www.last.fm/user/RJ/journal/2007/04/10/rz_libketama_-_a_consistent_hashing_algo_for_memcache_clients)计算出来的一致的哈希值负载均衡[注1]。Nginx会根据用户自定义的哈希键值将请求均匀地分派给上游服务器（upstream）。如果某个上游服务器被添加到上游组中或者从上游组中移除了，只有少数密钥将被重新映射。在负载均衡能够缓存服务器和其他积累状态的应用程序的情况下，这种方式会使缓存未命中最小化。\n5. `leasr_time` - 最短时长。对每一个请求，Nginx Plus会选择平均等待时长最短且活跃连接数最少的服务器。其中，最短平均等待时长是根据`least_time`的参数计算的：\n	- `header` - 从服务器接收到第一个字节的时间\n	- `last_byte` - 从服务器得到完整响应的时间\n	```\n	upstream backend {\n		least_time header;\n\n		server backend1.example.com;\n		server backend2.example.com;\n	}\n	```\n\n> 原文注：在采用除`round-robin`之外的方式时，需要在`upstream`块中的`server`列表之上添加对应的指令（`least_conn`、`ip_hash`、`hash`、`least_time`）。\n\n## 服务器权重\n默认情况下，Nginx采用轮询的方式在组内服务器之间依据它们的权重派发请求。`server`指令的`weight`参数就是用来设置服务器权重的，默认值为1。\n```\nupstream backend {\n	server backend1.example.com weight=5;\n	server backend2.example.com;\n	server 192.0.0.1 backup;\n}\n```\n在上面的例子中，“backend1.example.com”的权重是5，其他两个服务器使用的是默认权重1，但“192.0.0.1”被标记为备用服务器，因此除非其他两个服务器都不可用，否则它是不会收到请求的。按照这种权重配置，每六个请求中就有五个会被转发给“backend1.example.com”，另一个转发给“backend2.example.com”。\n\n## 服务器慢启动\n服务器慢启动功能能够防止刚刚恢复的服务器再次被请求淹没，继而超时并造成服务器被标记为失败。\n\n在Nginx Plus中，当一个上游服务器被恢复或者可用之后，慢启动能够让其从0到正常值优雅地恢复自己的权重。这个可以通过`server`指令的`slow_start`参数实现：\n```\nupstream backend {\n	server backend1.example.com slow_start=30s;\n	server backend2.example.com;\n	server 192.0.0.1 backup;\n}\n```\n该参数设置的时间值是指服务器恢复其权重所需的时间。\n\n> 原文注：如果组内只有一个服务器，`max_fails`、`fail_timeout`、和`slow_start`参数将会被忽略，且该服务器将永远不会被认为不可用。\n\n## 允许会话持久化\n会话持久化意味着Nginx Plus能够识别用户的会话并将请求派发给与上次相同的上游服务器。\n\nNginx Plus支持三种会话持久化的方式。这三种方式通过`sticky`指定设置：\n- `sticky cookie` - 在这种方式下，当上游组第一次响应的时候，Nginx Plus会向该响应中添加一个会话Cookie，并识别作出响应的服务器。当客户端发出下一个请求时，它将带上Cookie值，NGINX Plus会把请求路由到同一个上游服务器：\n	```\n	upstream backend {\n		server backend1.example.com;\n		server backend2.example.com;\n\n		sticky cookie srv_id expires=1h domain=.example.com path=/;\n	}\n	```\n	在上面的例子中，`sev_id`参数设置的Cookie的名称，可选的`expires`参数设置浏览器保存Cookie的时长，可选的`domain`参数设置了Cookie被设置的域，可选的`path`参数设置了Cookie被设置的路径。这是最简单的会话持久化的方法。\n- `sticky route` - 在这种方式下，Nginx Plus收到第一次请求的时候会给客户端分配一个“路由”，所有后续的请求都会与`server`指令的`route`参数比较，以识别应该被哪个服务器处理。这个路由信息可以从Cookie或URL中提取：\n	```\n	upstream backend {\n		server backend1.example.com route=a;\n		server backend2.example.com route=b;\n\n		sticky route $route_cookie $route_uri;\n	}\n	```\n- `cookie learn` - 在这种方式下，Nginx Plus会先通过检查请求和响应获取会话的标识，然后Nginx Plus会“学习”匹配上游服务器与会话。通常，这些标识都是通过HTTP Cookie传递的。如果某个请求包含了一个已经被Nginx Plus“学习”的会话标识，Nginx Plus会将该请求派发给对应的服务器。\n	```\n	upstream backend {\n		server backend1.example.com;\n		server backend2.example.com;\n\n		sticky learn\n			create=$upstream_cookie_examplecookie\n			lookup=$cookie_examplecookie\n			zone=client_sessions:1m\n			timeout=1h;\n	}\n	```\n	在上面的例子中，上游服务器通过在响应中设置**EXAMPLECOOKIE** Cookie来创建会话。\n	\n	必填参数**create**指定了一个变量，指示如何创建一个新的会话。在我们的例子中，从上游服务器发送的**EXAMPLECOOKIE** Cookie创建会新的会话。\n	\n	必填参数**lookup**指定如何去查找已存在的会话。在我们的例子中，是从客户端发送的**EXAMPLECOOKIE** Cookie里寻找已存在的会话。\n	\n	必填参数**zone**指定了一个共享内存区域，用来保存Sticky Session的所有信息。在我们的例子中，这个区域叫“client_session”，拥有1MB大小。\n	\n	这是更复杂的会话持久化方式，他不需要在客户端保存任何Cookie，所有的信息都保存在服务端的共享内存区域中。\n\n## 限制连接的数量\n利用Nginx Plus可以通过设置`max_conns`参数将连接的数量维持在一个期望的数值上。\n\n如果连接数达到了`max_conns`限制的数量，则多余的请求会被放入一个队列等待进一步处理，该队列通过`queue`指令指定。该指令可以设置队列中允许同时存在的最大数量的请求。\n```\nupstream backend {\n	server backend1.example.com  max_conns=3;\n	server backend2.example.com;\n\n	queue 100 timeout=70;\n}\n```\n如果队列满了或者服务器因为设置了超时时长而导致其无法被派发请求，客户端会收到一个错误。\n\n> 原文注：当其他工作进程中打开了一个空闲的长连接时，`max_conns`的限制会被忽略。因此，在与多个工作进程共享内存的配置中，与服务器的连接总数可能会超过`max_conns`值。\n\n## 被动健康监测\n', '72');
INSERT INTO `translation_article` VALUES ('23', '## Nginx作为HTTP负载均衡器\n[TOC]\n\n### 介绍\n优化资源利用率、最大化吞吐量、减少延迟以及确保容错配置常用的技术手段就是在多个应用程序实例间进行负载均衡。\n\n可以将Nginx作为一个高效的HTTP负载均衡器，向多个应用程序服务器分发流量；利用Nginx可以提高Web应用程序的性能、可扩展性及可靠性。\n\n### 负载均衡的方式\nNginx支持以下几种负载均衡的方式：\n- `round-robin` - 以轮询的方式将请求分发给应用程序服务器\n- `least-connected` - 将请求分发给活跃连接数最少的服务器\n- `ip-hash` - 一个哈希方法会（根据客户端的IP地址）决定请求被分发的服务器\n\n### 默认的负载均衡配置\nNginx中最简单的负载均衡配置和下面的例子相似：\n```\nhttp {\n	upstream myapp1 {\n		server srv1.example.com;\n		server srv2.example.com;\n		server srv3.example.com;\n	}\n\n	server {\n		listen 80;\n\n		location / {\n			proxy_pass http://myapp1;\n		}\n	}\n}\n```\n在上面的例子中，sv1-sv3上独立运行着相同的应用程序。当没有指定负载均衡的方式时，Nginx会默认选择轮询的方式。Nginx会利用HTTP负载均衡将所有的请求分发给myapp1服务器组里面的服务器。\n\n在Nginx中，反向代理的实现包括对HTTP、HTTPS、FastCGI、uwsgi、SCGI以及memcached的负载均衡。\n\n用HTTPS负载均衡代替HTTP负载均衡，只需要将协议改为“https”。\n\n为FastCGI、uwsgi、SCGI或memcached设置负载均衡时，分别需要用到`fastcgi_pass`、`uwsgi_pass`、`scgi_pass`及`memcached_pass`指令。\n\n### 根据最少连接数负载均衡\n（除了轮询）另一个负载均衡的方式是最少连接数。当一些请求的处理需要花费更长时间的时候，最少连接数策略能够更公平地控制该应用程序的负载。\n\n利用最少连接数策略的负载均衡，Nginx不会尝试向一个繁忙的应用程序服务器派发过多的请求造成其过载，而是会将这些请求派发给另一个相对空闲的服务器。\n\n在Nginx中，向服务器组配置里添加`least_conn`指令时，最少连接数策略的负载均衡就会生效。\n```\nupstream myapp1 {\n	least_conn;\n	server srv1.example.com;\n	server srv2.example.com;\n	server srv3.example.com;\n}\n```\n\n### 根据会话负载均衡\n需要注意的是，采用轮询或最少连接数策略的负载均衡，客户端后续的请求可能会被分发到不同的服务器。即它们不能保证来自相同客户端的请求会被分发到同一个服务器。\n\n如果需要将客户端绑定到某个应用程序服务器（即为了将来自同一个客户端的请求分发给同一个服务器，使该客户端的会话“粘性化”或“持久化”），可以选择`ip_hash`负载均衡策略。\n\n在这种策略下，客户端的IP地址会作为哈希秘钥来决定将请求分发给服务器组中的哪个服务器。这种策略确保了来自同一客户端的请求会被分发到同一个服务器，除非这个服务器不可用。\n\n只需要在服务器组配置中添加`ip_hash`指令即可应用该策略：\n```\nupstream myapp1 {\n	ip_hash;\n	server srv1.example.com;\n	server srv2.example.com;\n	server srv3.example.com;\n}\n```\n\n### 根据权重负载均衡\n还可以通过设置服务器权重来进一步影响Nginx的负载均衡算法。\n\n在上面所有的例子中都没有配置服务器权重，这意味着在指定的负载均衡策略下所有指定的服务器都能被均等地分发请求。\n\n尤其是在轮询策略中，这也意味着服务器之间的请求差不多是平均分配的--只要有足够的请求，且请求以统一的方式处理并完成得足够快。\n\n当服务器被指定了`weight`参数时，权重就会作为负载均衡决定的一部分：\n```\nupstream myapp1 {\n	server srv1.example.com weight=3;\n	server srv2.example.com;\n	server srv3.example.com;\n}\n```\n在上述配置下，每5个请求就会按照下面的方案分配给各个应用程序实例：3个请求分发给srv1，1个请求分发给srv2，另一个则分发给srv3。\n\n在最新版本的Nginx中可以将`weight`与`least_conn`或`ip_hash`联合使用。\n\n### 服务器健康检查\nＮginx的反向代理实现包括带内（或被动）服务器运行状况检查。如果来自指定服务器的响应因为一个错误失败了，Nginx会将该服务器标记为失败，并在一段时间内避免将后续入站请求分发到该服务器。\n\n在`fail_timeout`指定的时间内，`max_fails`设置了允许Nginx与服务器建立连接时失败的最大次数。`max_fails`的默认值为0，即不开启该服务器的健康检查。`fail_timeout`还定义了服务器被标记为失败的时长，即在服务器被标记为失败之后，经过该参数指定的时长之前，Nginx是不会向其再分发请求；经过该参数设置的时长之后，Nginx会利用客户端请求优雅地测试该服务器的可用状态，如果测试成功，则将其重新标记为活跃。\n\n### 深入阅读\n此外，在Nginx中还有许多指令和参数可以控制服务器负载均衡，例如`proxy_next_upstream`、`backup`、`down`及`keepalive`。更多信息可以参阅[说明文档](http://nginx.org/en/docs/)。\n\n另外，有偿的Nginx Plus还为服务器组提供了`application_load_balancing`、`application_health_checks`、`activity_monitoring`和`on-the-fly_reconfiguraion`。具体信息参阅Nginx官网。', '73');
INSERT INTO `translation_article` VALUES ('24', '## lscpu - 查询CPU信息\n用法：`lscpu [options]`\n\n选项：\n\n|参数|全称|作用|\n|--|--|--|\n|`-a`|`--all`|（默认以`-e`格式）打印在线和离线的CPU|\n|`-b`|`--online`|（默认以`-p`格式）只打印在线CPU|\n|`-c`|`--offline`|只打印离线CPU|\n|`-e`|`--extended[=<list>]`|以延伸阅读的格式打印|\n|`-h`|`--help`|打印帮助文档|\n|`-p`|`--parse[=<list>]`|以解析的格式打印|\n|`-s`|`--sysroot <dir>`|以系统root身份使用目录DIR|\n|`-V`|`--version`|打印版本信息并退出|\n|`-x`|`--hex`|以十六进制码形式打印CPU而不是以列表的形式|\n\n打印字段：\n- CPU：逻辑CPU的数量；\n- CORE：逻辑核心数量；\n- SOCKET：逻辑套接字数量；\n- NODE：逻辑NUMA节点数量\n- BOOK：逻辑书的数量；\n- CACHE：显示如何在CPU之间共享缓存\n- POLARIZATION：在虚拟硬件上CPU的分配模式\n- ADDRESS：CPU的物理地址\n- CONFIGURED：显示管理程序是否已经分配了该CPU\n- ONLINE：显示Linux当前是否正在使用该CPU\n\n### 查看CPU大致信息\n```\n$ lscpu\nArchitecture:          x86_64\nCPU op-mode(s):        32-bit, 64-bit\nByte Order:            Little Endian\nCPU(s):                16\nOn-line CPU(s) list:   0-15\nThread(s) per core:    1\nCore(s) per socket:    4\nSocket(s):             4\nNUMA node(s):          4\nVendor ID:             GenuineIntel\nCPU family:            6\nModel:                 47\nStepping:              2\nCPU MHz:               1995.000\nBogoMIPS:              3990.00\nHypervisor vendor:     VMware\nVirtualization type:   full\nL1d cache:             32K\nL1i cache:             32K\nL2 cache:              256K\nL3 cache:              18432K\nNUMA node0 CPU(s):     0-3\nNUMA node1 CPU(s):     4-7\nNUMA node2 CPU(s):     8-11\nNUMA node3 CPU(s):     12-15\n```\n\n### 查看CPU详细信息\n过滤选项分三种：`-a`、`-b`、`-c`；除此之外，还需要指定打印格式：`-e`、`-p`。\n```\n$ lscpu -a -e\nCPU NODE SOCKET CORE L1d:L1i:L2:L3 ONLINE\n0   0    0      0    0:0:0:0       yes\n1   0    0      1    0:0:0:0       yes\n2   0    0      2    0:0:0:0       yes\n3   0    0      3    0:0:0:0       yes\n4   1    1      4    1:1:1:1       yes\n5   1    1      5    1:1:1:1       yes\n6   1    1      6    1:1:1:1       yes\n7   1    1      7    1:1:1:1       yes\n8   2    2      8    2:2:2:2       yes\n9   2    2      9    2:2:2:2       yes\n10  2    2      10   2:2:2:2       yes\n11  2    2      11   2:2:2:2       yes\n12  3    3      12   3:3:3:3       yes\n13  3    3      13   3:3:3:3       yes\n14  3    3      14   3:3:3:3       yes\n15  3    3      15   3:3:3:3       yes\n```', '87');
INSERT INTO `translation_article` VALUES ('25', '## 11.开发第一个Spring Boot应用程序\n本节将用Java开发一个简单的“Hello world!”Web应用程序来强调Spring Boot的一些重要功能。鉴于大部分IDE都支持Maven，因此我们选用Maven构建这个项目。\n\n> 原文注：在[spring.io](https://spring.io)网站上有很多关于使用Spring Boot的“准备开始”教程。如果你正在寻求解决某个特殊的问题，应该先在这个网站上查看一下。你可以直接跳转到[start-spring.io](https://start.spring.io)，然后从依赖搜索器中选择`web`启动器来简化下面的步骤，因为该启动器会自动生成一个新的项目架构，这样你就可以直接开始编写代码了。\n\n在开始之前，先打开终端检查Java和Maven的版本：\n```\n$ java -version\njava version \"1.7.0_51\"\nJava(TM) SE Runtime Environment (build 1.7.0_51-b13)\nJava HotSpot(TM) 64-Bit Server VM (build 24.51-b03, mixed mode)\n$ mvn -v\nApache Maven 3.2.3 (33f8c3e1027c3ddde99d3cdebad2656a31e8fdf4; 2014-08-11T13:58:10-07:00)\nMaven home: /Users/user/tools/apache-maven-3.1.1\nJava version: 1.7.0_51, vendor: Oracle Corporation\n```\n\n> 原文注：本例创建在一个文件夹下。后续的说明将假设你已经创建并且进入了这个文件夹（即该文件夹是你的“当前目录”）。', '58');
INSERT INTO `translation_article` VALUES ('26', '### 11.1 创建POM\n首先需要创建一个Maven`pom.xml`文件，它是用来构建项目的配方。用文本编辑器添加以下内容：\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n	xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n	<modelVersion>4.0.0</modelVersion>\n\n	<groupId>com.example</groupId>\n	<artifactId>myproject</artifactId>\n	<version>0.0.1-SNAPSHOT</version>\n\n	<parent>\n	<groupId>org.springframework.boot</groupId>\n	<artifactId>spring-boot-starter-parent</artifactId>\n	<version>1.5.7.RELEASE</version>\n	</parent>\n\n	<!-- Additional lines to be added here... -->\n\n</project>\n```\n这会提供一个有效的构建，你可以通过允许`mvn package`来测试它（现在，你可以忽略“jar will be empty - no content was marked for inclusion!”的警告）。\n\n> 原文注：现在你可以将这个项目导入IDE（当下多数Java IDE都包含对Maven的支持）。为了简单，在本例中我们将继续使用纯文本编辑器。', '61');
INSERT INTO `translation_article` VALUES ('27', '### 11.2 添加类路径依赖\nSpring Boot提供了一些列的启动器来简化将JAR包添加到类路径的工作。我们的示例程序已经在POM的`parent`部分使用了`spring-boot-starter-parent`。`spring-boot-starter-parent`是一个特殊的启动器，提供了许多有用的Maven默认值。此外，它还提供了一个`dependency-management`，这样你可以忽略一部分依赖的版本信息。\n\n当你开发一个特定类型的应用程序时可能会需要用到其他的启动器，你可以简单直接地添加相关的依赖。当我们开发Web应用程序时，我们需要添加`spring-boot-starter-web`依赖，而在此之前，我们先查看一下当前项目拥有的依赖：\n```\n$ mvn dependency:tree\n[INFO] com.example:myproject:jar:0.0.1-SNAPSHOT\n```\n上述指令会打印出项目当前的依赖树。你可以看到`spring-boot-starter-parent`本身是没有提供任何依赖的。现在，编辑`pom.xml`文件，在`parent`部分下面添加`spring-boot-starter-web`依赖：\n```\n<dependencies>\n	<dependency>\n		<groupId>org.springframework.boot</groupId>\n		<artifactId>spring-boot-starter-web</artifactId>\n	</dependency>\n</dependencies>\n```\n如果你再次运行`mav dependency:tree`命令，你会发现新增了包括Tomcat Web服务器及Spring Boot在内的许多依赖。', '62');
INSERT INTO `translation_article` VALUES ('28', '## ngx_stub_status_module\n[TOC]\n\n`ngx_stub_status_module`能够访问基本的状态信息。\n\n### 构建\n（在安装Nginx时）该模块并不是默认被构建的，需要用配置参数`--with-http_stub_status_module`来显式指定将其构建进来。\n```\n$ ../configure ... --with-http_stub_status_module\n```\n\n### 配置示例\n```\nlocation /basic_status {\n	stub_status;\n}\n```\n该配置会创建一个简单的页面来显示下面这些基本的状态数据：\n```\nActive connections: 291 \nserver accepts handled requests\n 16630948 16630948 31070465 \nReading: 6 Writing: 179 Waiting: 106\n```\n\n### 指令\n#### stub_status\n语法：`stub_status`\n\n默认值：—\n\n上下文：`server`、`location`\n\n从包装该指令的`location`可以访问基本的状态信息。\n\n> 原文注：在1.7.5之前的版本，该指令需要携带一个任意参数，例如“stub_status on”。\n\n### 数据\n该模块将会提供以下状态信息：\n- `Active connections` - 当前活跃的客户端连接数，包括`waiting`状态的连接；\n- `accepts` - 已接收的客户端连接总数；\n- `handled` - 已处理的连接总数。通常情况下该参数的值与`accepts`相同，除非达到了某些资源限制（例如`worker_connections`限制）；\n- `requests` - 客户端请求的总数；\n- `Reading` - 当前Nginx正在读取其`header`信息的连接数量；\n- `Writing` - 当前Nginx正在借其向客户端写响应的连接数量；\n- `Waiting` - 当前正在等待请求的空闲的客户端连接数量。\n\n### 嵌入式参数\n本模块支持以下嵌入式参数（可以作为占位符输出，例如打印到日志）：\n- `$connections_active` - 参见`Active connections`\n- `$connections_reading` - 参见`Reading`\n- `$connections_writing` - 参见`Writing`\n- `$connections_waiting` - 参见`Waiting`', '90');
INSERT INTO `translation_article` VALUES ('29', '## ngx_req_status_module\n[TOC]\n\n`ngx_req_status_module`能够统计Nginx中请求的状态信息。\n\n### 构建\n该模块不是Nginx内置的模块，需要用到[第三方](https://github.com/zls0424/ngx_req_status/)模块。\n\n首先，将Nginx的压缩包与本模块的压缩包解压在统同一目录下：\n```\n$ tar -zxvf nginx-VERSION.tar.gz\n$ unzip ngx_req_status-master.zip\n```\n然后进入Nginx的文件夹，向Nginx打补丁。\n```\n$ cd nginx-VERSION\n$ patch -p1 < ../ngx_req_status-master/write_filter-VERSION.patch\n```\n> 译者注：注意`write_filter`是指带版本号的补丁文件。补丁没打或打错，在编译Nginx的时候都会报错：前者报`ngx_http_top_write_filter`未声明，后者报重复定义。\n\n接着，进行配置和编译。如果是对已安装的Nginx添加模块，需要先查看Nginx的配置，并在此次配置中全部带上：\n```\n$ sbin/nginx -V\nnginx version: nginx/1.9.9\nbuilt by gcc 4.4.7 20120313 (Red Hat 4.4.7-11) (GCC) \nbuilt with OpenSSL 1.0.1u  22 Sep 2016\nTLS SNI support enabled\nconfigure arguments: --prefix=/home/itv/nginx --with-http_realip_module --with-http_sub_module --with-http_flv_module --with-http_dav_module --with-http_gzip_static_module --with-http_stub_status_module --with-http_addition_module --with-pcre=/home/itv/nginx-install/packinstall/pcre-8.38 --with-openssl=/home/itv/nginx-install/packinstall/openssl-1.0.1u --with-http_ssl_module --with-zlib=/home/itv/nginx-install/packinstall/zlib-1.2.11 --add-module=/home/itv/nginx-install/packinstall/nginx-goodies-nginx-sticky-module-ng-08a395c66e42/ --add-module=/home/itv/nginx-install/packinstall/ngx_req_status-master/\n$ ../configure [之前的配置] --add-module=pathTo/ngx_req_status-master\n$ make -j2\n```\n\n最后，安装Nginx。如果是对已安装的Nginx添加新模块，则只需要将`objs/`目录下的`nginx`文件替换掉Nginx安装路径下`sbin/`目录的`nginx`即可。\n```\n$ make install\n```\n\n### 配置示例\n```\nhttp {\n	req_status_zone server_name $server_name 256k;\n	req_status_zone server_addr $server_addr 256k;\n\n	req_status server_name server_addr;\n\n	server {\n		location /req-status {\n			req_status_show on;\n\n			allow 10.0.0.0/8;\n			allow 127.0.0.1;\n			deny all;\n		}\n	}\n}\n```\n该配置会利用一个简单页面来展示下面的信息：\n```\nzone_name       key     max_active      max_bw  traffic requests        active  bandwidth\nimgstore_appid  43    27      6M      63G     374063  0        0\nimgstore_appid  53    329     87M     2058G   7870529 50      25M\nserver_addr     10.128.1.17     2        8968   24M     1849    0        0\nserver_addr     127.0.0.1       1       6M      5G      912     1        0\nserver_addr     180.96.x.1   3358    934M    27550G  141277391       891     356M\nserver_addr     180.96.x.2   78      45M     220G    400704  0        0\nserver_addr     180.96.x.3   242     58M     646G    2990547 42      7M\nserver_name     d.123.sogou.com 478     115M    2850G   30218726        115     39M\nserver_name     dl.pinyin.sogou.com     913     312M    8930G   35345453        225     97M\nserver_name     download.ie.sogou.com   964     275M    7462G   7979817 297     135M\n```\n\n### 指令\n#### req_status_zone\n语法：`req_status_zone [name] [string] [size]`\n\n默认值：-\n\n上下文：`http`\n\n定义一个请求状态区域。根据在第二个参数指定的字符串对请求进行分组。\n```\nreq_status_zone server_addr \"$server_addr:$server_port\" 256k;\n```\n\n#### req_status\n语法：`req_status [zone1] [zone2]`\n\n默认值：-\n\n上下文：`http`、`server`、`location`\n\n在该位置启用请求状态。你可以按需求指定多个请求状态区域。\n\n#### req_status_show\n语法：`req_status_show on`\n\n默认值：-\n\n上下文：`location`\n\n在当前位置启用请求状态处理程序。\n```\nlocation /req-status {\n	req_status_show on;\n\n	allow 10.0.0.0/8;\n	allow 127.0.0.1;\n	deny all;\n}\n```\n然后你可以访问http:// 127.0.0.1/req-status查看到请求状态信息。\n\n### 数据\n请求状态信息包括以下字段：\n- `zone_name` - 利用`req_status_zone`定义的分组标准。例如，按照服务器名称对请求进行分组后；\n- `key` - 请求按分组标准分组后的分组标识（即组名）。例如按服务器名称分组时，组名可能是192.168.1.12；\n- `max_active` - 该组的最大并发连接数；\n- `max_bw` - 该组的最大带宽；\n- `traffic` - 该组的总流量；\n- `requests` - 该组的总请求数；\n- `active` - 该组当前的并发连接数；\n- `bandwidth` - 该组当前带宽。', '91');
INSERT INTO `translation_article` VALUES ('30', '### 11.3 编写代码\n为了完善我们的应用程序，需要新建一个JAVA文件。Maven默认从`src/main/java`路径下获取并编译源码，因此你需要创建该目录结构并在该路径下添加一个完全名称为`src/main/java/Example.java`的文件。\n```\nimport org.springframework.boot.*;\nimport org.springframework.boot.autoconfigure.*;\nimport org.springframework.stereotype.*;\nimport org.springframework.web.bind.annotation.*;\n\n@RestController\n@EnableAutoConfiguration\npublic class Example {\n\n	@RequestMapping(\"/\")\n	String home() {\n		return \"Hello World!\";\n	}\n\n	public static void main(String[] args) throws Exception {\n		SpringApplication.run(Example.class, args);\n	}\n\n}\n```\n虽然代码不多，却做了很多事情。接下来我们进入重要环节。\n\n#### 11.3.1 @RestController与@RequestMapping注解\n在`Example`类上的第一个注解就是`@RestController`。它被称为固定注解，有助于阅读代码。对Spring来说，被其注解的类被视作一个Web控制器，当Spring处理请求时会考虑将请求交给它处理。\n\n`@RequestMapping`注解提供了“路由”信息。他告诉Spring，任何路径为“/”的HTTP请求都应当映射到`home`方法上，而`@RestController`注解则告诉Spring将结果字符串直接返回给调用者。\n\n> 原文注：`@RestController`和`@RequestMapping`注解都是Spring MVC注解，并不是Spring Boot独有的。\n\n#### 11.3.2 @EnableAutoConfiguration注解\n第二个类级注解是`@EnableAutoConfiguration`。该注解会告诉Spring Boot，让他根据你提供的JAR包依赖猜测你将会如何配置Spring。一旦`spring-boot-starter-web`添加了Tomcat和Spring MVC，自动配置就是假设你在开发一个Web应用程序并相应地对Spring进行配置。\n\n#### 11.3.3 “主”方法\n我们例子的最后一部分就是`main`方法。该方法是一个标准方法，遵循JAVA针对应用程序入口的规范。我们的主方法会通过调用`SpringApplication`的`run`方法将过程委派给后者。`SpringApplication`将会引导我们的应用程序，启动Spring并自动配置Tomcat Web服务器。我们需要将`Example.class`作为参数传给`run`方法，告诉`SpringApplication`它就是主要的Spring组件。`args`数组也被传递过去，以暴露任何命令行参数。', '63');
INSERT INTO `translation_article` VALUES ('31', '### 11.4 运行实例\n至此我们的应用程序就可以工作了。当使用`spring-boot-starter-parent`POM时，我们就拥有了一个可用的`run`目标来运行应用程序。从根项目目录键入`mvn spring-boot:run`以启动应用程序：\n```\n$ mvn spring-boot:run\n\n  .   ____          _            __ _ _\n /\\\\ / ___\'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\\n( ( )\\___ | \'_ | \'_| | \'_ \\/ _` | \\ \\ \\ \\\n \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )\n  \'  |____| .__|_| |_|_| |_\\__, | / / / /\n =========|_|==============|___/=/_/_/_/\n :: Spring Boot ::  (v1.5.7.RELEASE)\n....... . . .\n....... . . . (log output here)\n....... . . .\n........ Started Example in 2.222 seconds (JVM running for 6.514)\n```\n在浏览器中访问localhost: 8080就可以看到下面的输出：\n```\nHello World!\n```\n输入`ctrl-c`即可优雅地退出。', '65');
INSERT INTO `translation_article` VALUES ('32', '# Part3 使用Spring Boot\n本部分内容将更详细地说明如何使用Spring Boot，包括构建工具、自动配置以及运行应用程序。此外还提供了一些Spring Boot的最佳实践。虽然并无特别之处，但这些建议会让开发更轻松。\n\n如果读者刚接触Spring Boot，请务必先阅读上一部分的内容。', '67');
INSERT INTO `translation_article` VALUES ('33', '## 13.构建工具\n强烈建议使用支持依赖管理并能使用Maven中央库工件（Artifact）的构建工具。对此推荐Maven和Gradle，虽然Spring Boot同样能和其他构建工具一起工作，但并没有很好的支持。\n\n### 13.1 依赖管理\n每个Spring Boot的发行版都提供了一个他所支持的依赖的组织列表。实际开发中无须指定这些依赖的版本，因为Spring Boot会自动管理。当对Spring Boot进行升级时，这些依赖也会一起升级。\n\n> 原文注：如果有需求，可以通过指定依赖的版本信息来覆盖Spring Boot推荐的版本。\n\n该组织列表包含所有可以与Spring Boot一起使用的Spring模块以及一个精炼的第三方库列表。该列表可以用作标准的材料清单（`spring-boot-dependencies`）并为Maven和Gradle提供了额外的专门支持。\n\n> 原文注：每个Spring Boot的发行版都依赖某个版本的Spring Framework，因此非常不建议自己指定依赖的版本。\n\n### 13.2 Maven\nMaven的使用者可以通过继承`spring-boot-starter-parent`项目来获取合理的默认设置。该父项目提供了以下功能：\n- 默认编译版本是Java 1.6\n- UTF-8源码编码方式\n- 一个依赖管理，允许子项目忽略一些常见依赖的`version`标签，直接从`spring-boot-dependencies`中继承\n- 合理的资源过滤\n- 合理的插件配置\n- 为包含配置文件专用文件（如`application-foo.properties`和`application-foo.yml`）的`application.properties`和`application.yml`提供合理的资源过滤\n\n最后一点：当默认配置文件使用了Spring类型的占位符（`${...}`）时，Maven过滤时会改用`@..@`占位符（可以设置Maven的`resource.delimiter`属性覆盖它）。\n\n#### 13.2.1 继承启动器的父项目\n只需要设置一个`parent`标签就可以让项目继承`spring-boot-starter-parent`：\n```\n<!-- Inherit defaults from Spring Boot -->\n<parent>\n	<groupId>org.springframework.boot</groupId>\n	<artifactId>spring-boot-starter-parent</artifactId>\n	<version>1.5.7.RELEASE</version>\n</parent>\n```\n> 原文注：建议只在这个依赖中指定Spring Boot的版本号，这样在导入其他的启动器时可以安全地忽略其版本号。\n\n在该配置下，也可以通过在当前项目中覆盖某个属性来覆盖一个独立的依赖。例如，添加下面的内容对Spring Data的发行版进行升级：\n```\n<properties>\n	<spring-data-releasetrain.version>Fowler-SR2</spring-data-releasetrain.version>\n</properties>\n```\n> 原文注：查看`spring-boot-dependencies`POM了解其支持哪些属性。\n\n#### 13.2.2 非继承下使用Spring Boot\n不是每一个人都喜欢继承`spring-boot-starter-parent`POM。或许当前项目需要继承另一个父项目，也或许只是单纯地想显式声明自己所有的Maven配置。\n\n如果不想使用`spring-boot-starter-parent`，可以在`dependencyManagement`（而不是插件管理）中添加一个`scope=import`依赖：\n```\n<dependencyManagement>\n	<dependencies>\n		<dependency>\n			<!-- Import dependency management from Spring Boot -->\n			<groupId>org.springframework.boot</groupId>\n			<artifactId>spring-boot-dependencies</artifactId>\n			<version>1.5.7.RELEASE</version>\n			<type>pom</type>\n			<scope>import</scope>\n		</dependency>\n	</dependencies>\n</dependencyManagement>\n```\n这种设置将不能像之前的例子那样通过修改某个属性来覆盖一个独立的依赖。如果想实现这样的需求，可以在`spring-boot-dependencies`的前面添加该依赖。例如，升级Spring Data发行版，可以添加以下内容：\n```\n<dependencyManagement>\n	<dependencies>\n	<!-- Override Spring Data release train provided by Spring Boot -->\n		<dependency>\n			<groupId>org.springframework.data</groupId>\n			<artifactId>spring-data-releasetrain</artifactId>\n			<version>Fowler-SR2</version>\n			<scope>import</scope>\n			<type>pom</type>\n		</dependency>\n		<dependency>\n			<groupId>org.springframework.boot</groupId>\n			<artifactId>spring-boot-dependencies</artifactId>\n			<version>1.5.7.RELEASE</version>\n			<type>pom</type>\n			<scope>import</scope>\n		</dependency>\n	</dependencies>\n</dependencyManagement>\n```\n\n> 原文注：在上面的例子中，我们指定了一个BOM，但是任何依赖类型都可以被覆盖。\n\n#### 13.2.3 修改Java版本\n`spring-boot-starter-parent`选择了十分保守的Java兼容性。可以在`pom.xml`文件中的`properties`标签内新增一个`java.version`属性，手动指定编译的Java版本：\n```\n<properties>\n	<java.version>1.8</java.version>\n</properties>\n```\n\n#### 13.2.4 使用Spring Boot Maven插件\nSpring Boot提供了一个将项目打包成可执行JAR包的Maven插件。如果需要使用它，可以在`<plugins/>`标签中添加以下内容：\n```\n<build>\n	<plugins>\n		<plugin>\n			<groupId>org.springframework.boot</groupId>\n			<artifactId>spring-boot-maven-plugin</artifactId>\n		</plugin>\n	</plugins>\n</build>\n```\n> 原文注：如果当前项目使用了Spring Boot启动器的POM，可以只添加插件而不必配置它，除非想要覆盖父POM的设置。\n\n### 13.3 Gradle\nGradle的使用者可以直接在`dependencies`中导入启动器。不想Maven，他不需要导入父项目来共享某些配置：\n```\nrepositories {\n	jcenter()\n}\n\ndependencies {\n	compile(\"org.springframework.boot:spring-boot-starter-web:1.5.7.RELEASE\")\n}\n```\n和Maven一样，Spring Boot也提供了一个Gradle插件`spring-boot-gradle-plugin`来帮助创建一个可执行JAR包，并根据源码运行项目；另外，该插件也提供了一个依赖管理，像Maven一样可以在当前项目忽略Spring Boot管理的某些依赖的版本。\n```\nplugins {\n	id \'org.springframework.boot\' version \'1.5.7.RELEASE\'\n	id \'java\'\n}\n\n\nrepositories {\n	jcenter()\n}\n\ndependencies {\n	compile(\"org.springframework.boot:spring-boot-starter-web\")\n	testCompile(\"org.springframework.boot:spring-boot-starter-test\")\n}\n```\n\n### 13.4 Ant\n也可以使用Apache Ant+lvy构建Spring Boot项目。Spring Boot为该工具提供了一个`spring-boot-antlib`模块用来帮助Ant创建可执行JAR包。\n\n在`ivy.xml`中声明依赖与下面的内容相似：\n```\n<ivy-module version=\"2.0\">\n	<info organisation=\"org.springframework.boot\" module=\"spring-boot-sample-ant\" />\n	<configurations>\n		<conf name=\"compile\" description=\"everything needed to compile this module\" />\n		<conf name=\"runtime\" extends=\"compile\" description=\"everything needed to run this module\" />\n	</configurations>\n	<dependencies>\n		<dependency org=\"org.springframework.boot\" name=\"spring-boot-starter\" rev=\"${spring-boot.version}\" conf=\"compile\" />\n	</dependencies>\n</ivy-module>\n```\n而`build.xml`和下面的内容类似：\n```\n<project\n    xmlns:ivy=\"antlib:org.apache.ivy.ant\"\n    xmlns:spring-boot=\"antlib:org.springframework.boot.ant\"\n    name=\"myapp\" default=\"build\">\n\n    <property name=\"spring-boot.version\" value=\"1.3.0.BUILD-SNAPSHOT\" />\n\n    <target name=\"resolve\" description=\"--> retrieve dependencies with ivy\">\n        <ivy:retrieve pattern=\"lib/[conf]/[artifact]-[type]-[revision].[ext]\" />\n    </target>\n\n    <target name=\"classpaths\" depends=\"resolve\">\n        <path id=\"compile.classpath\">\n            <fileset dir=\"lib/compile\" includes=\"*.jar\" />\n        </path>\n    </target>\n\n    <target name=\"init\" depends=\"classpaths\">\n        <mkdir dir=\"build/classes\" />\n    </target>\n\n    <target name=\"compile\" depends=\"init\" description=\"compile\">\n        <javac srcdir=\"src/main/java\" destdir=\"build/classes\" classpathref=\"compile.classpath\" />\n    </target>\n\n    <target name=\"build\" depends=\"compile\">\n        <spring-boot:exejar destfile=\"build/myapp.jar\" classes=\"build/classes\">\n            <spring-boot:lib>\n                <fileset dir=\"lib/runtime\" />\n            </spring-boot:lib>\n        </spring-boot:exejar>\n    </target>\n</project>\n```\n\n### 13.5 启动器\n启动器是一组便捷的依赖描述符，可以一站式地获取Spring及所需相关技术的依赖。例如，需要使用Spring和JPA实现数据库访问，只需要添加`spring-boot-starter-data-jpa`依赖即可。\n\n> 译者注：个人认为，可以简单地将“启动器”视作一个Spring功能或技术的模块，这个模块内包含了该功能或技术所需的大部分依赖，使用者只需要添加启动器依赖就能获取到其他依赖，而不必再去搜索。\n\nSpring Boot在`org.springframework.boot`组下提供了以下启动器：\n\n|名称|描述|\n|--|--|\n|`spring-boot-starter`|核心启动器。包括自动配置支持、日志和YAML|\n|`spring-boot-starter-activemq`|使用Apache ActiveMQ的JMS消息启动器|\n|`spring-boot-starter-amqp`|使用Spring AMQP和Rabbit MQ的启动器|\n|`spring-boot-starter-aop`|使用Spring AOP和AspectJ进行面向切面编程的启动器|\n|`spring-boot-starter-artemis`|使用Apache Artemis的JMS消息启动器|\n|`spring-boot-starter-batch`|使用Spring Batch的启动器|\n|`spring-boot-starter-cache`|使用Spring Framework缓存支持的启动器|\n|`spring-boot-starter-cloud-connectors`|使用Spring云连接的启动器。云连接能够在Cloud Foundry和Heroku这类云平台上简化与服务的连接|\n|`spring-boot-starter-data-cassandra`|使用Cassandra分布式数据库及Spring Data Cassandra的启动器|\n|`spring-boot-starter-data-couchbase`|使用Couchbase面向文档的数据库及Spring Data Couchbase的启动器|\n|`spring-boot-starter-data-elasticsearch`|使用Elasticsearch搜索和分析引擎及Spring Data Elasticsearch的启动器|\n|`spring-boot-starter-data-gemfire`|使用GemFire分布式数据存储及Spring Data GemFire的启动器|\n|`spring-boot-starter-data-jpa`|使用Spring Data JPA和Hibernate的启动器|\n|`spring-boot-starter-data-ldap`|使用Spring Data LDAP的启动器|\n|`spring-boot-starter-data-mongodb`|使用MongoDB面向文档的数据库及Spring Data MongoDB的启动器|\n|`spring-boot-starter-data-neo4j`|使用Neo4j图形数据库及Spring Data Neo4j的启动器|\n|`spring-boot-starter-data-redis`|利用Spring Data Redis使用Redis键值数据存储和Jedis客户端的启动器|\n|`spring-boot-starter-data-rest`|利用Spring Data REST通过REST公开Spring数据存储仓库的启动器|\n|`spring-boot-starter-data-solr`|利用Spring Data Solr使用Apache Solr搜索平台的启动器|\n|`spring-boot-starter-freemarker`|使用FreeMarker视图构建MVC Web应用程序的启动器|\n|`spring-boot-starter-groovy-templateInfos`|使用Groovy模板视图构建MVC Web应用程序的启动器|\n|`spring-boot-starter-hateoas`|使用Spring MVC和Spring HATEOAS构建基于超媒体的RESTful Web应用程序|\n|`spring-boot-starter-integration`|使用Spring继承的启动器|\n|`spring-boot-starter-jdbc`|利用Tomcat JDBC连接池使用JDBC的启动器|\n|`spring-boot-starter-jersey`|使用JAX-RS和Jersey构建RESTful Web应用程序的启动器。另一个选择是`spring-boot-starter-web`|\n|`spring-boot-starter-jooq`|使用JOOQ访问SQL数据库的启动器。还可以选择`spring-boot-starter-data-jpa`或`spring-boot-starter-jdbc`|\n|`spring-boot-starter-jta-atomikos`|使用Atomikos管理JTA事务的启动器|\n|`spring-boot-starter-jta-bitronix`|使用Bitronix管理JTA事务的启动器|\n|`spring-boot-starter-jta-narayana`|Spring Boot Narayana JTA启动器|\n|`spring-boot-starter-mail`|使用Spring Mail和Spring Framework的email支持的启动器|\n|`spring-boot-starter-mobile`|使用Spring Mobile构建Web应用程序的启动器|\n|`spring-boot-starter-mustache`|使用Mustache事务构建MVC Web应用程序的启动器|\n|`spring-boot-starter-security`|使用Spring Security的启动器|\n|`spring-boot-starter-social-facebook`|使用Spring Social Facebook的启动器|\n|`spring-boot-starter-social-linkedin`|使用Spring Social Linkedin的启动器|\n|`spring-boot-starter-social-twitter`|使用Spring Social Twitter的启动器|\n|`spring-boot-starter-test`|使用 JUnit、Hamcrest和Mockito等库测试Spring Boot应用程序的启动器|\n|`spring-boot-starter-thymelea`|使用Thymeleaf视图构建MVC Web应用程序的启动器|\n|`spring-boot-starter-validation`|利用Hibernate Validator使用Java Bean Validation的启动器|\n|`spring-boot-starter-web`|使用MVC构建（包括RESTful）Web应用程序的启动器。Tomcat作为默认的嵌入式容器|\n|`spring-boot-starter-web-services`|使用Spring Web Service的启动器|\n|`spring-boot-starter-websocket`|使用Spring Framework的WebSocket支持来构建WebSocket应用程序的启动器|\n\n除了应用程序启动器之外，还可以使用以下启动器来添加生产准备功能：\n\n|名称|描述|\n|--|--|\n|`spring-boot-starter-actuator`|利用Spring Boot Actuator提供生产准备功能并帮助监控和管理应用程序的启动器|\n|`spring-boot-starter-remote-shell`|在SSH上利用CRaSH远程Shell来监控和管理应用程序的启动器。自1.5版本后弃用|\n\n最后，Spring Boot还提供了一些启动器来排除或替换指定的技术面：\n\n|名称|描述|\n|--|--|\n|`spring-boot-starter-jetty`|使用Jetty作为嵌入式Servlet容器的启动器。另一个选择是`spring-boot-starter-tomcat`|\n|`spring-boot-starter-log4j2`|使用log4j2打印日志的启动器。另一个选择是`spring-boot-starter-logging`|\n|`spring-boot-starter-logging`|使用Logback打印日志的启动器。是默认的启动器。|\n|`spring-boot-starter-tomcat`|使用Tomcat作为嵌入式Servlet容器的启动器。是`spring-boot-starter-web`默认的Servlet容器启动器|\n|`spring-boot-starter-undertow`|使用Undertow作为嵌入式Servlet容器的启动器。另一个选择是`spring-boot-starter-tomcat`|', '92');
INSERT INTO `translation_article` VALUES ('34', '## 14.构造代码\nSpring Boot对代码布局没有任何要求。\n\n### 14.1 使用“default”包\n当一个类没有`package`声明语句时，默认该类位于默认包下。不鼓励且应当避免使用默认包，因为在Spring Boot应用程序中使用`@ComponenetScan`、`@EntityScan`或`@SpringBootApplication`时，会造成每个JAR包中的类都会被读取。\n\n> 原文注：推荐遵循Java提倡的包命名规范，使用反向域名称作为包名（如`com.example.project`）。\n\n### 14.2 定位主应用程序类\n通常建议将主应用程序类放在其他类的根包下。位于该类上的`@EnableAutoConfiguration`注解隐式地为某些项目定义了一个基本的“搜索包”。例如，如果你写了一个JPA应用程序，Spring Boot会在被`@EnableAutoConfiguration`注解的类所在的包中搜索`@Entity`项目。\n\n使用根包还可以免除配置`@ComponentScan`注解的`basePackage`属性。如果主应用程序类位于根包，还可以使用`@SpringBootApllication`注解。\n\n典型的布局如下：\n```\ncom\n +- example\n     +- myproject\n         +- Application.java\n         |\n         +- domain\n         |   +- Customer.java\n         |   +- CustomerRepository.java\n         |\n         +- service\n         |   +- CustomerService.java\n         |\n         +- web\n             +- CustomerController.java\n```\n`Application.java`将声明一个`main`方法和一个`@Configuration`：\n```\npackage com.example.myproject;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.EnableAutoConfiguration;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\n@EnableAutoConfiguration\n@ComponentScan\npublic class Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n}\n```', '93');
INSERT INTO `translation_article` VALUES ('35', '## ngx_http_log_module\n[TOC]\n\n`ngx_http_log_module`会按照指定的格式输出请求日志。\n\n在处理结束的位置，请求会被记录在该位置的上下文中。如果在请求处理期间发生内部重定向，它可能与原始位置不同。\n\n### 构建\n该模块默认被构建到Nginx中。\n\n### 配置示例\n```\nlog_format compression \'$remote_addr - $remote_user [$time_local] \'\n						\'\"$request\" $status $bytes_sent \'\n						\'\"$http_referer\" \"$http_user_agent\" \"$gzip_ratio\"\';\n\naccess_log /spool/logs/nginx-access.log compression buffer=32k;\n```\n\n### 指令\n#### access_log\n语法：access_log\n', '98');
INSERT INTO `translation_article` VALUES ('36', '## uname - 查询系统信息\n语法：`uname [options]`\n\n选项：\n\n|参数|全称|描述|\n|--|--|--|\n|`-a`|`--all`|按照下面的参数顺序输出。其中，若`-p`和`-i`的探测结果不可知，则省略|\n|`-s`|`--kernel-name`|输出内核名称|\n|`-n`|`--nodename`|输出网络节点上的主机名|\n|`-r`|`--kernel-release`|输出内核发行号|\n|`-v`|`--kernel-version`|输出内核版本|\n|`-m`|`--machine`|输出主机的硬件架构名称|\n|`-p`|`--processor`|输出处理器类型或“unknown”|\n|`-i`|`--hardware-platform`|输出硬件平台或“unknown”|\n|`-o`|`--operating-system`|输出操作系统名称|\n||`--help`|显示帮助信息并退出|\n||`--version`|显示版本信息并退出|', '99');
INSERT INTO `translation_article` VALUES ('37', '## 15.配置类\nSpring Boot支持基于JAVA的配置。虽然可以在`SpringApplication.run()`中指定一个XML，但推荐将`@Configuration`注解的类作为主配置。通常，该主配置是含有`main`方法的类。\n\n> 原文注：许多发布在互联网上的Spring配置实例都是基于XML的，但推荐尽可能地使用基于JAVA的配置。搜索`Enable*`注解可以帮助了解更多。\n\n### 15.1 导入外部配置类\n你不必将所有的`@Configuration`放在一个类中。`@Import`注解可以用来导入外部配置类。或者你也可以使用`@ComponentScan`自动扫描所有的Spring组件，包括`@Configuration`类。\n\n### 15.2 导入XML配置\n如果你一定要使用基于XML的配置，我们还是建议你通过在`@Configuration`类上使用`@ImportResource`注解加载XML配置文件。', '94');
INSERT INTO `translation_article` VALUES ('38', '## 16.自动配置\nSpring Boot的自动配置会根据你添加的JAR包依赖尝试自动配置你的Spring应用程序。例如，在你的类路径中存在`HSQLDB`，且你没有配置任何数据库连接Bean，那么Spring Boot将自动配置一个内存数据库。\n\n你需要在`@Configuration`类上选择利用`@EnableAutoConfiguration`还是`@SpringBootApplication`注解声明自动配置。\n\n> 原文注：上面两个注解只需要选择其中一个即可。通常我们推荐在主`@Configuration`类上使用`@EnableAutoConfiguration`注解。\n\n### 16.1 逐渐替换自动配置\n自动配置是非侵入式的，任何时候你都可以利用自定义的配置替换指定部分的自动配置。例如，如果你添加了自己的`DataSource`Bean，那么默认的嵌入式数据库将不会生效。\n\n如果你需要查询哪些自动配置被应用了，可以在启动应用程序的时候添加`--debug`参数，它会选择一个核心日志框架调试日志，并将自动配置报告打印到控制台。\n\n### 16.2 禁用指定的自动配置\n如果你不想应用某些自动配置，你可以使用`@EnableAutoConfiguration`注解的`exclude`属性禁用相应的配置类：\n```\nimport org.springframework.boot.autoconfigure.*;\nimport org.springframework.boot.autoconfigure.jdbc.*;\nimport org.springframework.context.annotation.*;\n\n@Configuration\n@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})\npublic class MyConfiguration {\n}\n```\n如果这个配置类不在类路径下，你可以改用上述注解的`excludeName`属性，通过指定配置类的全限定名称禁用该自动配置。最后，你还可以通过`sprng.autoconfigure.exclude`属性控制禁用的自动配置类列表。\n\n> 原文注：你可以在注解级或使用属性定义被禁用的自动配置类。', '95');
INSERT INTO `translation_article` VALUES ('39', '## 17.Spring的Bean和依赖注入\n你可以自由地使用标准Spring Framework技术定义你的Bean和它们注入的依赖关系。简单来说，我们通常利用`@ComponentScan`注解找到你的Bean，结合`@Autowired`注解进行构造器注入。\n\n如果你按照之前的建议构造你的代码（将应用程序类放在根包下），你无须在`@ComponentScan`中添加任何参数，所有的应用程序组件（`@Component`、`@Service`、`@Repository`、`@Controller`等）都会自动被注册为Spring的Bean。\n\n下面是一个`@Service`Bean的例子，利用构造器注入获取一个`RiskAccessor`Bean：\n```\npackage com.example.service;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class DatabaseAccountService implements AccountService {\n\n    private final RiskAssessor riskAssessor;\n\n    @Autowired\n    public DatabaseAccountService(RiskAssessor riskAssessor) {\n        this.riskAssessor = riskAssessor;\n    }\n\n    // ...\n\n}\n```\n如果Bean中含有一个构造器，你可以省略`@Autowired`注解：\n```\n@Service\npublic class DatabaseAccountService implements AccountService {\n\n    private final RiskAssessor riskAssessor;\n\n    public DatabaseAccountService(RiskAssessor riskAssessor) {\n        this.riskAssessor = riskAssessor;\n    }\n\n    // ...\n\n}\n```\n> 原文注：注意，使用构造器注入的方式允许`riskAccessor`属性被声明为`final`，表示它之后不能被改变。', '96');
INSERT INTO `translation_article` VALUES ('40', '## 18.使用@SpringBootApplication注解\n许多Spring Boot的开发者都会在他们的主类上使用`@Configuration`、`@EnableAutoConfiguration`和`@ComponentScan`注解。由于这个组合使用得过于频繁（尤其是采用之前推荐的最佳实践时），Spring Boot提供了另一个方便的选择`@SpringBootApplication`注解。\n\n`@SpringBiitApplication`注解等价于上述三个注解的组合，并拥有他们的默认属性：\n```\npackage com.example.myproject;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication // same as @Configuration @EnableAutoConfiguration @ComponentScan\npublic class Application {\n\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n\n}\n```\n> 原文注：`@SpringBootApplication`还提供了别名用于自定义`@EnableAutoConfiguration`和`@ComponentScan`的属性。', '97');
INSERT INTO `translation_article` VALUES ('41', '## ngx_http_map_module\n[TOC]\n\n`ngx_http_map_module`对已有的变量进行处理，将新产生的值赋给新的变量。\n\n### 构建\n该模块默认被构建到Nginx中。\n\n### 配置示例\n```\nmap $http_host $name {\n    hostnames;\n\n    default       0;\n\n    example.com   1;\n    *.example.com 1;\n    example.org   2;\n    *.example.org 2;\n    .example.net  3;\n    wap.*         4;\n}\n\nmap $http_user_agent $mobile {\n    default       0;\n    \"~Opera Mini\" 1;\n}\n```\n\n### 指令\n#### map\n语法：`map [srcVariables] [$resultVariable] {..}`\n\n默认值：-\n\n上下文：`http`\n\n创建一个新的变量，其值依赖于在第一个参数中指定的一个或多个源变量。\n\n> 原文注：0.9.0之前的版本只能在第一个参数中指定一个源变量。因为只有在使用变量时才计算变量，所以单纯地声明大量的“map”变量不会增加任何额外的成本来进行处理。\n\n在`map`块中的参数规范了源值与结果值之间的映射关系。\n\n源值以字符串或正则表达式（0.9.0）的形式指定：字符串形式忽略大小写。正则表达式形式以`~`符号开头时大小写敏感，以`~*`符号（1.0.4）开头时忽略大小写。正则表达式可以包含命名和位置捕获，稍后可以在其他指令中使用结果变量。\n\n如果源值匹配下面描述的参数的名称，那么它应该添加一个`\\`符号前缀。\n\n结果值可以包含文本、变量（0.9.0）及它们的组合。\n\n除了源值，模块还提供了一些参数：\n- `default [value]` - 当源值无法匹配到`map`块中的任何参数时，将该参数的值设置成结果值。如果没有指定该参数，则默认的结果值是空字符串。\n- `hostnames` - 表示源值可以是带前缀或后缀的主机名称。\n	```\n	*.example.com 1;\n	example.*     1;\n	```\n	下面的两个记录\n	```\n	example.com   1;\n	*.example.com 1;\n	```\n	可以整合成\n	```\n	.example.com  1;\n	```\n	该参数应当在值列表之前被指定。\n- `include [file]` - 包含一个存储了值的文件。可以有多个包含参数。\n- `volatile` - 表示变量不可缓存（1.11.7）。\n\n如果源值匹配多个\n\n#### map_hash_bucket_size\n\n\n#### map_hash_max_size', '100');
INSERT INTO `translation_article` VALUES ('42', '## 1.Nginx的安装与升级\n[TOC]\n\n> 笔者注：本部分及此后的文章均基于Linux系统。Nginx在Windows系统下的使用不在讨论范围。\n\nLinux系统下安装Nginx有两种方式：包管理器自动安装和源码编译安装。\n\n### 1.1 包管理器自动安装\n\n\n### 1.2 源码编译安装\n相较于包管理器自动安装的方式，虽然源码编译安装的方式可以让安装过程变得可控（比如，指定安装地址、添加自开发的模块），但需要注意的事也很多。例如，需要预装编译器等。\n\nNginx依赖额外的三个库：`zlib`、`pcre`和`openssl`。按照依赖的方式，源码编译安装又可以分为动态依赖编译和静态依赖编译两种方式。\n\n#### 1.2.1 动态依赖编译\n动态依赖编译是指Nginx在编译时依赖环境已安装的库。优点是升级依赖库的时候不需要重新编译安装Nginx，缺点则是如果环境没有安装上述三个库，需要手动安装。\n\nNginx的编译安装参考下一节内容。\n\n#### 1.2.2 静态依赖编译\n静态依赖编译是指将依赖库编译到Nginx中一起安装。优点是可以手动搭配依赖库的版本，而且更直观方便；缺点则是需要了解版本兼容。\n\n首先，下载。分别下载[zlib源码压缩包](http://www.zlib.net/)、[pcre源码压缩包](http://ftp.exim.llorien.org/pcre/)、[openssl源码压缩包](https://www.openssl.org/source/)以及[Nginx源码压缩包](http://nginx.org/en/download.html)。\n\n然后，上传。将上述四个压缩包上传到Linux系统服务器上的同一个目录下。如`/home/user001/installors`。在该目录下创建一个`nginx-install`文件夹。\n```\n[user001@localhost installors]$ mkdir nginx-install\n```\n\n接着，解压。将上述四个压缩包解压至该文件夹下，并进入Nginx的源码根目录：\n```\n[user001@localhost installors]$ tar -zxvf openssl-1.1.0g.tar.gz -C nginx-install\n[user001@localhost installors]$ tar -zxvf pcre2-10-21.tar.gz -C nginx-install\n[user001@localhost installors]$ tar -zxvf zlib-1.2.11.tar.gz -C nginx-install\n[user001@localhost installors]$ tar -zxvf nginx-1.9.9.tar.gz -C nginx-install\n[user001@localhost installors]$ cd nginx-install/nginx-1.9.9\n[user001@localhost nginx-1.9.9]$\n```\n\n继续，配置。Nginx的配置参数可以通过`./configure --help`查看，详细配置可参阅《[源码安装Nginx](http://blog.csdn.net/zsl10/article/details/52181748)》：\n```\n[user001@localhost nginx-1.9.9]$ ./configure ...\n```\n\n最后，编译和安装。\n```\n[user001@localhost nginx-1.9.9]$ make\n[user001@localhost nginx-1.9.9]$ make install\n```\n\n### 1.3 常见安装报错\n#### 1.3.1 pcre.h: No such file or directory\n查看pcre的安装包是否以“pcre2”开头，换做“pcre”开头的安装包试试。\n\n#### 1.3.2 ngx_event_openssl.c: dereferencing pointer to imcompletetype\nOpenSSL的版本过高（1.1.-），换到（1.0.-）试试。\n\n#### 1.3.3 ./configure: C compiler cc is not found\n没有找到C编译器，需要安装GCC。', '102');
INSERT INTO `translation_article` VALUES ('43', '## 20.开发者工具\nSpring Boot包含一组额外的工具，可以体验更愉快的应用程序开发。`spring-boot-devtools`模块可以添加到任何项目中，用来提供额外的开发时的功能。只需将该模块的依赖添加到构建文件中即可：\n- Maven\n	```\n	<dependencies>\n		<dependency>\n			<groupId>org.springframework.boot</groupId>\n			<artifactId>spring-boot-devtools</artifactId>\n			<optional>true</optional>\n		</dependency>\n	</dependencies>\n	```\n- Gradle\n	```\n	dependencies {\n		compile(\"org.springframework.boot:spring-boot-devtools\")\n	}\n	```\n\n> 原文注：当运行整个打包后的应用程序时，开发者工具会自动被禁用。如果你是通过`java -jar`或一个特殊的类加载器启动应用程序，那么该应用会被视作“生产应用”。将该依赖标记为可选，可以防止devtools被项目应用到其他模块。Gradle并不支持`optional`依赖，所以你可以参阅`propdeps-plugin`。\n\n### 20.1 属性默认值\nSpring Boot提供的一些库使用缓存来提高性能。例如，模板引擎会缓存已编译的模板来避免重复解析模板文件，以及Spring MVC在处理静态资源时会将HTTP缓存头信息添加到响应中。\n\n高速缓存在生产环境中好处多多，但在开发时可能会造成反作用，阻止你实时查看在程序中所做的修改。因为这个，spring-boot-devtools默认禁用了这些高速缓存的选项。\n\n这些缓存选项可以在`application.properties`文件中配置。例如，Thymeleaf提供了`spring.thymeleaf.cache`属性。其实不必手动配置这些属性，因为`spring-boot-devtools`有一套默认的、合理的开发时配置。\n\n> 原文注：查看属性的完整列表可以参阅`DevToolsPropertyDefaultsPostProcessor`。\n\n### 20.2 自动重启\n当类路径下的文件内容发生改变时，使用了`spring-boot-devtools`的应用程序会自动重启。这在利用IDE开发时很有用，因为它为代码变更提供了一个快速反馈循环。默认情况下，类路径下的任何实体的变化都会被监控。注意，某些资源（如静态资源和视图模板）是不需要重启应用程序的。\n\n#### 20.2.1 排除资源\n某些资源被修改时无需触发应用程序的重启。例如，Thymeleaf模板可以就地编辑。默认情况下，在`/META-INF/maven`、`/META-INF/resources`、`/resources`、`/static`、`/public`或`/templateInfos`目录下的资源被修改后不会触发程序重启，但是会触发即时重载。如果你想自定义这些排除的路径，可以覆盖`spring.devtools.restart.exclude`属性。例如，只排除`/static`和`/public`目录：\n```\nspring.devtools.restart.exclude=static/**,public/**\n```\n> 原文注：如果你想在默认配置的基础上添加新的排除项，可以使用`spring.devtools.restart.additional-exclude`属性。\n\n#### 20.2.2 监控其他路径\n如果你希望在修改类路径以外的文件时也能够触发应用程序的重启或重载，可以使用`spring.devtools.restart.additional-paths`属性来监视类路径以外的路径。你可以向之前描述的那样，使用`spring.devtools.restart.exclude`属性来控制这个路径下的文件发生修改时是触发重启还是重载。\n\n#### 20.2.3 禁用重启\n你可以使用`spring.devtools.restart.enabled`属性禁用重启功能。在多数情况下你可以在`application.properties`中设置该属性（重启的类加载器依旧会被初始化，但不会再监控文件的修改）。\n\n如果你需要完全禁用重启支持，例如，因为它不支持某些特殊的库，你需要在调用`SpringApplication.run(..)`之前设置一个`System`属性。例如：\n```\npublic static void main(String[] args) {\n    System.setProperty(\"spring.devtools.restart.enabled\", \"false\");\n    SpringApplication.run(MyApp.class, args);\n}\n```\n\n#### 20.2.4 使用触发器文件\n如果你在使用IDE时它不停地编译被修改的文件，你可能期望只在指定时间触发重启。对此，你可以使用“触发器文件”。触发器文件是个特殊的文件，当你想真正触发一个重启检查时必须监控该文件。只更改文件会触发检查，只有Devtools检测到必须执行某些操作时才会重启。可以手动或利用IDE插件更新触发器文件。\n\n可以使用`spring.devtools.restart.trigger-file`属性指定触发器文件。\n\n> 原文注：你可以将该属性设置成全局配置，从而对所有项目都有效。\n\n#### 20.2.5 自定义重启类加载器\n如上所述，重启功能基于两个类加载器。这种方式对多数应用程序已经够用，但是有时候会造成类加载相关的问题。\n\n默认情况下，在IDE中打开的项目由“重启”类加载器加载，常规`.jar`文件则由“公共”类加载器加载。对于多模块项目，如果存在模块未导入到IDE，你需要自定义一些东西。对此，你可以创建一个`META-INF/spring-devtools.properties`文件。\n\n`spring-devtools.properties`文件可以包含`restart.exclude.`和`restart.include.`前缀的属性。其中`include`指定需要被“重启”类加载器加载的项目，`exclude`指定需要被“公共”类加载器加载的项目。这些属性的值是针对类路径的正则表达式。\n\n例如：\n```\nrestart.exclude.companycommonlibs=/mycorp-common-[\\\\w-]+\\.jar\nrestart.include.projectcommon=/mycorp-myproj-[\\\\w-]+\\.jar\n```\n\n> 原文注：所有属性的键名必须唯一，且以`restart.include.`或`restart.exclude.`开头时可用。\n\n#### 20.2.6 已知的限制\n对于利用标准的`ObjectInputStream`进行反序列化的对象，重启功能可能会失效。如果你需要反序列化数据，可以结合`Thread.currentThread().getContextClassLoader()`使用Spring的`ConfigurableObjectInputStream`。\n\n不幸的是，一些第三方库反序列化时没有考虑上下文类加载器。如果你发现了这个问题，可以请求作者修复。', '57');
INSERT INTO `translation_article` VALUES ('44', '在使用调度器之前，你必须先实例化它。对此，你需要用到`SchedulerFactory`。一些Quartz的使用者喜欢将工厂实例放到JNDI存储中，另一些使用者则发现直接实例化并使用工厂实例也很简单。\n\n调度器一旦被实例化，就可以被启动、置于待机模式以及关闭。注意，调度器一旦被关闭，在重新被实例化之前是无法重新启动的。如果调度器没有启动或者处于暂停状态，触发器不会触发（作业也不会执行）。\n\n下面是一段简短的代码，展示了调度器的实例化和启动，以及调度一个任务去执行：\n```\nSchedulerFactory schedFact = new org.quartz.impl.StdSchedulerFactory();\n\nScheduler sched = schedFact.getScheduler();\n\nsched.start();\n\n// define the job and tie it to our HelloJob class\nJobDetail job = newJob(HelloJob.class)\n    .withIdentity(\"myJob\", \"group1\")\n    .build();\n\n// Trigger the job to run now, and then every 40 seconds\nTrigger trigger = newTrigger()\n    .withIdentity(\"myTrigger\", \"group1\")\n    .startNow()\n    .withSchedule(simpleSchedule()\n        .withIntervalInSeconds(40)\n        .repeatForever())\n    .build();\n\n// Tell quartz to schedule the job using our trigger\nsched.scheduleJob(job, trigger);\n```\n正如你所见，Quartz的使用十分简单。在第2讲中我们将简单地了解Job和Trigger，以及Quartz的API，这样你就能更透彻地理解上面的例子了。', '110');
INSERT INTO `translation_article` VALUES ('45', '## Quartz API\nQuartz API的主要接口包括：\n- `Scheduler` - 与调度器交互的主要API。\n- `Job` - 实现了该接口的组件能够被调度器执行。\n- `JobDetail` - 用于定义Job实例。\n- `Trigger` - 基于指定Job定义执行调度的组件。\n- `JobBuilder` - 用于定义或创建JobDetail实例。\n- `TriggerBuilder` - 用于定义或创建Trigger实例。\n \n`Scheduler`的生命周期从利用`SchedulerFactory`创建开始到调用自身的`shutdown()`方法结束。`Scheduler`一旦被创建，就可以添加、删除和查询Job和Trigger，以及执行其他与调度相关的操作（例如暂停触发器）。但是在`Scheduler`调用`start()`方法启动之前（如第1讲所示），是不会触发任何触发器（执行作业）的。\n\nQuartz提供了一些定义了DSL（Domain Specific Language）的“构建器”类。在之前的例子中已经展示相关的用法，下面再次贴出相关代码：\n```\n// define the job and tie it to our HelloJob class\nJobDetail job = newJob(HelloJob.class)\n    .withIdentity(\"myJob\", \"group1\") // name \"myJob\", group \"group1\"\n    .build();\n\n// Trigger the job to run now, and then every 40 seconds\nTrigger trigger = newTrigger()\n    .withIdentity(\"myTrigger\", \"group1\")\n    .startNow()\n    .withSchedule(simpleSchedule()\n        .withIntervalInSeconds(40)\n        .repeatForever())            \n    .build();\n\n// Tell quartz to schedule the job using our trigger\nsched.scheduleJob(job, trigger);\n```\n构建了作业定义的代码块使用了从`JobBuilder`静态导入的方法。同样，构建了触发器定义的代码块使用了从`TriggerBuilder`及`SimpleScheduleBuilder`静态导入的方法。\n\nDSL的静态导入可通过下面的导入语句实现：\n```\nimport static org.quartz.JobBuilder.*;\nimport static org.quartz.SimpleScheduleBuilder.*;\nimport static org.quartz.CronScheduleBuilder.*;\nimport static org.quartz.CalendarIntervalScheduleBuilder.*;\nimport static org.quartz.TriggerBuilder.*;\nimport static org.quartz.DateBuilder.*;\n```\n不同的`ScheduleBuilder`类能够定义不同类型的调度策略。\n\n`DateBuilder`类拥有一系列的方法轻松为特定的时间点（例如表示下一个偶数小时的日期。换言之，如果当前是9:43:27，则为10:00:00）构造`java.util.Date`实例。\n\n## 作业和触发器\n作业就是实现了`Job`接口的类。`Job`接口只有一个简单的方法：\n```\npackage org.quartz;\n\npublic interface Job {\n\n    public void execute(JobExecutionContext context) throws JobExecutionException;\n}\n```\n当作业的触发器被触发时（在同一时刻可能被触发多次），调度器的某个工作线程就会调用`execute(..)`方法。传递给该方法的`JobExecutionContext`对象提供了该作业的实例，该实例携带了其自身的运行时环境，包括一个执行该作业的调度器句柄、一个触发这个执行操作的触发器句柄、作业的`JobDetail`对象及其他内容。\n\n`JobDetail`对象在作业被添加到调度器的时候由Quartz客户端（即你的程序）创建。它包含许多作业的设置属性以及一个`JobDataMap`，后者可以用来存储作业类实例的状态信息。`JobDetail`实质上是作业实例的定义，在下一讲将会深入讲解。\n\n`Trigger`对象用于触发作业的执行。当你希望调度一个作业时，你可以实例化一个触发器并调整它的属性来设计调度策略。触发器也可能会有一个与之关联的`JobDataMap`-这对于将特定于触发器触发的参数传递给作业非常有用。Quartz附带少数几种不同的触发器类型，但最常用的是`SimpleTrigger`和`CronTrigger`。\n\n`SimpleTrigger`适合一次性执行的作业（只是在特定时刻执行一项作业）或者在某个时刻执行且间隔T时间重复执行N次的作业。`CronTrigger`更适合基于类日历调度策略的作业-例如“每个星期五的下午”或者“每个月10号的10::15”。\n\n为什么区分作业和触发器呢？一些作业调度器并没有区分作业和触发器的概念。其中一部分将“作业”定义为带有一些小型作业标识符的执行时间（或调度策略），另一些则类似Quartz中作业和触发器对象的联合体。在开发Quartz时，我们觉得对调度策略和基于该策略执行的作业进行区分很有必要。这样做（在我们看来）有很多好处。\n\n例如，作业可以独立于触发器被创建和存储在作业调度器内，多个触发器可以关联同一个作业。这种松耦合的另一个好处是，对于调度器维护的作业，当他们关联的触发器失效后允许对他们进行再配置，这样不用重新定义这些作业，就可以在之后重新调度他们。即它允许你在不用重新定义作业的前提下修改或替换触发器。\n\n## 标识\n作业和触发器在被注册到Quartz调度器的时候会被指定标识键。作业和触发器的键（`JobKey`和`TriggerKey`）能够将作业和触发器放在“组”内分类进行管理，例如“报表作业组”、“维护作业组”等。作业或触发器的键名称部分在组内必须是唯一的-换言之，作业和触发器的完整键（或标识）是名称和组的复合。\n\n你现在已经大致了解了什么是作业和触发器，在第3讲和第4讲你可以了解更多。', '111');

-- ----------------------------
-- Table structure for translation_struct
-- ----------------------------
DROP TABLE IF EXISTS `translation_struct`;
CREATE TABLE `translation_struct` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '结构ID',
  `name` varchar(50) DEFAULT NULL COMMENT '结构名称',
  `pro_id` varchar(64) DEFAULT NULL COMMENT '项目ID',
  `parent_id` int(11) DEFAULT NULL COMMENT '父节点',
  `sort` int(2) DEFAULT NULL COMMENT '排序',
  `level` int(1) DEFAULT NULL COMMENT '层级:基于0',
  `is_parent` int(1) DEFAULT NULL COMMENT '是否父节点:0-否，1-是',
  `translator` int(11) DEFAULT NULL COMMENT '翻译者',
  `update_time` datetime DEFAULT NULL COMMENT '翻译时间',
  `verifier` int(11) DEFAULT NULL COMMENT '校验者',
  `verify_time` datetime DEFAULT NULL COMMENT '校验时间',
  `status` int(1) DEFAULT NULL COMMENT '状态（1-待翻译，2-待校验，3-通过）',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=112 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of translation_struct
-- ----------------------------
INSERT INTO `translation_struct` VALUES ('1', 'Spring Framework中文文档', '29792a95-806b-46c3-9218-71ee39cb3d5a', '0', '1', '0', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('2', '核心技术', '29792a95-806b-46c3-9218-71ee39cb3d5a', '1', '1', '1', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('3', '测试模块', '29792a95-806b-46c3-9218-71ee39cb3d5a', '1', '2', '1', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('4', '数据访问', '29792a95-806b-46c3-9218-71ee39cb3d5a', '1', '3', '1', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('5', 'Web Servlet', '29792a95-806b-46c3-9218-71ee39cb3d5a', '1', '4', '1', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('6', 'Web反应', '29792a95-806b-46c3-9218-71ee39cb3d5a', '1', '5', '1', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('7', '整合', '29792a95-806b-46c3-9218-71ee39cb3d5a', '1', '6', '1', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('8', '语言', '29792a95-806b-46c3-9218-71ee39cb3d5a', '1', '7', '1', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('9', '新节点', '29792a95-806b-46c3-9218-71ee39cb3d5a', '1', '8', '1', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('10', '1.IoC容器', '29792a95-806b-46c3-9218-71ee39cb3d5a', '2', '1', '2', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('11', '2.资源', '29792a95-806b-46c3-9218-71ee39cb3d5a', '2', '2', '2', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('12', '3.验证、数据绑定和类型转换', '29792a95-806b-46c3-9218-71ee39cb3d5a', '2', '3', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('13', '4.表达式语言(SpEL)', '29792a95-806b-46c3-9218-71ee39cb3d5a', '2', '4', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('14', '5.Spring面向切面编程', '29792a95-806b-46c3-9218-71ee39cb3d5a', '2', '5', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('15', '6.Spring AOP的APIs', '29792a95-806b-46c3-9218-71ee39cb3d5a', '2', '6', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('16', '7.Null安全', '29792a95-806b-46c3-9218-71ee39cb3d5a', '2', '7', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('17', '8.附录', '29792a95-806b-46c3-9218-71ee39cb3d5a', '2', '8', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('18', '1.1.Spring IoC容器和Bean的简介', '29792a95-806b-46c3-9218-71ee39cb3d5a', '10', '1', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('19', '1.2.容器概览', '29792a95-806b-46c3-9218-71ee39cb3d5a', '10', '1', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('20', '1.3.Bean概览', '29792a95-806b-46c3-9218-71ee39cb3d5a', '10', '1', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('21', '1.Spring测试模块介绍', '29792a95-806b-46c3-9218-71ee39cb3d5a', '3', '1', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('22', '1.4.依赖关系', '29792a95-806b-46c3-9218-71ee39cb3d5a', '10', '4', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('23', '1.5.Bean的范围', '29792a95-806b-46c3-9218-71ee39cb3d5a', '10', '5', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('24', '2.1.介绍', '29792a95-806b-46c3-9218-71ee39cb3d5a', '11', '1', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('25', '1.6.自定义Bean的特性', '29792a95-806b-46c3-9218-71ee39cb3d5a', '10', '6', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('26', '1.7.Bean定义的继承', '29792a95-806b-46c3-9218-71ee39cb3d5a', '10', '7', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('27', '1.事务管理', '29792a95-806b-46c3-9218-71ee39cb3d5a', '4', '1', '2', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('28', '1.1.Spring事务管理介绍', '29792a95-806b-46c3-9218-71ee39cb3d5a', '27', '1', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('29', '1.2.Spring事务支持模型的优势', '29792a95-806b-46c3-9218-71ee39cb3d5a', '27', '2', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('30', 'Nginx中文文档', 'c4d145ec-02bc-47ff-9543-244539fed90e', '0', '1', '0', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('31', '介绍', 'c4d145ec-02bc-47ff-9543-244539fed90e', '30', '1', '1', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('32', '安装Nginx', 'c4d145ec-02bc-47ff-9543-244539fed90e', '31', '1', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('33', '初学者教程', 'c4d145ec-02bc-47ff-9543-244539fed90e', '31', '2', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('34', '管理员教程（包括Nginx Plus）', 'c4d145ec-02bc-47ff-9543-244539fed90e', '30', '2', '1', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('35', '控制Nginx', 'c4d145ec-02bc-47ff-9543-244539fed90e', '31', '4', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('36', '2.DAO支持', '29792a95-806b-46c3-9218-71ee39cb3d5a', '4', '2', '2', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('37', '2.1.介绍', '29792a95-806b-46c3-9218-71ee39cb3d5a', '36', '1', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('38', '2.2.一致的异常层次', '29792a95-806b-46c3-9218-71ee39cb3d5a', '36', '2', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('39', '2.3.使用注解配置DAO和Repositoy', '29792a95-806b-46c3-9218-71ee39cb3d5a', '36', '3', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('40', '3.JDBC数据访问', '29792a95-806b-46c3-9218-71ee39cb3d5a', '4', '3', '2', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('41', '4.对象关系映射数据访问', '29792a95-806b-46c3-9218-71ee39cb3d5a', '4', '4', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('42', '3.1.Spring Framework的JDBC介绍', '29792a95-806b-46c3-9218-71ee39cb3d5a', '40', '1', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('43', 'Spring Boot中文文档', '6415d31f-beea-4064-aa9c-757f76d27ca2', '0', '1', '0', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('44', 'Part1 Spring Boot文档', '6415d31f-beea-4064-aa9c-757f76d27ca2', '43', '1', '1', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('45', '1.关于本文档', '6415d31f-beea-4064-aa9c-757f76d27ca2', '44', '1', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('46', '2.获取帮助', '6415d31f-beea-4064-aa9c-757f76d27ca2', '44', '2', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('47', '3.第一步', '6415d31f-beea-4064-aa9c-757f76d27ca2', '44', '3', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('48', '4.使用Spring Boot', '6415d31f-beea-4064-aa9c-757f76d27ca2', '44', '4', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('49', '5.了解Spring Boot的功能', '6415d31f-beea-4064-aa9c-757f76d27ca2', '44', '5', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('50', '6.转向生产', '6415d31f-beea-4064-aa9c-757f76d27ca2', '44', '6', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('51', '7.高级主题', '6415d31f-beea-4064-aa9c-757f76d27ca2', '44', '7', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('52', 'Part2 开始', '6415d31f-beea-4064-aa9c-757f76d27ca2', '43', '2', '1', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('53', '8.Spring Boot介绍', '6415d31f-beea-4064-aa9c-757f76d27ca2', '52', '1', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('54', '9.系统需求', '6415d31f-beea-4064-aa9c-757f76d27ca2', '52', '2', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('55', '19.运行应用程序', '6415d31f-beea-4064-aa9c-757f76d27ca2', '67', '7', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('56', '10.安装Spring Boot', '6415d31f-beea-4064-aa9c-757f76d27ca2', '52', '3', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('57', '20.开发者工具', '6415d31f-beea-4064-aa9c-757f76d27ca2', '67', '8', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('58', '11.开发第一个Spring Boot应用程序', '6415d31f-beea-4064-aa9c-757f76d27ca2', '52', '4', '2', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('59', '12.下一部分内容预览', '6415d31f-beea-4064-aa9c-757f76d27ca2', '52', '5', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('60', '10.2 安装Spring Boot CLI', '6415d31f-beea-4064-aa9c-757f76d27ca2', '56', '2', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('61', '11.1 创建POM', '6415d31f-beea-4064-aa9c-757f76d27ca2', '58', '1', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('62', '11.2 添加类路径依赖', '6415d31f-beea-4064-aa9c-757f76d27ca2', '58', '2', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('63', '11.3 编写代码', '6415d31f-beea-4064-aa9c-757f76d27ca2', '58', '3', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('64', '10.3 升级低版本Spring Boot', '6415d31f-beea-4064-aa9c-757f76d27ca2', '56', '3', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('65', '11.4 运行实例', '6415d31f-beea-4064-aa9c-757f76d27ca2', '58', '4', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('66', '11.5 创建可运行的JAR文件', '6415d31f-beea-4064-aa9c-757f76d27ca2', '58', '5', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('67', 'Part3 使用Spring Boot', '6415d31f-beea-4064-aa9c-757f76d27ca2', '43', '3', '1', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('68', '连接处理方法', 'c4d145ec-02bc-47ff-9543-244539fed90e', '31', '5', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('69', 'Nginx负载均衡 - HTTP', '3494e096-41da-4235-b13f-bd72f9f8f28b', '0', '1', '0', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('70', '负载均衡概览', '3494e096-41da-4235-b13f-bd72f9f8f28b', '69', '1', '1', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('71', '负载均衡', 'c4d145ec-02bc-47ff-9543-244539fed90e', '34', '1', '2', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('72', 'HTTP负载均衡器', 'c4d145ec-02bc-47ff-9543-244539fed90e', '71', '1', '3', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('73', '作为HTTP负载均衡器', 'c4d145ec-02bc-47ff-9543-244539fed90e', '31', '5', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('74', 'Linux指令大全中文文档', 'f4e3b441-dc74-484a-9022-15d4d63a4a1b', '0', '1', '0', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('75', 'a*', 'f4e3b441-dc74-484a-9022-15d4d63a4a1b', '74', '1', '1', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('76', 'b*', 'f4e3b441-dc74-484a-9022-15d4d63a4a1b', '74', '2', '1', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('77', 'c*', 'f4e3b441-dc74-484a-9022-15d4d63a4a1b', '74', '3', '1', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('78', 'd*', 'f4e3b441-dc74-484a-9022-15d4d63a4a1b', '74', '4', '1', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('79', 'e*', 'f4e3b441-dc74-484a-9022-15d4d63a4a1b', '74', '5', '1', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('80', 'f*', 'f4e3b441-dc74-484a-9022-15d4d63a4a1b', '74', '6', '1', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('81', 'g*', 'f4e3b441-dc74-484a-9022-15d4d63a4a1b', '74', '7', '1', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('82', 'h*', 'f4e3b441-dc74-484a-9022-15d4d63a4a1b', '74', '8', '1', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('83', 'i*', 'f4e3b441-dc74-484a-9022-15d4d63a4a1b', '74', '9', '1', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('84', 'j*', 'f4e3b441-dc74-484a-9022-15d4d63a4a1b', '74', '10', '1', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('85', '网络状态管理', 'f4e3b441-dc74-484a-9022-15d4d63a4a1b', '74', '11', '1', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('86', '系统和硬件管理', 'f4e3b441-dc74-484a-9022-15d4d63a4a1b', '74', '12', '1', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('87', 'lscpu - 查询CPU信息', 'f4e3b441-dc74-484a-9022-15d4d63a4a1b', '86', '1', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('88', 'netstat - 查询端口状态', 'f4e3b441-dc74-484a-9022-15d4d63a4a1b', '85', '1', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('89', '模块说明', 'c4d145ec-02bc-47ff-9543-244539fed90e', '30', '3', '1', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('90', 'ngx_stub_status_module', 'c4d145ec-02bc-47ff-9543-244539fed90e', '89', '1', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('91', 'ngx_req_status_module', 'c4d145ec-02bc-47ff-9543-244539fed90e', '89', '2', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('92', '13.构建工具', '6415d31f-beea-4064-aa9c-757f76d27ca2', '67', '1', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('93', '14.构造代码', '6415d31f-beea-4064-aa9c-757f76d27ca2', '67', '2', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('94', '15.配置类', '6415d31f-beea-4064-aa9c-757f76d27ca2', '67', '3', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('95', '16.自动配置', '6415d31f-beea-4064-aa9c-757f76d27ca2', '67', '4', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('96', '17.Spring的Bean与依赖注入', '6415d31f-beea-4064-aa9c-757f76d27ca2', '67', '5', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('97', '18.使用@SpringBootApplication注解', '6415d31f-beea-4064-aa9c-757f76d27ca2', '67', '6', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('98', 'ngx_http_log_module', 'c4d145ec-02bc-47ff-9543-244539fed90e', '89', '3', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('99', 'uname - 查询系统信息', 'f4e3b441-dc74-484a-9022-15d4d63a4a1b', '86', '2', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('100', 'ngx_http_map_module', 'c4d145ec-02bc-47ff-9543-244539fed90e', '89', '4', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('101', '学习到深入', 'c4d145ec-02bc-47ff-9543-244539fed90e', '30', '4', '1', '1', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('102', '1.Nginx的安装与升级', 'c4d145ec-02bc-47ff-9543-244539fed90e', '101', '1', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('103', '2.Nginx的优化', 'c4d145ec-02bc-47ff-9543-244539fed90e', '101', '2', '2', '0', '1', null, null, null, null);
INSERT INTO `translation_struct` VALUES ('105', 'Quartz中文文档', 'a6ad4f07-712b-4c2f-8b4b-0c157e2bee95', '0', '1', '0', '1', null, null, null, null, '3');
INSERT INTO `translation_struct` VALUES ('106', '快速开始', 'a6ad4f07-712b-4c2f-8b4b-0c157e2bee95', '105', '1', '1', '0', null, null, null, null, '1');
INSERT INTO `translation_struct` VALUES ('107', '新特性', 'a6ad4f07-712b-4c2f-8b4b-0c157e2bee95', '105', '2', '1', '0', null, null, null, null, '1');
INSERT INTO `translation_struct` VALUES ('108', '教程', 'a6ad4f07-712b-4c2f-8b4b-0c157e2bee95', '105', '3', '1', '1', null, null, null, null, '3');
INSERT INTO `translation_struct` VALUES ('109', '实例', 'a6ad4f07-712b-4c2f-8b4b-0c157e2bee95', '105', '4', '1', '0', null, null, null, null, '1');
INSERT INTO `translation_struct` VALUES ('110', '使用Quartz', 'a6ad4f07-712b-4c2f-8b4b-0c157e2bee95', '108', '1', '2', '0', '2', null, null, null, '1');
INSERT INTO `translation_struct` VALUES ('111', 'Quartz API、Job和Trigger的简介', 'a6ad4f07-712b-4c2f-8b4b-0c157e2bee95', '108', '2', '2', '0', '2', null, '1', null, '1');

-- ----------------------------
-- Table structure for ts_key
-- ----------------------------
DROP TABLE IF EXISTS `ts_key`;
CREATE TABLE `ts_key` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '键ID',
  `name` varchar(50) DEFAULT NULL COMMENT '键名',
  `chinese` varchar(20) DEFAULT NULL COMMENT '中文名',
  `descr` varchar(100) DEFAULT NULL COMMENT '描述',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of ts_key
-- ----------------------------
INSERT INTO `ts_key` VALUES ('1', 'blogType', '博客类型', '1-原创，2-转载，3-翻译');

-- ----------------------------
-- Table structure for ts_key_value
-- ----------------------------
DROP TABLE IF EXISTS `ts_key_value`;
CREATE TABLE `ts_key_value` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '值ID',
  `name` varchar(255) DEFAULT NULL COMMENT '值',
  `chinese` varchar(20) DEFAULT NULL COMMENT '中文名',
  `descr` varchar(100) DEFAULT NULL COMMENT '描述',
  `sort` int(2) DEFAULT NULL COMMENT '排序',
  `key_id` int(11) DEFAULT NULL COMMENT '键ID',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of ts_key_value
-- ----------------------------
INSERT INTO `ts_key_value` VALUES ('1', '1', '原创', '博客类型', '1', '1');
INSERT INTO `ts_key_value` VALUES ('2', '2', '转载', '博客类型', '2', '1');
INSERT INTO `ts_key_value` VALUES ('3', '3', '翻译', '博客类型', '3', '1');

-- ----------------------------
-- Table structure for ts_log
-- ----------------------------
DROP TABLE IF EXISTS `ts_log`;
CREATE TABLE `ts_log` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '日志ID',
  `op_type` varchar(20) DEFAULT NULL COMMENT '操作类型：query、delete、update、insert等',
  `op_result` int(1) DEFAULT NULL COMMENT '操作结果：0-失败，1-成功',
  `op_info` varchar(255) DEFAULT NULL COMMENT '操作结果描述',
  `op_class` varchar(100) DEFAULT NULL COMMENT '操作类路径',
  `op_method` varchar(20) DEFAULT NULL COMMENT '操作方法',
  `op_time` datetime DEFAULT NULL COMMENT '操作时间',
  `op_user` int(11) DEFAULT NULL COMMENT '操作用户',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of ts_log
-- ----------------------------
INSERT INTO `ts_log` VALUES ('1', 'auth', '0', 'javax.persistence.PersistenceException: org.hibernate.exception.SQLGrammarException: could not extract ResultSet', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-20 09:51:50', '1');
INSERT INTO `ts_log` VALUES ('2', 'auth', '0', 'java.lang.StringIndexOutOfBoundsException: String index out of range: -1', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-20 09:54:23', '1');
INSERT INTO `ts_log` VALUES ('3', 'auth', '0', 'java.lang.StringIndexOutOfBoundsException: String index out of range: -1', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-20 09:58:31', '1');
INSERT INTO `ts_log` VALUES ('4', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-23 02:16:43', '1');
INSERT INTO `ts_log` VALUES ('5', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 01:42:04', '1');
INSERT INTO `ts_log` VALUES ('6', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 01:42:05', '1');
INSERT INTO `ts_log` VALUES ('7', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 01:42:58', '1');
INSERT INTO `ts_log` VALUES ('8', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 01:42:59', '1');
INSERT INTO `ts_log` VALUES ('9', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 01:43:01', '1');
INSERT INTO `ts_log` VALUES ('10', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 01:43:02', '1');
INSERT INTO `ts_log` VALUES ('11', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 01:43:02', '1');
INSERT INTO `ts_log` VALUES ('12', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 01:43:03', '1');
INSERT INTO `ts_log` VALUES ('13', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 01:43:04', '1');
INSERT INTO `ts_log` VALUES ('14', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 01:43:05', '1');
INSERT INTO `ts_log` VALUES ('15', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 01:47:19', '1');
INSERT INTO `ts_log` VALUES ('16', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 01:47:19', '1');
INSERT INTO `ts_log` VALUES ('17', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 01:55:58', '1');
INSERT INTO `ts_log` VALUES ('18', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 01:57:54', '1');
INSERT INTO `ts_log` VALUES ('19', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 01:57:54', '1');
INSERT INTO `ts_log` VALUES ('20', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 01:59:23', '1');
INSERT INTO `ts_log` VALUES ('21', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 01:59:25', '1');
INSERT INTO `ts_log` VALUES ('22', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 02:06:19', '1');
INSERT INTO `ts_log` VALUES ('23', 'auth', '0', 'java.lang.NullPointerException', 'chngzhen.web.base.authorization.IAuthorization', 'preHandle', '2017-11-24 02:06:21', '1');

-- ----------------------------
-- Table structure for ts_module
-- ----------------------------
DROP TABLE IF EXISTS `ts_module`;
CREATE TABLE `ts_module` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '模块ID',
  `name` varchar(10) DEFAULT NULL COMMENT '中文名称',
  `type` int(1) DEFAULT NULL COMMENT '模块类型:1-父节点,2-页面,3-按钮',
  `url` varchar(100) DEFAULT NULL COMMENT '链接地址',
  `target` varchar(10) DEFAULT NULL COMMENT '链接方式:_blank,_self,_parent,_top',
  `parent_id` int(11) DEFAULT NULL COMMENT '父节点',
  `level` int(2) DEFAULT NULL COMMENT '层级:从1开始',
  `icon` varchar(20) DEFAULT NULL COMMENT '图标',
  `auth_name` varchar(50) DEFAULT NULL COMMENT '权限名称',
  `sort` int(2) DEFAULT NULL COMMENT '排序:从1开始',
  `root_id` int(11) DEFAULT NULL COMMENT '根节点ID',
  `is_parent` int(1) DEFAULT NULL COMMENT '是否父节点',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of ts_module
-- ----------------------------
INSERT INTO `ts_module` VALUES ('1', '根节点', '1', '#', null, '0', '0', null, null, '1', '0', '1');
INSERT INTO `ts_module` VALUES ('2', '门户网站', '1', '#', null, '1', '1', null, null, '1', '2', '1');
INSERT INTO `ts_module` VALUES ('3', '后台管理', '1', '#', null, '1', '1', null, null, '2', '3', '1');
INSERT INTO `ts_module` VALUES ('4', '查询与统计', '2', '#', null, '3', '2', null, null, '1', '3', '1');
INSERT INTO `ts_module` VALUES ('5', '系统与配置', '2', '#', null, '3', '2', null, null, '2', '3', '1');
INSERT INTO `ts_module` VALUES ('6', '个人博客', '3', '/blog/statistics', null, '4', '3', null, 'blog_statistics', '1', '3', '0');
INSERT INTO `ts_module` VALUES ('7', '菜单模块管理', '3', '/tsmodule', null, '5', '3', null, 'tsmodule', '1', '3', '0');
INSERT INTO `ts_module` VALUES ('8', '首页', '3', '/index', '', '2', '2', 'fa fa-home', 'index', '1', '2', '1');
INSERT INTO `ts_module` VALUES ('9', '博客', '3', '/blog', '', '2', '2', 'fa fa-book', 'blog', '2', '2', '1');
INSERT INTO `ts_module` VALUES ('10', '新建', '4', '/blog/new', '', '9', '3', '', 'blog_insert', '1', '2', '0');
INSERT INTO `ts_module` VALUES ('11', '编辑', '4', '/blog/edit', '', '9', '3', '', 'blog_update', '2', '2', '0');
INSERT INTO `ts_module` VALUES ('12', '删除', '4', '/blog/del', '', '9', '3', '', 'blog_delete', '3', '2', '0');
INSERT INTO `ts_module` VALUES ('13', '查询', '4', '/blog/view', null, '9', '3', null, 'blog_query', '4', '2', '0');
INSERT INTO `ts_module` VALUES ('15', '解决方案', '3', '/issue', '', '2', '2', 'fa fa-list-alt', 'issue', '3', '2', '1');
INSERT INTO `ts_module` VALUES ('16', '新增', '4', '/issue/new', '', '15', '3', '', 'issue_save', '1', '2', '0');
INSERT INTO `ts_module` VALUES ('17', '用户管理', '3', '/tsusermodule', '', '5', '3', '', 'tsusermodule', '2', '3', '0');
INSERT INTO `ts_module` VALUES ('18', '新增', '4', '/tsusermodule/new', null, '17', '4', null, 'tsusermodule_save', '1', '3', '0');
INSERT INTO `ts_module` VALUES ('19', '查看', '4', '/tsusermodule/view', null, '17', '4', null, 'tsusermodule_query', '2', '3', '0');
INSERT INTO `ts_module` VALUES ('20', '编辑', '4', '/tsusermodule/edit', null, '17', '4', null, 'tsusermodule_update', '3', '3', '0');
INSERT INTO `ts_module` VALUES ('21', '删除', '4', '/tsusermodule/del', null, '17', '4', null, 'tsusermodule_delete', '4', '3', '0');

-- ----------------------------
-- Table structure for ts_role
-- ----------------------------
DROP TABLE IF EXISTS `ts_role`;
CREATE TABLE `ts_role` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '角色ID',
  `name` varchar(10) DEFAULT NULL COMMENT '中文名称',
  `org_id` int(11) DEFAULT NULL COMMENT '隶属组织',
  `status` int(1) DEFAULT NULL COMMENT '角色状态:1-正常;0-禁用',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of ts_role
-- ----------------------------

-- ----------------------------
-- Table structure for ts_role_module
-- ----------------------------
DROP TABLE IF EXISTS `ts_role_module`;
CREATE TABLE `ts_role_module` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '记录ID',
  `role_id` int(11) DEFAULT NULL COMMENT '角色ID',
  `module_id` int(11) DEFAULT NULL COMMENT '模块ID',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of ts_role_module
-- ----------------------------

-- ----------------------------
-- Table structure for ts_test
-- ----------------------------
DROP TABLE IF EXISTS `ts_test`;
CREATE TABLE `ts_test` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '记录ID',
  `bit_set` varchar(255) DEFAULT NULL COMMENT 'BitSet数据',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of ts_test
-- ----------------------------
INSERT INTO `ts_test` VALUES ('1', '100000,1000001');
INSERT INTO `ts_test` VALUES ('2', '-111111111111111111111111110111111111111111111111111111111111110');
INSERT INTO `ts_test` VALUES ('3', '1000000000000000000000000000000000010,1');

-- ----------------------------
-- Table structure for ts_user
-- ----------------------------
DROP TABLE IF EXISTS `ts_user`;
CREATE TABLE `ts_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '用户ID',
  `role_id` int(11) DEFAULT NULL COMMENT '角色ID',
  `user_name` varchar(50) DEFAULT NULL COMMENT '登陆账号',
  `user_pswd` varchar(32) DEFAULT NULL COMMENT '登陆密码',
  `register_time` datetime DEFAULT NULL COMMENT '注册时间',
  `user_nick` varchar(20) DEFAULT NULL COMMENT '用户昵称',
  `link_email` varchar(50) DEFAULT NULL COMMENT '对外邮箱',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of ts_user
-- ----------------------------
INSERT INTO `ts_user` VALUES ('1', null, 'chngzhen', 'E10ADC3949BA59ABBE56E057F20F883E', '2017-09-26 18:17:24', '没错！我师父是霍元甲', null);
INSERT INTO `ts_user` VALUES ('2', null, 'chngzhen@outlook.com', 'E10ADC3949BA59ABBE56E057F20F883E', '2018-03-02 08:11:01', 'Chngzhen', '1069106742@qq.com');
INSERT INTO `ts_user` VALUES ('3', null, 'root', 'e10adc3949ba59abbe56e057f20f883e', null, null, null);

-- ----------------------------
-- Table structure for ts_user_module
-- ----------------------------
DROP TABLE IF EXISTS `ts_user_module`;
CREATE TABLE `ts_user_module` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '记录ID',
  `user_id` int(11) DEFAULT NULL COMMENT '用户ID',
  `module_id` int(11) DEFAULT NULL COMMENT '模块ID',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of ts_user_module
-- ----------------------------
INSERT INTO `ts_user_module` VALUES ('1', '1', '9');
INSERT INTO `ts_user_module` VALUES ('2', '1', '10');
INSERT INTO `ts_user_module` VALUES ('3', '1', '11');
INSERT INTO `ts_user_module` VALUES ('4', '1', '12');
INSERT INTO `ts_user_module` VALUES ('5', '1', '13');

-- ----------------------------
-- Table structure for word
-- ----------------------------
DROP TABLE IF EXISTS `word`;
CREATE TABLE `word` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '单词ID',
  `word` varchar(255) DEFAULT NULL COMMENT '单词',
  `language` int(2) DEFAULT NULL COMMENT '语种',
  `phonetic_eng` varchar(255) DEFAULT NULL COMMENT '英式发音',
  `phonetic_ame` varchar(255) DEFAULT NULL COMMENT '美式发音',
  `create_time` datetime DEFAULT CURRENT_TIMESTAMP COMMENT '添加时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=37 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of word
-- ----------------------------
INSERT INTO `word` VALUES ('1', 'prototype', null, 'ˈprəʊtətaɪp', 'ˈproʊtətaɪp', '2018-01-03 09:13:55');
INSERT INTO `word` VALUES ('2', 'prototypical', null, 'ˌprəʊtə\'tɪpɪkl', ',protə\'tɪpɪkl', '2018-01-09 08:49:31');
INSERT INTO `word` VALUES ('3', 'contrast', null, 'ˈkɒntrɑ:st', 'ˈkɑ:ntræst', '2018-01-03 09:13:57');
INSERT INTO `word` VALUES ('4', 'contrastive', null, 'kənˈtrɑ:stɪv', 'kənˈtræstɪv', '2018-01-09 08:54:54');
INSERT INTO `word` VALUES ('5', 'contrasty', null, '\'kɒntrɑːstɪ', 'kən\'træsti', '2018-01-09 08:57:51');
INSERT INTO `word` VALUES ('6', 'scope', null, 'skəʊp', 'skoʊp', '2018-01-03 09:13:59');
INSERT INTO `word` VALUES ('7', 'assemble', null, 'əˈsembl', 'əˈsɛmbəl', '2018-01-03 09:14:02');
INSERT INTO `word` VALUES ('8', 'assembled', null, 'ə\'sembəld', 'ə\'sembld', '2018-01-09 14:24:44');
INSERT INTO `word` VALUES ('9', 'assembling', null, 'ə\'semblɪŋ', 'ə\'semblɪŋ', '2018-01-09 14:26:29');
INSERT INTO `word` VALUES ('10', 'assembly', null, 'ə\'semblɪ', 'ə\'sɛmbli', '2018-01-09 14:27:43');
INSERT INTO `word` VALUES ('11', 'assemblage', null, 'ə\'semblɪdʒ', 'ə\'sɛmblɪdʒ', '2018-01-09 14:28:40');
INSERT INTO `word` VALUES ('12', 'assembler', null, 'ə\'semblə', 'ə\'sɛmblɚ', '2018-01-09 14:29:30');
INSERT INTO `word` VALUES ('13', 'regardless', null, 'rɪˈgɑ:dləs', 'rɪˈgɑ:rdləs', '2018-01-03 09:14:04');
INSERT INTO `word` VALUES ('14', 'regardful', null, 'rɪ\'gɑ:dfəl', 'rɪ\'gɑ:dfəl', '2018-01-09 17:04:11');
INSERT INTO `word` VALUES ('15', 'regard', null, 'rɪ\'gɑːd', 'rɪ\'ɡɑrd', '2018-01-09 17:04:57');
INSERT INTO `word` VALUES ('16', 'interact', null, 'ˌɪntərˈækt', 'ˌɪntɚˈækt', '2018-01-04 09:43:15');
INSERT INTO `word` VALUES ('17', 'interactive', null, 'ɪntər\'æktɪv', ',ɪntɚ\'æktɪv', '2018-01-09 17:07:51');
INSERT INTO `word` VALUES ('18', 'interactional', null, ',intər\'ækʃənl', ',intər\'ækʃənl', '2018-01-09 17:08:36');
INSERT INTO `word` VALUES ('19', 'interaction', null, 'ɪntər\'ækʃ(ə)n', ',ɪntə\'rækʃən', '2018-01-09 17:09:54');
INSERT INTO `word` VALUES ('20', 'participate', null, 'pɑ:ˈtɪsɪpeɪt', 'pɑ:rˈtɪsɪpeɪt', '2018-01-04 09:43:27');
INSERT INTO `word` VALUES ('21', 'participant', null, 'pɑː\'tɪsɪp(ə)nt', 'pɑr\'tɪsəpənt', '2018-01-09 17:11:49');
INSERT INTO `word` VALUES ('22', 'participatory', null, 'pɑ:tɪsɪ\'peɪtərɪ', 'pɑr\'tɪsəpətɔri', '2018-01-09 17:12:54');
INSERT INTO `word` VALUES ('23', 'participating', null, 'pɑː\'tɪsɪpeɪtɪŋ', 'pɑr\'tɪsə,petɪŋ', '2018-01-09 17:13:35');
INSERT INTO `word` VALUES ('24', 'participation', null, 'pɑː,tɪsɪ\'peɪʃn', 'pɑr,tɪsɪ\'peʃən', '2018-01-09 17:14:23');
INSERT INTO `word` VALUES ('25', 'alternatively', null, 'ɔ:lˈtɜ:nətɪvli', 'ɔ:lˈtɜ:rnətɪvli', '2018-01-04 09:43:45');
INSERT INTO `word` VALUES ('26', 'alternative', null, 'ɔːl\'tɜːnətɪv; ɒl-', 'ɔl\'tɝnətɪv', '2018-01-09 17:15:37');
INSERT INTO `word` VALUES ('27', 'consistency', null, 'kənˈsɪstənsi', 'kənˈsɪstənsi', '2018-01-04 09:44:10');
INSERT INTO `word` VALUES ('28', 'consistent', null, 'kən\'sɪst(ə)nt', 'kən\'sɪstənt', '2018-01-09 17:17:37');
INSERT INTO `word` VALUES ('29', 'consistently', null, 'kən\'sɪstəntli', 'kən\'sɪstəntli', '2018-01-09 17:18:12');
INSERT INTO `word` VALUES ('30', 'accordance', null, 'əˈkɔ:dns', 'əˈkɔ:rdns', '2018-01-04 09:44:25');
INSERT INTO `word` VALUES ('31', 'accordant', null, 'ə\'kɔːd(ə)nt', 'ə\'kɔrdənt', '2018-01-09 17:19:58');
INSERT INTO `word` VALUES ('32', 'accord', null, 'ə\'kɔːd', 'ə\'kɔrd', '2018-01-09 17:20:44');
INSERT INTO `word` VALUES ('33', 'invasive', null, 'ɪn\'veɪsɪv', 'ɪn\'vesɪv', '2018-01-10 14:15:53');
INSERT INTO `word` VALUES ('34', 'invasion', null, 'ɪn\'veɪʒ(ə)n', 'ɪn\'veʒn', '2018-01-10 14:17:23');
INSERT INTO `word` VALUES ('35', 'invader', null, 'ɪn\'veɪdə(r)', 'ɪn\'vedɚ', '2018-01-10 14:18:41');
INSERT INTO `word` VALUES ('36', 'invade', null, 'ɪn\'veɪd', 'ɪn\'ved', '2018-01-10 14:19:15');

-- ----------------------------
-- Table structure for word_explain
-- ----------------------------
DROP TABLE IF EXISTS `word_explain`;
CREATE TABLE `word_explain` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '翻译ID',
  `part` int(1) DEFAULT NULL COMMENT '词性ID：1-n，2-vi，3-vt，4-v，5-adv，6-adj',
  `chinese` varchar(255) DEFAULT NULL COMMENT '中文翻译',
  `word_id` int(11) DEFAULT NULL COMMENT '单词ID',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=53 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of word_explain
-- ----------------------------
INSERT INTO `word_explain` VALUES ('1', '1', '原型，雏形，蓝本', '1');
INSERT INTO `word_explain` VALUES ('2', '1', '对比，对照;差异;对照物，对立面;[摄]反差', '3');
INSERT INTO `word_explain` VALUES ('3', '2', '对比;形成对照', '3');
INSERT INTO `word_explain` VALUES ('4', '3', '使对照，使对比;和…形成对照', '3');
INSERT INTO `word_explain` VALUES ('5', '1', '处理、研究事务的）范围;眼界，见识;（活动或能力的）余地;广袤，地域', '6');
INSERT INTO `word_explain` VALUES ('6', '4', '审视，仔细研究', '6');
INSERT INTO `word_explain` VALUES ('7', '4', '集合，收集', '7');
INSERT INTO `word_explain` VALUES ('8', '3', '装配，组合', '7');
INSERT INTO `word_explain` VALUES ('9', '5', '不顾后果地;不管怎样，无论如何;不惜费用地', '13');
INSERT INTO `word_explain` VALUES ('10', '6', '不重视的，不尊敬的;不顾虑的，不关心的;不受注意的，毫无价值的', '13');
INSERT INTO `word_explain` VALUES ('11', '4', '互动;相互作用;互相影响', '16');
INSERT INTO `word_explain` VALUES ('12', '2', '参加某事;分享某事', '20');
INSERT INTO `word_explain` VALUES ('13', '3', '得到或接受某部分东西', '20');
INSERT INTO `word_explain` VALUES ('14', '5', '或者;二者择一地;要不然', '25');
INSERT INTO `word_explain` VALUES ('15', '1', '浓度;连贯;符合;前后一致', '27');
INSERT INTO `word_explain` VALUES ('16', '1', '一致;和谐;给予', '30');
INSERT INTO `word_explain` VALUES ('17', '6', '原型的；典型的', '2');
INSERT INTO `word_explain` VALUES ('18', '6', '对比的', '4');
INSERT INTO `word_explain` VALUES ('19', '6', '硬调的，明暗差别强烈的', '5');
INSERT INTO `word_explain` VALUES ('20', '6', '组合的；安装的', '8');
INSERT INTO `word_explain` VALUES ('21', '4', '集合，收集( assemble的过去式和过去分词 );装配，组合', '8');
INSERT INTO `word_explain` VALUES ('22', '1', '装配；[计] 汇编', '9');
INSERT INTO `word_explain` VALUES ('23', '6', '装配的；组合的', '9');
INSERT INTO `word_explain` VALUES ('24', '4', '装配（assemble的ing形式）；聚集', '9');
INSERT INTO `word_explain` VALUES ('25', '1', '装配；集会，集合', '10');
INSERT INTO `word_explain` VALUES ('26', '1', '装配；集合；聚集；集会；集合物；聚集的物或人', '11');
INSERT INTO `word_explain` VALUES ('27', '1', '汇编程序；汇编机；装配工', '12');
INSERT INTO `word_explain` VALUES ('28', '6', '留心的，关心的，表示敬意的', '14');
INSERT INTO `word_explain` VALUES ('29', '1', '注意；尊重；问候；凝视', '15');
INSERT INTO `word_explain` VALUES ('30', '3', '注重，考虑；看待；尊敬；把…看作；与…有关', '15');
INSERT INTO `word_explain` VALUES ('31', '2', '注意，注重；注视', '15');
INSERT INTO `word_explain` VALUES ('32', '6', '交互式的；相互作用的', '17');
INSERT INTO `word_explain` VALUES ('33', '6', '相互作用的', '18');
INSERT INTO `word_explain` VALUES ('34', '1', '相互作用；[数] 交互作用；互动', '19');
INSERT INTO `word_explain` VALUES ('35', '6', '参与的；有关系的', '21');
INSERT INTO `word_explain` VALUES ('36', '1', '参与者；关系者', '21');
INSERT INTO `word_explain` VALUES ('37', '6', '供人分享的；吸引参与的', '22');
INSERT INTO `word_explain` VALUES ('38', '6', '由多人一起参加的；（股票等）持有人有权分享利益的', '23');
INSERT INTO `word_explain` VALUES ('39', '1', '参与；分享；参股', '24');
INSERT INTO `word_explain` VALUES ('40', '6', '供选择的；选择性的；交替的', '26');
INSERT INTO `word_explain` VALUES ('41', '1', '二中择一；供替代的选择', '26');
INSERT INTO `word_explain` VALUES ('42', '6', '始终如一的，一致的；坚持的', '28');
INSERT INTO `word_explain` VALUES ('43', '5', '一贯地，坚持地，固守地;总', '29');
INSERT INTO `word_explain` VALUES ('44', '6', '一致的；调和的', '31');
INSERT INTO `word_explain` VALUES ('45', '1', '符合；一致；协议；自愿', '32');
INSERT INTO `word_explain` VALUES ('46', '3', '使一致；给予', '32');
INSERT INTO `word_explain` VALUES ('47', '2', '符合；一致', '32');
INSERT INTO `word_explain` VALUES ('48', '6', '侵略性的；攻击性的', '33');
INSERT INTO `word_explain` VALUES ('49', '1', '入侵，侵略；侵袭；侵犯', '34');
INSERT INTO `word_explain` VALUES ('50', '1', '侵略者；侵入物', '35');
INSERT INTO `word_explain` VALUES ('51', '3', '侵略；侵袭；侵扰；涌入', '36');
INSERT INTO `word_explain` VALUES ('52', '2', '侵略；侵入；侵袭；侵犯', '36');
